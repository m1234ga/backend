
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model app_users
 * 
 */
export type app_users = $Result.DefaultSelection<Prisma.$app_usersPayload>
/**
 * Model chatAssignmentDetail
 * 
 */
export type chatAssignmentDetail = $Result.DefaultSelection<Prisma.$chatAssignmentDetailPayload>
/**
 * Model chatTags
 * 
 */
export type chatTags = $Result.DefaultSelection<Prisma.$chatTagsPayload>
/**
 * Model chat_status_details
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type chat_status_details = $Result.DefaultSelection<Prisma.$chat_status_detailsPayload>
/**
 * Model chatparticipants
 * 
 */
export type chatparticipants = $Result.DefaultSelection<Prisma.$chatparticipantsPayload>
/**
 * Model chats
 * 
 */
export type chats = $Result.DefaultSelection<Prisma.$chatsPayload>
/**
 * Model cleaned_contacts
 * 
 */
export type cleaned_contacts = $Result.DefaultSelection<Prisma.$cleaned_contactsPayload>
/**
 * Model contacts
 * 
 */
export type contacts = $Result.DefaultSelection<Prisma.$contactsPayload>
/**
 * Model conversations
 * 
 */
export type conversations = $Result.DefaultSelection<Prisma.$conversationsPayload>
/**
 * Model groups
 * 
 */
export type groups = $Result.DefaultSelection<Prisma.$groupsPayload>
/**
 * Model messageTemplates
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type messageTemplates = $Result.DefaultSelection<Prisma.$messageTemplatesPayload>
/**
 * Model message_history
 * 
 */
export type message_history = $Result.DefaultSelection<Prisma.$message_historyPayload>
/**
 * Model message_reactions
 * 
 */
export type message_reactions = $Result.DefaultSelection<Prisma.$message_reactionsPayload>
/**
 * Model messages
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model tags
 * 
 */
export type tags = $Result.DefaultSelection<Prisma.$tagsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model whatsmeow_app_state_mutation_macs
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type whatsmeow_app_state_mutation_macs = $Result.DefaultSelection<Prisma.$whatsmeow_app_state_mutation_macsPayload>
/**
 * Model whatsmeow_app_state_sync_keys
 * 
 */
export type whatsmeow_app_state_sync_keys = $Result.DefaultSelection<Prisma.$whatsmeow_app_state_sync_keysPayload>
/**
 * Model whatsmeow_app_state_version
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type whatsmeow_app_state_version = $Result.DefaultSelection<Prisma.$whatsmeow_app_state_versionPayload>
/**
 * Model whatsmeow_chat_settings
 * 
 */
export type whatsmeow_chat_settings = $Result.DefaultSelection<Prisma.$whatsmeow_chat_settingsPayload>
/**
 * Model whatsmeow_contacts
 * 
 */
export type whatsmeow_contacts = $Result.DefaultSelection<Prisma.$whatsmeow_contactsPayload>
/**
 * Model whatsmeow_device
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type whatsmeow_device = $Result.DefaultSelection<Prisma.$whatsmeow_devicePayload>
/**
 * Model whatsmeow_event_buffer
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type whatsmeow_event_buffer = $Result.DefaultSelection<Prisma.$whatsmeow_event_bufferPayload>
/**
 * Model whatsmeow_identity_keys
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type whatsmeow_identity_keys = $Result.DefaultSelection<Prisma.$whatsmeow_identity_keysPayload>
/**
 * Model whatsmeow_lid_map
 * 
 */
export type whatsmeow_lid_map = $Result.DefaultSelection<Prisma.$whatsmeow_lid_mapPayload>
/**
 * Model whatsmeow_message_secrets
 * 
 */
export type whatsmeow_message_secrets = $Result.DefaultSelection<Prisma.$whatsmeow_message_secretsPayload>
/**
 * Model whatsmeow_pre_keys
 * This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
 */
export type whatsmeow_pre_keys = $Result.DefaultSelection<Prisma.$whatsmeow_pre_keysPayload>
/**
 * Model whatsmeow_privacy_tokens
 * 
 */
export type whatsmeow_privacy_tokens = $Result.DefaultSelection<Prisma.$whatsmeow_privacy_tokensPayload>
/**
 * Model whatsmeow_sender_keys
 * 
 */
export type whatsmeow_sender_keys = $Result.DefaultSelection<Prisma.$whatsmeow_sender_keysPayload>
/**
 * Model whatsmeow_sessions
 * 
 */
export type whatsmeow_sessions = $Result.DefaultSelection<Prisma.$whatsmeow_sessionsPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more App_users
 * const app_users = await prisma.app_users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more App_users
   * const app_users = await prisma.app_users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs, $Utils.Call<Prisma.TypeMapCb, {
    extArgs: ExtArgs
  }>, ClientOptions>

      /**
   * `prisma.app_users`: Exposes CRUD operations for the **app_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more App_users
    * const app_users = await prisma.app_users.findMany()
    * ```
    */
  get app_users(): Prisma.app_usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatAssignmentDetail`: Exposes CRUD operations for the **chatAssignmentDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatAssignmentDetails
    * const chatAssignmentDetails = await prisma.chatAssignmentDetail.findMany()
    * ```
    */
  get chatAssignmentDetail(): Prisma.chatAssignmentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatTags`: Exposes CRUD operations for the **chatTags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatTags
    * const chatTags = await prisma.chatTags.findMany()
    * ```
    */
  get chatTags(): Prisma.chatTagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chat_status_details`: Exposes CRUD operations for the **chat_status_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chat_status_details
    * const chat_status_details = await prisma.chat_status_details.findMany()
    * ```
    */
  get chat_status_details(): Prisma.chat_status_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chatparticipants`: Exposes CRUD operations for the **chatparticipants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chatparticipants
    * const chatparticipants = await prisma.chatparticipants.findMany()
    * ```
    */
  get chatparticipants(): Prisma.chatparticipantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.chats`: Exposes CRUD operations for the **chats** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chats
    * const chats = await prisma.chats.findMany()
    * ```
    */
  get chats(): Prisma.chatsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaned_contacts`: Exposes CRUD operations for the **cleaned_contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cleaned_contacts
    * const cleaned_contacts = await prisma.cleaned_contacts.findMany()
    * ```
    */
  get cleaned_contacts(): Prisma.cleaned_contactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contacts`: Exposes CRUD operations for the **contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contacts.findMany()
    * ```
    */
  get contacts(): Prisma.contactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversations`: Exposes CRUD operations for the **conversations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversations.findMany()
    * ```
    */
  get conversations(): Prisma.conversationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.groups`: Exposes CRUD operations for the **groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Groups
    * const groups = await prisma.groups.findMany()
    * ```
    */
  get groups(): Prisma.groupsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageTemplates`: Exposes CRUD operations for the **messageTemplates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageTemplates
    * const messageTemplates = await prisma.messageTemplates.findMany()
    * ```
    */
  get messageTemplates(): Prisma.messageTemplatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message_history`: Exposes CRUD operations for the **message_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Message_histories
    * const message_histories = await prisma.message_history.findMany()
    * ```
    */
  get message_history(): Prisma.message_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message_reactions`: Exposes CRUD operations for the **message_reactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Message_reactions
    * const message_reactions = await prisma.message_reactions.findMany()
    * ```
    */
  get message_reactions(): Prisma.message_reactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tags`: Exposes CRUD operations for the **tags** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tags.findMany()
    * ```
    */
  get tags(): Prisma.tagsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_app_state_mutation_macs`: Exposes CRUD operations for the **whatsmeow_app_state_mutation_macs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_app_state_mutation_macs
    * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findMany()
    * ```
    */
  get whatsmeow_app_state_mutation_macs(): Prisma.whatsmeow_app_state_mutation_macsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_app_state_sync_keys`: Exposes CRUD operations for the **whatsmeow_app_state_sync_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_app_state_sync_keys
    * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findMany()
    * ```
    */
  get whatsmeow_app_state_sync_keys(): Prisma.whatsmeow_app_state_sync_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_app_state_version`: Exposes CRUD operations for the **whatsmeow_app_state_version** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_app_state_versions
    * const whatsmeow_app_state_versions = await prisma.whatsmeow_app_state_version.findMany()
    * ```
    */
  get whatsmeow_app_state_version(): Prisma.whatsmeow_app_state_versionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_chat_settings`: Exposes CRUD operations for the **whatsmeow_chat_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_chat_settings
    * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findMany()
    * ```
    */
  get whatsmeow_chat_settings(): Prisma.whatsmeow_chat_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_contacts`: Exposes CRUD operations for the **whatsmeow_contacts** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_contacts
    * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findMany()
    * ```
    */
  get whatsmeow_contacts(): Prisma.whatsmeow_contactsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_device`: Exposes CRUD operations for the **whatsmeow_device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_devices
    * const whatsmeow_devices = await prisma.whatsmeow_device.findMany()
    * ```
    */
  get whatsmeow_device(): Prisma.whatsmeow_deviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_event_buffer`: Exposes CRUD operations for the **whatsmeow_event_buffer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_event_buffers
    * const whatsmeow_event_buffers = await prisma.whatsmeow_event_buffer.findMany()
    * ```
    */
  get whatsmeow_event_buffer(): Prisma.whatsmeow_event_bufferDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_identity_keys`: Exposes CRUD operations for the **whatsmeow_identity_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_identity_keys
    * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findMany()
    * ```
    */
  get whatsmeow_identity_keys(): Prisma.whatsmeow_identity_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_lid_map`: Exposes CRUD operations for the **whatsmeow_lid_map** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_lid_maps
    * const whatsmeow_lid_maps = await prisma.whatsmeow_lid_map.findMany()
    * ```
    */
  get whatsmeow_lid_map(): Prisma.whatsmeow_lid_mapDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_message_secrets`: Exposes CRUD operations for the **whatsmeow_message_secrets** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_message_secrets
    * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findMany()
    * ```
    */
  get whatsmeow_message_secrets(): Prisma.whatsmeow_message_secretsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_pre_keys`: Exposes CRUD operations for the **whatsmeow_pre_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_pre_keys
    * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findMany()
    * ```
    */
  get whatsmeow_pre_keys(): Prisma.whatsmeow_pre_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_privacy_tokens`: Exposes CRUD operations for the **whatsmeow_privacy_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_privacy_tokens
    * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findMany()
    * ```
    */
  get whatsmeow_privacy_tokens(): Prisma.whatsmeow_privacy_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_sender_keys`: Exposes CRUD operations for the **whatsmeow_sender_keys** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_sender_keys
    * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findMany()
    * ```
    */
  get whatsmeow_sender_keys(): Prisma.whatsmeow_sender_keysDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.whatsmeow_sessions`: Exposes CRUD operations for the **whatsmeow_sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Whatsmeow_sessions
    * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findMany()
    * ```
    */
  get whatsmeow_sessions(): Prisma.whatsmeow_sessionsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.2.1
   * Query Engine version: 4123509d24aa4dede1e864b46351bf2790323b69
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    app_users: 'app_users',
    chatAssignmentDetail: 'chatAssignmentDetail',
    chatTags: 'chatTags',
    chat_status_details: 'chat_status_details',
    chatparticipants: 'chatparticipants',
    chats: 'chats',
    cleaned_contacts: 'cleaned_contacts',
    contacts: 'contacts',
    conversations: 'conversations',
    groups: 'groups',
    messageTemplates: 'messageTemplates',
    message_history: 'message_history',
    message_reactions: 'message_reactions',
    messages: 'messages',
    migrations: 'migrations',
    tags: 'tags',
    users: 'users',
    whatsmeow_app_state_mutation_macs: 'whatsmeow_app_state_mutation_macs',
    whatsmeow_app_state_sync_keys: 'whatsmeow_app_state_sync_keys',
    whatsmeow_app_state_version: 'whatsmeow_app_state_version',
    whatsmeow_chat_settings: 'whatsmeow_chat_settings',
    whatsmeow_contacts: 'whatsmeow_contacts',
    whatsmeow_device: 'whatsmeow_device',
    whatsmeow_event_buffer: 'whatsmeow_event_buffer',
    whatsmeow_identity_keys: 'whatsmeow_identity_keys',
    whatsmeow_lid_map: 'whatsmeow_lid_map',
    whatsmeow_message_secrets: 'whatsmeow_message_secrets',
    whatsmeow_pre_keys: 'whatsmeow_pre_keys',
    whatsmeow_privacy_tokens: 'whatsmeow_privacy_tokens',
    whatsmeow_sender_keys: 'whatsmeow_sender_keys',
    whatsmeow_sessions: 'whatsmeow_sessions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "app_users" | "chatAssignmentDetail" | "chatTags" | "chat_status_details" | "chatparticipants" | "chats" | "cleaned_contacts" | "contacts" | "conversations" | "groups" | "messageTemplates" | "message_history" | "message_reactions" | "messages" | "migrations" | "tags" | "users" | "whatsmeow_app_state_mutation_macs" | "whatsmeow_app_state_sync_keys" | "whatsmeow_app_state_version" | "whatsmeow_chat_settings" | "whatsmeow_contacts" | "whatsmeow_device" | "whatsmeow_event_buffer" | "whatsmeow_identity_keys" | "whatsmeow_lid_map" | "whatsmeow_message_secrets" | "whatsmeow_pre_keys" | "whatsmeow_privacy_tokens" | "whatsmeow_sender_keys" | "whatsmeow_sessions"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      app_users: {
        payload: Prisma.$app_usersPayload<ExtArgs>
        fields: Prisma.app_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.app_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.app_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>
          }
          findFirst: {
            args: Prisma.app_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.app_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>
          }
          findMany: {
            args: Prisma.app_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>[]
          }
          create: {
            args: Prisma.app_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>
          }
          createMany: {
            args: Prisma.app_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.app_usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>[]
          }
          delete: {
            args: Prisma.app_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>
          }
          update: {
            args: Prisma.app_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>
          }
          deleteMany: {
            args: Prisma.app_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.app_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.app_usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>[]
          }
          upsert: {
            args: Prisma.app_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$app_usersPayload>
          }
          aggregate: {
            args: Prisma.App_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp_users>
          }
          groupBy: {
            args: Prisma.app_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<App_usersGroupByOutputType>[]
          }
          count: {
            args: Prisma.app_usersCountArgs<ExtArgs>
            result: $Utils.Optional<App_usersCountAggregateOutputType> | number
          }
        }
      }
      chatAssignmentDetail: {
        payload: Prisma.$chatAssignmentDetailPayload<ExtArgs>
        fields: Prisma.chatAssignmentDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatAssignmentDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatAssignmentDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>
          }
          findFirst: {
            args: Prisma.chatAssignmentDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatAssignmentDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>
          }
          findMany: {
            args: Prisma.chatAssignmentDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>[]
          }
          create: {
            args: Prisma.chatAssignmentDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>
          }
          createMany: {
            args: Prisma.chatAssignmentDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatAssignmentDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>[]
          }
          delete: {
            args: Prisma.chatAssignmentDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>
          }
          update: {
            args: Prisma.chatAssignmentDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>
          }
          deleteMany: {
            args: Prisma.chatAssignmentDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatAssignmentDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatAssignmentDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>[]
          }
          upsert: {
            args: Prisma.chatAssignmentDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatAssignmentDetailPayload>
          }
          aggregate: {
            args: Prisma.ChatAssignmentDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatAssignmentDetail>
          }
          groupBy: {
            args: Prisma.chatAssignmentDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatAssignmentDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatAssignmentDetailCountArgs<ExtArgs>
            result: $Utils.Optional<ChatAssignmentDetailCountAggregateOutputType> | number
          }
        }
      }
      chatTags: {
        payload: Prisma.$chatTagsPayload<ExtArgs>
        fields: Prisma.chatTagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatTagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatTagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>
          }
          findFirst: {
            args: Prisma.chatTagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatTagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>
          }
          findMany: {
            args: Prisma.chatTagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>[]
          }
          create: {
            args: Prisma.chatTagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>
          }
          createMany: {
            args: Prisma.chatTagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatTagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>[]
          }
          delete: {
            args: Prisma.chatTagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>
          }
          update: {
            args: Prisma.chatTagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>
          }
          deleteMany: {
            args: Prisma.chatTagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatTagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatTagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>[]
          }
          upsert: {
            args: Prisma.chatTagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatTagsPayload>
          }
          aggregate: {
            args: Prisma.ChatTagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatTags>
          }
          groupBy: {
            args: Prisma.chatTagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatTagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatTagsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatTagsCountAggregateOutputType> | number
          }
        }
      }
      chat_status_details: {
        payload: Prisma.$chat_status_detailsPayload<ExtArgs>
        fields: Prisma.chat_status_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chat_status_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chat_status_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>
          }
          findFirst: {
            args: Prisma.chat_status_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chat_status_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>
          }
          findMany: {
            args: Prisma.chat_status_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>[]
          }
          create: {
            args: Prisma.chat_status_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>
          }
          createMany: {
            args: Prisma.chat_status_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chat_status_detailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>[]
          }
          delete: {
            args: Prisma.chat_status_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>
          }
          update: {
            args: Prisma.chat_status_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>
          }
          deleteMany: {
            args: Prisma.chat_status_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chat_status_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chat_status_detailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>[]
          }
          upsert: {
            args: Prisma.chat_status_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chat_status_detailsPayload>
          }
          aggregate: {
            args: Prisma.Chat_status_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChat_status_details>
          }
          groupBy: {
            args: Prisma.chat_status_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Chat_status_detailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chat_status_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Chat_status_detailsCountAggregateOutputType> | number
          }
        }
      }
      chatparticipants: {
        payload: Prisma.$chatparticipantsPayload<ExtArgs>
        fields: Prisma.chatparticipantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatparticipantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatparticipantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>
          }
          findFirst: {
            args: Prisma.chatparticipantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatparticipantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>
          }
          findMany: {
            args: Prisma.chatparticipantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>[]
          }
          create: {
            args: Prisma.chatparticipantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>
          }
          createMany: {
            args: Prisma.chatparticipantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatparticipantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>[]
          }
          delete: {
            args: Prisma.chatparticipantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>
          }
          update: {
            args: Prisma.chatparticipantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>
          }
          deleteMany: {
            args: Prisma.chatparticipantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatparticipantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatparticipantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>[]
          }
          upsert: {
            args: Prisma.chatparticipantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatparticipantsPayload>
          }
          aggregate: {
            args: Prisma.ChatparticipantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatparticipants>
          }
          groupBy: {
            args: Prisma.chatparticipantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatparticipantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatparticipantsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatparticipantsCountAggregateOutputType> | number
          }
        }
      }
      chats: {
        payload: Prisma.$chatsPayload<ExtArgs>
        fields: Prisma.chatsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.chatsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.chatsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findFirst: {
            args: Prisma.chatsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.chatsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          findMany: {
            args: Prisma.chatsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          create: {
            args: Prisma.chatsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          createMany: {
            args: Prisma.chatsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.chatsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          delete: {
            args: Prisma.chatsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          update: {
            args: Prisma.chatsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          deleteMany: {
            args: Prisma.chatsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.chatsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.chatsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>[]
          }
          upsert: {
            args: Prisma.chatsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$chatsPayload>
          }
          aggregate: {
            args: Prisma.ChatsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChats>
          }
          groupBy: {
            args: Prisma.chatsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatsGroupByOutputType>[]
          }
          count: {
            args: Prisma.chatsCountArgs<ExtArgs>
            result: $Utils.Optional<ChatsCountAggregateOutputType> | number
          }
        }
      }
      cleaned_contacts: {
        payload: Prisma.$cleaned_contactsPayload<ExtArgs>
        fields: Prisma.cleaned_contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cleaned_contactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cleaned_contactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>
          }
          findFirst: {
            args: Prisma.cleaned_contactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cleaned_contactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>
          }
          findMany: {
            args: Prisma.cleaned_contactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>[]
          }
          create: {
            args: Prisma.cleaned_contactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>
          }
          createMany: {
            args: Prisma.cleaned_contactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cleaned_contactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>[]
          }
          delete: {
            args: Prisma.cleaned_contactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>
          }
          update: {
            args: Prisma.cleaned_contactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>
          }
          deleteMany: {
            args: Prisma.cleaned_contactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cleaned_contactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cleaned_contactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>[]
          }
          upsert: {
            args: Prisma.cleaned_contactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cleaned_contactsPayload>
          }
          aggregate: {
            args: Prisma.Cleaned_contactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaned_contacts>
          }
          groupBy: {
            args: Prisma.cleaned_contactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cleaned_contactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cleaned_contactsCountArgs<ExtArgs>
            result: $Utils.Optional<Cleaned_contactsCountAggregateOutputType> | number
          }
        }
      }
      contacts: {
        payload: Prisma.$contactsPayload<ExtArgs>
        fields: Prisma.contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findFirst: {
            args: Prisma.contactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          findMany: {
            args: Prisma.contactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          create: {
            args: Prisma.contactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          createMany: {
            args: Prisma.contactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.contactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          delete: {
            args: Prisma.contactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          update: {
            args: Prisma.contactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          deleteMany: {
            args: Prisma.contactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.contactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>[]
          }
          upsert: {
            args: Prisma.contactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactsPayload>
          }
          aggregate: {
            args: Prisma.ContactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContacts>
          }
          groupBy: {
            args: Prisma.contactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.contactsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactsCountAggregateOutputType> | number
          }
        }
      }
      conversations: {
        payload: Prisma.$conversationsPayload<ExtArgs>
        fields: Prisma.conversationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.conversationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.conversationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findFirst: {
            args: Prisma.conversationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.conversationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          findMany: {
            args: Prisma.conversationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          create: {
            args: Prisma.conversationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          createMany: {
            args: Prisma.conversationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.conversationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          delete: {
            args: Prisma.conversationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          update: {
            args: Prisma.conversationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          deleteMany: {
            args: Prisma.conversationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.conversationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.conversationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>[]
          }
          upsert: {
            args: Prisma.conversationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$conversationsPayload>
          }
          aggregate: {
            args: Prisma.ConversationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversations>
          }
          groupBy: {
            args: Prisma.conversationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.conversationsCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationsCountAggregateOutputType> | number
          }
        }
      }
      groups: {
        payload: Prisma.$groupsPayload<ExtArgs>
        fields: Prisma.groupsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.groupsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.groupsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          findFirst: {
            args: Prisma.groupsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.groupsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          findMany: {
            args: Prisma.groupsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>[]
          }
          create: {
            args: Prisma.groupsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          createMany: {
            args: Prisma.groupsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.groupsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>[]
          }
          delete: {
            args: Prisma.groupsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          update: {
            args: Prisma.groupsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          deleteMany: {
            args: Prisma.groupsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.groupsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.groupsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>[]
          }
          upsert: {
            args: Prisma.groupsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$groupsPayload>
          }
          aggregate: {
            args: Prisma.GroupsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGroups>
          }
          groupBy: {
            args: Prisma.groupsGroupByArgs<ExtArgs>
            result: $Utils.Optional<GroupsGroupByOutputType>[]
          }
          count: {
            args: Prisma.groupsCountArgs<ExtArgs>
            result: $Utils.Optional<GroupsCountAggregateOutputType> | number
          }
        }
      }
      messageTemplates: {
        payload: Prisma.$messageTemplatesPayload<ExtArgs>
        fields: Prisma.messageTemplatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messageTemplatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messageTemplatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>
          }
          findFirst: {
            args: Prisma.messageTemplatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messageTemplatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>
          }
          findMany: {
            args: Prisma.messageTemplatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>[]
          }
          create: {
            args: Prisma.messageTemplatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>
          }
          createMany: {
            args: Prisma.messageTemplatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messageTemplatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>[]
          }
          delete: {
            args: Prisma.messageTemplatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>
          }
          update: {
            args: Prisma.messageTemplatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>
          }
          deleteMany: {
            args: Prisma.messageTemplatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messageTemplatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messageTemplatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>[]
          }
          upsert: {
            args: Prisma.messageTemplatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messageTemplatesPayload>
          }
          aggregate: {
            args: Prisma.MessageTemplatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageTemplates>
          }
          groupBy: {
            args: Prisma.messageTemplatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messageTemplatesCountArgs<ExtArgs>
            result: $Utils.Optional<MessageTemplatesCountAggregateOutputType> | number
          }
        }
      }
      message_history: {
        payload: Prisma.$message_historyPayload<ExtArgs>
        fields: Prisma.message_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.message_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.message_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>
          }
          findFirst: {
            args: Prisma.message_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.message_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>
          }
          findMany: {
            args: Prisma.message_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>[]
          }
          create: {
            args: Prisma.message_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>
          }
          createMany: {
            args: Prisma.message_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.message_historyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>[]
          }
          delete: {
            args: Prisma.message_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>
          }
          update: {
            args: Prisma.message_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>
          }
          deleteMany: {
            args: Prisma.message_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.message_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.message_historyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>[]
          }
          upsert: {
            args: Prisma.message_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_historyPayload>
          }
          aggregate: {
            args: Prisma.Message_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage_history>
          }
          groupBy: {
            args: Prisma.message_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Message_historyGroupByOutputType>[]
          }
          count: {
            args: Prisma.message_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Message_historyCountAggregateOutputType> | number
          }
        }
      }
      message_reactions: {
        payload: Prisma.$message_reactionsPayload<ExtArgs>
        fields: Prisma.message_reactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.message_reactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.message_reactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>
          }
          findFirst: {
            args: Prisma.message_reactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.message_reactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>
          }
          findMany: {
            args: Prisma.message_reactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>[]
          }
          create: {
            args: Prisma.message_reactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>
          }
          createMany: {
            args: Prisma.message_reactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.message_reactionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>[]
          }
          delete: {
            args: Prisma.message_reactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>
          }
          update: {
            args: Prisma.message_reactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>
          }
          deleteMany: {
            args: Prisma.message_reactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.message_reactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.message_reactionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>[]
          }
          upsert: {
            args: Prisma.message_reactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$message_reactionsPayload>
          }
          aggregate: {
            args: Prisma.Message_reactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage_reactions>
          }
          groupBy: {
            args: Prisma.message_reactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Message_reactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.message_reactionsCountArgs<ExtArgs>
            result: $Utils.Optional<Message_reactionsCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.migrationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.migrationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      tags: {
        payload: Prisma.$tagsPayload<ExtArgs>
        fields: Prisma.tagsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.tagsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.tagsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findFirst: {
            args: Prisma.tagsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.tagsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          findMany: {
            args: Prisma.tagsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          create: {
            args: Prisma.tagsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          createMany: {
            args: Prisma.tagsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.tagsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          delete: {
            args: Prisma.tagsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          update: {
            args: Prisma.tagsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          deleteMany: {
            args: Prisma.tagsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.tagsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.tagsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>[]
          }
          upsert: {
            args: Prisma.tagsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$tagsPayload>
          }
          aggregate: {
            args: Prisma.TagsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTags>
          }
          groupBy: {
            args: Prisma.tagsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagsGroupByOutputType>[]
          }
          count: {
            args: Prisma.tagsCountArgs<ExtArgs>
            result: $Utils.Optional<TagsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_app_state_mutation_macs: {
        payload: Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>
        fields: Prisma.whatsmeow_app_state_mutation_macsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_app_state_mutation_macsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_app_state_mutation_macsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_app_state_mutation_macsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_app_state_mutation_macsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_app_state_mutation_macsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_app_state_mutation_macsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_app_state_mutation_macsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_app_state_mutation_macsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_app_state_mutation_macsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>
          }
          update: {
            args: Prisma.whatsmeow_app_state_mutation_macsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_app_state_mutation_macsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_app_state_mutation_macsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_app_state_mutation_macsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_app_state_mutation_macsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_mutation_macsPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_app_state_mutation_macsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_app_state_mutation_macs>
          }
          groupBy: {
            args: Prisma.whatsmeow_app_state_mutation_macsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_app_state_mutation_macsGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_app_state_mutation_macsCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_app_state_mutation_macsCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_app_state_sync_keys: {
        payload: Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>
        fields: Prisma.whatsmeow_app_state_sync_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_app_state_sync_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_app_state_sync_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_app_state_sync_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_app_state_sync_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_app_state_sync_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_app_state_sync_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_app_state_sync_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_app_state_sync_keysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_app_state_sync_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>
          }
          update: {
            args: Prisma.whatsmeow_app_state_sync_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_app_state_sync_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_app_state_sync_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_app_state_sync_keysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_app_state_sync_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_sync_keysPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_app_state_sync_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_app_state_sync_keys>
          }
          groupBy: {
            args: Prisma.whatsmeow_app_state_sync_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_app_state_sync_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_app_state_sync_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_app_state_sync_keysCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_app_state_version: {
        payload: Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>
        fields: Prisma.whatsmeow_app_state_versionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_app_state_versionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_app_state_versionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_app_state_versionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_app_state_versionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_app_state_versionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_app_state_versionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_app_state_versionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_app_state_versionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_app_state_versionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>
          }
          update: {
            args: Prisma.whatsmeow_app_state_versionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_app_state_versionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_app_state_versionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_app_state_versionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_app_state_versionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_app_state_versionPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_app_state_versionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_app_state_version>
          }
          groupBy: {
            args: Prisma.whatsmeow_app_state_versionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_app_state_versionGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_app_state_versionCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_app_state_versionCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_chat_settings: {
        payload: Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>
        fields: Prisma.whatsmeow_chat_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_chat_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_chat_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_chat_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_chat_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_chat_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_chat_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_chat_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_chat_settingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_chat_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>
          }
          update: {
            args: Prisma.whatsmeow_chat_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_chat_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_chat_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_chat_settingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_chat_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_chat_settingsPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_chat_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_chat_settings>
          }
          groupBy: {
            args: Prisma.whatsmeow_chat_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_chat_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_chat_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_chat_settingsCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_contacts: {
        payload: Prisma.$whatsmeow_contactsPayload<ExtArgs>
        fields: Prisma.whatsmeow_contactsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_contactsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_contactsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_contactsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_contactsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_contactsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_contactsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_contactsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_contactsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_contactsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>
          }
          update: {
            args: Prisma.whatsmeow_contactsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_contactsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_contactsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_contactsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_contactsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_contactsPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_contactsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_contacts>
          }
          groupBy: {
            args: Prisma.whatsmeow_contactsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_contactsGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_contactsCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_contactsCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_device: {
        payload: Prisma.$whatsmeow_devicePayload<ExtArgs>
        fields: Prisma.whatsmeow_deviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_deviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_deviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_deviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_deviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>
          }
          findMany: {
            args: Prisma.whatsmeow_deviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>[]
          }
          create: {
            args: Prisma.whatsmeow_deviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>
          }
          createMany: {
            args: Prisma.whatsmeow_deviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_deviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_deviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>
          }
          update: {
            args: Prisma.whatsmeow_deviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_deviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_deviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_deviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_deviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_devicePayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_deviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_device>
          }
          groupBy: {
            args: Prisma.whatsmeow_deviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_deviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_deviceCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_deviceCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_event_buffer: {
        payload: Prisma.$whatsmeow_event_bufferPayload<ExtArgs>
        fields: Prisma.whatsmeow_event_bufferFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_event_bufferFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_event_bufferFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_event_bufferFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_event_bufferFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_event_bufferFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_event_bufferCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_event_bufferCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_event_bufferCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_event_bufferDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>
          }
          update: {
            args: Prisma.whatsmeow_event_bufferUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_event_bufferDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_event_bufferUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_event_bufferUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_event_bufferUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_event_bufferPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_event_bufferAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_event_buffer>
          }
          groupBy: {
            args: Prisma.whatsmeow_event_bufferGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_event_bufferGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_event_bufferCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_event_bufferCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_identity_keys: {
        payload: Prisma.$whatsmeow_identity_keysPayload<ExtArgs>
        fields: Prisma.whatsmeow_identity_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_identity_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_identity_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_identity_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_identity_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_identity_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_identity_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_identity_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_identity_keysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_identity_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>
          }
          update: {
            args: Prisma.whatsmeow_identity_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_identity_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_identity_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_identity_keysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_identity_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_identity_keysPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_identity_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_identity_keys>
          }
          groupBy: {
            args: Prisma.whatsmeow_identity_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_identity_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_identity_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_identity_keysCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_lid_map: {
        payload: Prisma.$whatsmeow_lid_mapPayload<ExtArgs>
        fields: Prisma.whatsmeow_lid_mapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_lid_mapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_lid_mapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_lid_mapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_lid_mapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_lid_mapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_lid_mapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_lid_mapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_lid_mapCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_lid_mapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>
          }
          update: {
            args: Prisma.whatsmeow_lid_mapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_lid_mapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_lid_mapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_lid_mapUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_lid_mapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_lid_mapPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_lid_mapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_lid_map>
          }
          groupBy: {
            args: Prisma.whatsmeow_lid_mapGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_lid_mapGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_lid_mapCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_lid_mapCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_message_secrets: {
        payload: Prisma.$whatsmeow_message_secretsPayload<ExtArgs>
        fields: Prisma.whatsmeow_message_secretsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_message_secretsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_message_secretsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_message_secretsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_message_secretsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_message_secretsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_message_secretsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_message_secretsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_message_secretsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_message_secretsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>
          }
          update: {
            args: Prisma.whatsmeow_message_secretsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_message_secretsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_message_secretsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_message_secretsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_message_secretsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_message_secretsPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_message_secretsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_message_secrets>
          }
          groupBy: {
            args: Prisma.whatsmeow_message_secretsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_message_secretsGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_message_secretsCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_message_secretsCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_pre_keys: {
        payload: Prisma.$whatsmeow_pre_keysPayload<ExtArgs>
        fields: Prisma.whatsmeow_pre_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_pre_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_pre_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_pre_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_pre_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_pre_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_pre_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_pre_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_pre_keysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_pre_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>
          }
          update: {
            args: Prisma.whatsmeow_pre_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_pre_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_pre_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_pre_keysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_pre_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_pre_keysPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_pre_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_pre_keys>
          }
          groupBy: {
            args: Prisma.whatsmeow_pre_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_pre_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_pre_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_pre_keysCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_privacy_tokens: {
        payload: Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>
        fields: Prisma.whatsmeow_privacy_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_privacy_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_privacy_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_privacy_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_privacy_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_privacy_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_privacy_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_privacy_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_privacy_tokensCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_privacy_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>
          }
          update: {
            args: Prisma.whatsmeow_privacy_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_privacy_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_privacy_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_privacy_tokensUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_privacy_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_privacy_tokensPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_privacy_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_privacy_tokens>
          }
          groupBy: {
            args: Prisma.whatsmeow_privacy_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_privacy_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_privacy_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_privacy_tokensCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_sender_keys: {
        payload: Prisma.$whatsmeow_sender_keysPayload<ExtArgs>
        fields: Prisma.whatsmeow_sender_keysFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_sender_keysFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_sender_keysFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_sender_keysFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_sender_keysFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_sender_keysFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_sender_keysCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_sender_keysCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_sender_keysCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_sender_keysDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>
          }
          update: {
            args: Prisma.whatsmeow_sender_keysUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_sender_keysDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_sender_keysUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_sender_keysUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_sender_keysUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sender_keysPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_sender_keysAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_sender_keys>
          }
          groupBy: {
            args: Prisma.whatsmeow_sender_keysGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_sender_keysGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_sender_keysCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_sender_keysCountAggregateOutputType> | number
          }
        }
      }
      whatsmeow_sessions: {
        payload: Prisma.$whatsmeow_sessionsPayload<ExtArgs>
        fields: Prisma.whatsmeow_sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.whatsmeow_sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.whatsmeow_sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>
          }
          findFirst: {
            args: Prisma.whatsmeow_sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.whatsmeow_sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>
          }
          findMany: {
            args: Prisma.whatsmeow_sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>[]
          }
          create: {
            args: Prisma.whatsmeow_sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>
          }
          createMany: {
            args: Prisma.whatsmeow_sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.whatsmeow_sessionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>[]
          }
          delete: {
            args: Prisma.whatsmeow_sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>
          }
          update: {
            args: Prisma.whatsmeow_sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>
          }
          deleteMany: {
            args: Prisma.whatsmeow_sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.whatsmeow_sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.whatsmeow_sessionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>[]
          }
          upsert: {
            args: Prisma.whatsmeow_sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$whatsmeow_sessionsPayload>
          }
          aggregate: {
            args: Prisma.Whatsmeow_sessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhatsmeow_sessions>
          }
          groupBy: {
            args: Prisma.whatsmeow_sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_sessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.whatsmeow_sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<Whatsmeow_sessionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    app_users?: app_usersOmit
    chatAssignmentDetail?: chatAssignmentDetailOmit
    chatTags?: chatTagsOmit
    chat_status_details?: chat_status_detailsOmit
    chatparticipants?: chatparticipantsOmit
    chats?: chatsOmit
    cleaned_contacts?: cleaned_contactsOmit
    contacts?: contactsOmit
    conversations?: conversationsOmit
    groups?: groupsOmit
    messageTemplates?: messageTemplatesOmit
    message_history?: message_historyOmit
    message_reactions?: message_reactionsOmit
    messages?: messagesOmit
    migrations?: migrationsOmit
    tags?: tagsOmit
    users?: usersOmit
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsOmit
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysOmit
    whatsmeow_app_state_version?: whatsmeow_app_state_versionOmit
    whatsmeow_chat_settings?: whatsmeow_chat_settingsOmit
    whatsmeow_contacts?: whatsmeow_contactsOmit
    whatsmeow_device?: whatsmeow_deviceOmit
    whatsmeow_event_buffer?: whatsmeow_event_bufferOmit
    whatsmeow_identity_keys?: whatsmeow_identity_keysOmit
    whatsmeow_lid_map?: whatsmeow_lid_mapOmit
    whatsmeow_message_secrets?: whatsmeow_message_secretsOmit
    whatsmeow_pre_keys?: whatsmeow_pre_keysOmit
    whatsmeow_privacy_tokens?: whatsmeow_privacy_tokensOmit
    whatsmeow_sender_keys?: whatsmeow_sender_keysOmit
    whatsmeow_sessions?: whatsmeow_sessionsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ChatsCountOutputType
   */

  export type ChatsCountOutputType = {
    chat_status_details: number
    chatparticipants: number
    messages: number
  }

  export type ChatsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_status_details?: boolean | ChatsCountOutputTypeCountChat_status_detailsArgs
    chatparticipants?: boolean | ChatsCountOutputTypeCountChatparticipantsArgs
    messages?: boolean | ChatsCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatsCountOutputType
     */
    select?: ChatsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountChat_status_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_status_detailsWhereInput
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountChatparticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatparticipantsWhereInput
  }

  /**
   * ChatsCountOutputType without action
   */
  export type ChatsCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }


  /**
   * Count Type ContactsCountOutputType
   */

  export type ContactsCountOutputType = {
    chatparticipants: number
  }

  export type ContactsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatparticipants?: boolean | ContactsCountOutputTypeCountChatparticipantsArgs
  }

  // Custom InputTypes
  /**
   * ContactsCountOutputType without action
   */
  export type ContactsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactsCountOutputType
     */
    select?: ContactsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactsCountOutputType without action
   */
  export type ContactsCountOutputTypeCountChatparticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatparticipantsWhereInput
  }


  /**
   * Count Type MessagesCountOutputType
   */

  export type MessagesCountOutputType = {
    message_reactions: number
  }

  export type MessagesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_reactions?: boolean | MessagesCountOutputTypeCountMessage_reactionsArgs
  }

  // Custom InputTypes
  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessagesCountOutputType
     */
    select?: MessagesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessagesCountOutputType without action
   */
  export type MessagesCountOutputTypeCountMessage_reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_reactionsWhereInput
  }


  /**
   * Count Type Whatsmeow_app_state_versionCountOutputType
   */

  export type Whatsmeow_app_state_versionCountOutputType = {
    whatsmeow_app_state_mutation_macs: number
  }

  export type Whatsmeow_app_state_versionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_mutation_macs?: boolean | Whatsmeow_app_state_versionCountOutputTypeCountWhatsmeow_app_state_mutation_macsArgs
  }

  // Custom InputTypes
  /**
   * Whatsmeow_app_state_versionCountOutputType without action
   */
  export type Whatsmeow_app_state_versionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsmeow_app_state_versionCountOutputType
     */
    select?: Whatsmeow_app_state_versionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Whatsmeow_app_state_versionCountOutputType without action
   */
  export type Whatsmeow_app_state_versionCountOutputTypeCountWhatsmeow_app_state_mutation_macsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_app_state_mutation_macsWhereInput
  }


  /**
   * Count Type Whatsmeow_deviceCountOutputType
   */

  export type Whatsmeow_deviceCountOutputType = {
    whatsmeow_app_state_sync_keys: number
    whatsmeow_app_state_version: number
    whatsmeow_chat_settings: number
    whatsmeow_contacts: number
    whatsmeow_event_buffer: number
    whatsmeow_identity_keys: number
    whatsmeow_message_secrets: number
    whatsmeow_pre_keys: number
    whatsmeow_sender_keys: number
    whatsmeow_sessions: number
  }

  export type Whatsmeow_deviceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_sync_keys?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_app_state_sync_keysArgs
    whatsmeow_app_state_version?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_app_state_versionArgs
    whatsmeow_chat_settings?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_chat_settingsArgs
    whatsmeow_contacts?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_contactsArgs
    whatsmeow_event_buffer?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_event_bufferArgs
    whatsmeow_identity_keys?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_identity_keysArgs
    whatsmeow_message_secrets?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_message_secretsArgs
    whatsmeow_pre_keys?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_pre_keysArgs
    whatsmeow_sender_keys?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_sender_keysArgs
    whatsmeow_sessions?: boolean | Whatsmeow_deviceCountOutputTypeCountWhatsmeow_sessionsArgs
  }

  // Custom InputTypes
  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Whatsmeow_deviceCountOutputType
     */
    select?: Whatsmeow_deviceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_app_state_sync_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_app_state_sync_keysWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_app_state_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_app_state_versionWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_chat_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_chat_settingsWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_contactsWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_event_bufferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_event_bufferWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_identity_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_identity_keysWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_message_secretsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_message_secretsWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_pre_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_pre_keysWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_sender_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_sender_keysWhereInput
  }

  /**
   * Whatsmeow_deviceCountOutputType without action
   */
  export type Whatsmeow_deviceCountOutputTypeCountWhatsmeow_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_sessionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model app_users
   */

  export type AggregateApp_users = {
    _count: App_usersCountAggregateOutputType | null
    _min: App_usersMinAggregateOutputType | null
    _max: App_usersMaxAggregateOutputType | null
  }

  export type App_usersMinAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password_hash: string | null
    first_name: string | null
    last_name: string | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
  }

  export type App_usersMaxAggregateOutputType = {
    id: string | null
    username: string | null
    email: string | null
    password_hash: string | null
    first_name: string | null
    last_name: string | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
  }

  export type App_usersCountAggregateOutputType = {
    id: number
    username: number
    email: number
    password_hash: number
    first_name: number
    last_name: number
    role: number
    created_at: number
    updated_at: number
    is_active: number
    _all: number
  }


  export type App_usersMinAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    role?: true
    created_at?: true
    updated_at?: true
    is_active?: true
  }

  export type App_usersMaxAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    role?: true
    created_at?: true
    updated_at?: true
    is_active?: true
  }

  export type App_usersCountAggregateInputType = {
    id?: true
    username?: true
    email?: true
    password_hash?: true
    first_name?: true
    last_name?: true
    role?: true
    created_at?: true
    updated_at?: true
    is_active?: true
    _all?: true
  }

  export type App_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_users to aggregate.
     */
    where?: app_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_usersOrderByWithRelationInput | app_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: app_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned app_users
    **/
    _count?: true | App_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: App_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: App_usersMaxAggregateInputType
  }

  export type GetApp_usersAggregateType<T extends App_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateApp_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp_users[P]>
      : GetScalarType<T[P], AggregateApp_users[P]>
  }




  export type app_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: app_usersWhereInput
    orderBy?: app_usersOrderByWithAggregationInput | app_usersOrderByWithAggregationInput[]
    by: App_usersScalarFieldEnum[] | App_usersScalarFieldEnum
    having?: app_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: App_usersCountAggregateInputType | true
    _min?: App_usersMinAggregateInputType
    _max?: App_usersMaxAggregateInputType
  }

  export type App_usersGroupByOutputType = {
    id: string
    username: string
    email: string
    password_hash: string
    first_name: string | null
    last_name: string | null
    role: string | null
    created_at: Date | null
    updated_at: Date | null
    is_active: boolean | null
    _count: App_usersCountAggregateOutputType | null
    _min: App_usersMinAggregateOutputType | null
    _max: App_usersMaxAggregateOutputType | null
  }

  type GetApp_usersGroupByPayload<T extends app_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<App_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof App_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], App_usersGroupByOutputType[P]>
            : GetScalarType<T[P], App_usersGroupByOutputType[P]>
        }
      >
    >


  export type app_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["app_users"]>

  export type app_usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["app_users"]>

  export type app_usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
  }, ExtArgs["result"]["app_users"]>

  export type app_usersSelectScalar = {
    id?: boolean
    username?: boolean
    email?: boolean
    password_hash?: boolean
    first_name?: boolean
    last_name?: boolean
    role?: boolean
    created_at?: boolean
    updated_at?: boolean
    is_active?: boolean
  }

  export type app_usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "email" | "password_hash" | "first_name" | "last_name" | "role" | "created_at" | "updated_at" | "is_active", ExtArgs["result"]["app_users"]>

  export type $app_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "app_users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      email: string
      password_hash: string
      first_name: string | null
      last_name: string | null
      role: string | null
      created_at: Date | null
      updated_at: Date | null
      is_active: boolean | null
    }, ExtArgs["result"]["app_users"]>
    composites: {}
  }

  type app_usersGetPayload<S extends boolean | null | undefined | app_usersDefaultArgs> = $Result.GetResult<Prisma.$app_usersPayload, S>

  type app_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<app_usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: App_usersCountAggregateInputType | true
    }

  export interface app_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['app_users'], meta: { name: 'app_users' } }
    /**
     * Find zero or one App_users that matches the filter.
     * @param {app_usersFindUniqueArgs} args - Arguments to find a App_users
     * @example
     * // Get one App_users
     * const app_users = await prisma.app_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends app_usersFindUniqueArgs>(args: SelectSubset<T, app_usersFindUniqueArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one App_users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {app_usersFindUniqueOrThrowArgs} args - Arguments to find a App_users
     * @example
     * // Get one App_users
     * const app_users = await prisma.app_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends app_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, app_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first App_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usersFindFirstArgs} args - Arguments to find a App_users
     * @example
     * // Get one App_users
     * const app_users = await prisma.app_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends app_usersFindFirstArgs>(args?: SelectSubset<T, app_usersFindFirstArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first App_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usersFindFirstOrThrowArgs} args - Arguments to find a App_users
     * @example
     * // Get one App_users
     * const app_users = await prisma.app_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends app_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, app_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more App_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all App_users
     * const app_users = await prisma.app_users.findMany()
     * 
     * // Get first 10 App_users
     * const app_users = await prisma.app_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const app_usersWithIdOnly = await prisma.app_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends app_usersFindManyArgs>(args?: SelectSubset<T, app_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a App_users.
     * @param {app_usersCreateArgs} args - Arguments to create a App_users.
     * @example
     * // Create one App_users
     * const App_users = await prisma.app_users.create({
     *   data: {
     *     // ... data to create a App_users
     *   }
     * })
     * 
     */
    create<T extends app_usersCreateArgs>(args: SelectSubset<T, app_usersCreateArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many App_users.
     * @param {app_usersCreateManyArgs} args - Arguments to create many App_users.
     * @example
     * // Create many App_users
     * const app_users = await prisma.app_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends app_usersCreateManyArgs>(args?: SelectSubset<T, app_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many App_users and returns the data saved in the database.
     * @param {app_usersCreateManyAndReturnArgs} args - Arguments to create many App_users.
     * @example
     * // Create many App_users
     * const app_users = await prisma.app_users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many App_users and only return the `id`
     * const app_usersWithIdOnly = await prisma.app_users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends app_usersCreateManyAndReturnArgs>(args?: SelectSubset<T, app_usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a App_users.
     * @param {app_usersDeleteArgs} args - Arguments to delete one App_users.
     * @example
     * // Delete one App_users
     * const App_users = await prisma.app_users.delete({
     *   where: {
     *     // ... filter to delete one App_users
     *   }
     * })
     * 
     */
    delete<T extends app_usersDeleteArgs>(args: SelectSubset<T, app_usersDeleteArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one App_users.
     * @param {app_usersUpdateArgs} args - Arguments to update one App_users.
     * @example
     * // Update one App_users
     * const app_users = await prisma.app_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends app_usersUpdateArgs>(args: SelectSubset<T, app_usersUpdateArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more App_users.
     * @param {app_usersDeleteManyArgs} args - Arguments to filter App_users to delete.
     * @example
     * // Delete a few App_users
     * const { count } = await prisma.app_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends app_usersDeleteManyArgs>(args?: SelectSubset<T, app_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many App_users
     * const app_users = await prisma.app_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends app_usersUpdateManyArgs>(args: SelectSubset<T, app_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more App_users and returns the data updated in the database.
     * @param {app_usersUpdateManyAndReturnArgs} args - Arguments to update many App_users.
     * @example
     * // Update many App_users
     * const app_users = await prisma.app_users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more App_users and only return the `id`
     * const app_usersWithIdOnly = await prisma.app_users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends app_usersUpdateManyAndReturnArgs>(args: SelectSubset<T, app_usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one App_users.
     * @param {app_usersUpsertArgs} args - Arguments to update or create a App_users.
     * @example
     * // Update or create a App_users
     * const app_users = await prisma.app_users.upsert({
     *   create: {
     *     // ... data to create a App_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App_users we want to update
     *   }
     * })
     */
    upsert<T extends app_usersUpsertArgs>(args: SelectSubset<T, app_usersUpsertArgs<ExtArgs>>): Prisma__app_usersClient<$Result.GetResult<Prisma.$app_usersPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of App_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usersCountArgs} args - Arguments to filter App_users to count.
     * @example
     * // Count the number of App_users
     * const count = await prisma.app_users.count({
     *   where: {
     *     // ... the filter for the App_users we want to count
     *   }
     * })
    **/
    count<T extends app_usersCountArgs>(
      args?: Subset<T, app_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], App_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {App_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends App_usersAggregateArgs>(args: Subset<T, App_usersAggregateArgs>): Prisma.PrismaPromise<GetApp_usersAggregateType<T>>

    /**
     * Group by App_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {app_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends app_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: app_usersGroupByArgs['orderBy'] }
        : { orderBy?: app_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, app_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApp_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the app_users model
   */
  readonly fields: app_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for app_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__app_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the app_users model
   */ 
  interface app_usersFieldRefs {
    readonly id: FieldRef<"app_users", 'String'>
    readonly username: FieldRef<"app_users", 'String'>
    readonly email: FieldRef<"app_users", 'String'>
    readonly password_hash: FieldRef<"app_users", 'String'>
    readonly first_name: FieldRef<"app_users", 'String'>
    readonly last_name: FieldRef<"app_users", 'String'>
    readonly role: FieldRef<"app_users", 'String'>
    readonly created_at: FieldRef<"app_users", 'DateTime'>
    readonly updated_at: FieldRef<"app_users", 'DateTime'>
    readonly is_active: FieldRef<"app_users", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * app_users findUnique
   */
  export type app_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * Filter, which app_users to fetch.
     */
    where: app_usersWhereUniqueInput
  }

  /**
   * app_users findUniqueOrThrow
   */
  export type app_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * Filter, which app_users to fetch.
     */
    where: app_usersWhereUniqueInput
  }

  /**
   * app_users findFirst
   */
  export type app_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * Filter, which app_users to fetch.
     */
    where?: app_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_usersOrderByWithRelationInput | app_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_users.
     */
    cursor?: app_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_users.
     */
    distinct?: App_usersScalarFieldEnum | App_usersScalarFieldEnum[]
  }

  /**
   * app_users findFirstOrThrow
   */
  export type app_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * Filter, which app_users to fetch.
     */
    where?: app_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_usersOrderByWithRelationInput | app_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for app_users.
     */
    cursor?: app_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of app_users.
     */
    distinct?: App_usersScalarFieldEnum | App_usersScalarFieldEnum[]
  }

  /**
   * app_users findMany
   */
  export type app_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * Filter, which app_users to fetch.
     */
    where?: app_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of app_users to fetch.
     */
    orderBy?: app_usersOrderByWithRelationInput | app_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing app_users.
     */
    cursor?: app_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` app_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` app_users.
     */
    skip?: number
    distinct?: App_usersScalarFieldEnum | App_usersScalarFieldEnum[]
  }

  /**
   * app_users create
   */
  export type app_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * The data needed to create a app_users.
     */
    data: XOR<app_usersCreateInput, app_usersUncheckedCreateInput>
  }

  /**
   * app_users createMany
   */
  export type app_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many app_users.
     */
    data: app_usersCreateManyInput | app_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_users createManyAndReturn
   */
  export type app_usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * The data used to create many app_users.
     */
    data: app_usersCreateManyInput | app_usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * app_users update
   */
  export type app_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * The data needed to update a app_users.
     */
    data: XOR<app_usersUpdateInput, app_usersUncheckedUpdateInput>
    /**
     * Choose, which app_users to update.
     */
    where: app_usersWhereUniqueInput
  }

  /**
   * app_users updateMany
   */
  export type app_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update app_users.
     */
    data: XOR<app_usersUpdateManyMutationInput, app_usersUncheckedUpdateManyInput>
    /**
     * Filter which app_users to update
     */
    where?: app_usersWhereInput
  }

  /**
   * app_users updateManyAndReturn
   */
  export type app_usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * The data used to update app_users.
     */
    data: XOR<app_usersUpdateManyMutationInput, app_usersUncheckedUpdateManyInput>
    /**
     * Filter which app_users to update
     */
    where?: app_usersWhereInput
  }

  /**
   * app_users upsert
   */
  export type app_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * The filter to search for the app_users to update in case it exists.
     */
    where: app_usersWhereUniqueInput
    /**
     * In case the app_users found by the `where` argument doesn't exist, create a new app_users with this data.
     */
    create: XOR<app_usersCreateInput, app_usersUncheckedCreateInput>
    /**
     * In case the app_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<app_usersUpdateInput, app_usersUncheckedUpdateInput>
  }

  /**
   * app_users delete
   */
  export type app_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
    /**
     * Filter which app_users to delete.
     */
    where: app_usersWhereUniqueInput
  }

  /**
   * app_users deleteMany
   */
  export type app_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which app_users to delete
     */
    where?: app_usersWhereInput
  }

  /**
   * app_users without action
   */
  export type app_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the app_users
     */
    select?: app_usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the app_users
     */
    omit?: app_usersOmit<ExtArgs> | null
  }


  /**
   * Model chatAssignmentDetail
   */

  export type AggregateChatAssignmentDetail = {
    _count: ChatAssignmentDetailCountAggregateOutputType | null
    _avg: ChatAssignmentDetailAvgAggregateOutputType | null
    _sum: ChatAssignmentDetailSumAggregateOutputType | null
    _min: ChatAssignmentDetailMinAggregateOutputType | null
    _max: ChatAssignmentDetailMaxAggregateOutputType | null
  }

  export type ChatAssignmentDetailAvgAggregateOutputType = {
    chatAssignmentDetailId: number | null
  }

  export type ChatAssignmentDetailSumAggregateOutputType = {
    chatAssignmentDetailId: bigint | null
  }

  export type ChatAssignmentDetailMinAggregateOutputType = {
    chatId: string | null
    assignedTo: string | null
    assignedBy: string | null
    chatAssignmentDetailId: bigint | null
    assignedAt: Date | null
  }

  export type ChatAssignmentDetailMaxAggregateOutputType = {
    chatId: string | null
    assignedTo: string | null
    assignedBy: string | null
    chatAssignmentDetailId: bigint | null
    assignedAt: Date | null
  }

  export type ChatAssignmentDetailCountAggregateOutputType = {
    chatId: number
    assignedTo: number
    assignedBy: number
    chatAssignmentDetailId: number
    assignedAt: number
    _all: number
  }


  export type ChatAssignmentDetailAvgAggregateInputType = {
    chatAssignmentDetailId?: true
  }

  export type ChatAssignmentDetailSumAggregateInputType = {
    chatAssignmentDetailId?: true
  }

  export type ChatAssignmentDetailMinAggregateInputType = {
    chatId?: true
    assignedTo?: true
    assignedBy?: true
    chatAssignmentDetailId?: true
    assignedAt?: true
  }

  export type ChatAssignmentDetailMaxAggregateInputType = {
    chatId?: true
    assignedTo?: true
    assignedBy?: true
    chatAssignmentDetailId?: true
    assignedAt?: true
  }

  export type ChatAssignmentDetailCountAggregateInputType = {
    chatId?: true
    assignedTo?: true
    assignedBy?: true
    chatAssignmentDetailId?: true
    assignedAt?: true
    _all?: true
  }

  export type ChatAssignmentDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatAssignmentDetail to aggregate.
     */
    where?: chatAssignmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatAssignmentDetails to fetch.
     */
    orderBy?: chatAssignmentDetailOrderByWithRelationInput | chatAssignmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatAssignmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatAssignmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatAssignmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatAssignmentDetails
    **/
    _count?: true | ChatAssignmentDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatAssignmentDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatAssignmentDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatAssignmentDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatAssignmentDetailMaxAggregateInputType
  }

  export type GetChatAssignmentDetailAggregateType<T extends ChatAssignmentDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateChatAssignmentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatAssignmentDetail[P]>
      : GetScalarType<T[P], AggregateChatAssignmentDetail[P]>
  }




  export type chatAssignmentDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatAssignmentDetailWhereInput
    orderBy?: chatAssignmentDetailOrderByWithAggregationInput | chatAssignmentDetailOrderByWithAggregationInput[]
    by: ChatAssignmentDetailScalarFieldEnum[] | ChatAssignmentDetailScalarFieldEnum
    having?: chatAssignmentDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatAssignmentDetailCountAggregateInputType | true
    _avg?: ChatAssignmentDetailAvgAggregateInputType
    _sum?: ChatAssignmentDetailSumAggregateInputType
    _min?: ChatAssignmentDetailMinAggregateInputType
    _max?: ChatAssignmentDetailMaxAggregateInputType
  }

  export type ChatAssignmentDetailGroupByOutputType = {
    chatId: string | null
    assignedTo: string | null
    assignedBy: string | null
    chatAssignmentDetailId: bigint
    assignedAt: Date | null
    _count: ChatAssignmentDetailCountAggregateOutputType | null
    _avg: ChatAssignmentDetailAvgAggregateOutputType | null
    _sum: ChatAssignmentDetailSumAggregateOutputType | null
    _min: ChatAssignmentDetailMinAggregateOutputType | null
    _max: ChatAssignmentDetailMaxAggregateOutputType | null
  }

  type GetChatAssignmentDetailGroupByPayload<T extends chatAssignmentDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatAssignmentDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatAssignmentDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatAssignmentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], ChatAssignmentDetailGroupByOutputType[P]>
        }
      >
    >


  export type chatAssignmentDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatId?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    chatAssignmentDetailId?: boolean
    assignedAt?: boolean
  }, ExtArgs["result"]["chatAssignmentDetail"]>

  export type chatAssignmentDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatId?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    chatAssignmentDetailId?: boolean
    assignedAt?: boolean
  }, ExtArgs["result"]["chatAssignmentDetail"]>

  export type chatAssignmentDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatId?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    chatAssignmentDetailId?: boolean
    assignedAt?: boolean
  }, ExtArgs["result"]["chatAssignmentDetail"]>

  export type chatAssignmentDetailSelectScalar = {
    chatId?: boolean
    assignedTo?: boolean
    assignedBy?: boolean
    chatAssignmentDetailId?: boolean
    assignedAt?: boolean
  }

  export type chatAssignmentDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chatId" | "assignedTo" | "assignedBy" | "chatAssignmentDetailId" | "assignedAt", ExtArgs["result"]["chatAssignmentDetail"]>

  export type $chatAssignmentDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatAssignmentDetail"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      chatId: string | null
      assignedTo: string | null
      assignedBy: string | null
      chatAssignmentDetailId: bigint
      assignedAt: Date | null
    }, ExtArgs["result"]["chatAssignmentDetail"]>
    composites: {}
  }

  type chatAssignmentDetailGetPayload<S extends boolean | null | undefined | chatAssignmentDetailDefaultArgs> = $Result.GetResult<Prisma.$chatAssignmentDetailPayload, S>

  type chatAssignmentDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatAssignmentDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatAssignmentDetailCountAggregateInputType | true
    }

  export interface chatAssignmentDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatAssignmentDetail'], meta: { name: 'chatAssignmentDetail' } }
    /**
     * Find zero or one ChatAssignmentDetail that matches the filter.
     * @param {chatAssignmentDetailFindUniqueArgs} args - Arguments to find a ChatAssignmentDetail
     * @example
     * // Get one ChatAssignmentDetail
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatAssignmentDetailFindUniqueArgs>(args: SelectSubset<T, chatAssignmentDetailFindUniqueArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChatAssignmentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatAssignmentDetailFindUniqueOrThrowArgs} args - Arguments to find a ChatAssignmentDetail
     * @example
     * // Get one ChatAssignmentDetail
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatAssignmentDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, chatAssignmentDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChatAssignmentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatAssignmentDetailFindFirstArgs} args - Arguments to find a ChatAssignmentDetail
     * @example
     * // Get one ChatAssignmentDetail
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatAssignmentDetailFindFirstArgs>(args?: SelectSubset<T, chatAssignmentDetailFindFirstArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChatAssignmentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatAssignmentDetailFindFirstOrThrowArgs} args - Arguments to find a ChatAssignmentDetail
     * @example
     * // Get one ChatAssignmentDetail
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatAssignmentDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, chatAssignmentDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChatAssignmentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatAssignmentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatAssignmentDetails
     * const chatAssignmentDetails = await prisma.chatAssignmentDetail.findMany()
     * 
     * // Get first 10 ChatAssignmentDetails
     * const chatAssignmentDetails = await prisma.chatAssignmentDetail.findMany({ take: 10 })
     * 
     * // Only select the `chatId`
     * const chatAssignmentDetailWithChatIdOnly = await prisma.chatAssignmentDetail.findMany({ select: { chatId: true } })
     * 
     */
    findMany<T extends chatAssignmentDetailFindManyArgs>(args?: SelectSubset<T, chatAssignmentDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChatAssignmentDetail.
     * @param {chatAssignmentDetailCreateArgs} args - Arguments to create a ChatAssignmentDetail.
     * @example
     * // Create one ChatAssignmentDetail
     * const ChatAssignmentDetail = await prisma.chatAssignmentDetail.create({
     *   data: {
     *     // ... data to create a ChatAssignmentDetail
     *   }
     * })
     * 
     */
    create<T extends chatAssignmentDetailCreateArgs>(args: SelectSubset<T, chatAssignmentDetailCreateArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChatAssignmentDetails.
     * @param {chatAssignmentDetailCreateManyArgs} args - Arguments to create many ChatAssignmentDetails.
     * @example
     * // Create many ChatAssignmentDetails
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatAssignmentDetailCreateManyArgs>(args?: SelectSubset<T, chatAssignmentDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatAssignmentDetails and returns the data saved in the database.
     * @param {chatAssignmentDetailCreateManyAndReturnArgs} args - Arguments to create many ChatAssignmentDetails.
     * @example
     * // Create many ChatAssignmentDetails
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatAssignmentDetails and only return the `chatId`
     * const chatAssignmentDetailWithChatIdOnly = await prisma.chatAssignmentDetail.createManyAndReturn({
     *   select: { chatId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatAssignmentDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, chatAssignmentDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChatAssignmentDetail.
     * @param {chatAssignmentDetailDeleteArgs} args - Arguments to delete one ChatAssignmentDetail.
     * @example
     * // Delete one ChatAssignmentDetail
     * const ChatAssignmentDetail = await prisma.chatAssignmentDetail.delete({
     *   where: {
     *     // ... filter to delete one ChatAssignmentDetail
     *   }
     * })
     * 
     */
    delete<T extends chatAssignmentDetailDeleteArgs>(args: SelectSubset<T, chatAssignmentDetailDeleteArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChatAssignmentDetail.
     * @param {chatAssignmentDetailUpdateArgs} args - Arguments to update one ChatAssignmentDetail.
     * @example
     * // Update one ChatAssignmentDetail
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatAssignmentDetailUpdateArgs>(args: SelectSubset<T, chatAssignmentDetailUpdateArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChatAssignmentDetails.
     * @param {chatAssignmentDetailDeleteManyArgs} args - Arguments to filter ChatAssignmentDetails to delete.
     * @example
     * // Delete a few ChatAssignmentDetails
     * const { count } = await prisma.chatAssignmentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatAssignmentDetailDeleteManyArgs>(args?: SelectSubset<T, chatAssignmentDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatAssignmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatAssignmentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatAssignmentDetails
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatAssignmentDetailUpdateManyArgs>(args: SelectSubset<T, chatAssignmentDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatAssignmentDetails and returns the data updated in the database.
     * @param {chatAssignmentDetailUpdateManyAndReturnArgs} args - Arguments to update many ChatAssignmentDetails.
     * @example
     * // Update many ChatAssignmentDetails
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatAssignmentDetails and only return the `chatId`
     * const chatAssignmentDetailWithChatIdOnly = await prisma.chatAssignmentDetail.updateManyAndReturn({
     *   select: { chatId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatAssignmentDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, chatAssignmentDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChatAssignmentDetail.
     * @param {chatAssignmentDetailUpsertArgs} args - Arguments to update or create a ChatAssignmentDetail.
     * @example
     * // Update or create a ChatAssignmentDetail
     * const chatAssignmentDetail = await prisma.chatAssignmentDetail.upsert({
     *   create: {
     *     // ... data to create a ChatAssignmentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatAssignmentDetail we want to update
     *   }
     * })
     */
    upsert<T extends chatAssignmentDetailUpsertArgs>(args: SelectSubset<T, chatAssignmentDetailUpsertArgs<ExtArgs>>): Prisma__chatAssignmentDetailClient<$Result.GetResult<Prisma.$chatAssignmentDetailPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChatAssignmentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatAssignmentDetailCountArgs} args - Arguments to filter ChatAssignmentDetails to count.
     * @example
     * // Count the number of ChatAssignmentDetails
     * const count = await prisma.chatAssignmentDetail.count({
     *   where: {
     *     // ... the filter for the ChatAssignmentDetails we want to count
     *   }
     * })
    **/
    count<T extends chatAssignmentDetailCountArgs>(
      args?: Subset<T, chatAssignmentDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatAssignmentDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatAssignmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatAssignmentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatAssignmentDetailAggregateArgs>(args: Subset<T, ChatAssignmentDetailAggregateArgs>): Prisma.PrismaPromise<GetChatAssignmentDetailAggregateType<T>>

    /**
     * Group by ChatAssignmentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatAssignmentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatAssignmentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatAssignmentDetailGroupByArgs['orderBy'] }
        : { orderBy?: chatAssignmentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatAssignmentDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatAssignmentDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatAssignmentDetail model
   */
  readonly fields: chatAssignmentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatAssignmentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatAssignmentDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatAssignmentDetail model
   */ 
  interface chatAssignmentDetailFieldRefs {
    readonly chatId: FieldRef<"chatAssignmentDetail", 'String'>
    readonly assignedTo: FieldRef<"chatAssignmentDetail", 'String'>
    readonly assignedBy: FieldRef<"chatAssignmentDetail", 'String'>
    readonly chatAssignmentDetailId: FieldRef<"chatAssignmentDetail", 'BigInt'>
    readonly assignedAt: FieldRef<"chatAssignmentDetail", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * chatAssignmentDetail findUnique
   */
  export type chatAssignmentDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * Filter, which chatAssignmentDetail to fetch.
     */
    where: chatAssignmentDetailWhereUniqueInput
  }

  /**
   * chatAssignmentDetail findUniqueOrThrow
   */
  export type chatAssignmentDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * Filter, which chatAssignmentDetail to fetch.
     */
    where: chatAssignmentDetailWhereUniqueInput
  }

  /**
   * chatAssignmentDetail findFirst
   */
  export type chatAssignmentDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * Filter, which chatAssignmentDetail to fetch.
     */
    where?: chatAssignmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatAssignmentDetails to fetch.
     */
    orderBy?: chatAssignmentDetailOrderByWithRelationInput | chatAssignmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatAssignmentDetails.
     */
    cursor?: chatAssignmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatAssignmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatAssignmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatAssignmentDetails.
     */
    distinct?: ChatAssignmentDetailScalarFieldEnum | ChatAssignmentDetailScalarFieldEnum[]
  }

  /**
   * chatAssignmentDetail findFirstOrThrow
   */
  export type chatAssignmentDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * Filter, which chatAssignmentDetail to fetch.
     */
    where?: chatAssignmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatAssignmentDetails to fetch.
     */
    orderBy?: chatAssignmentDetailOrderByWithRelationInput | chatAssignmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatAssignmentDetails.
     */
    cursor?: chatAssignmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatAssignmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatAssignmentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatAssignmentDetails.
     */
    distinct?: ChatAssignmentDetailScalarFieldEnum | ChatAssignmentDetailScalarFieldEnum[]
  }

  /**
   * chatAssignmentDetail findMany
   */
  export type chatAssignmentDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * Filter, which chatAssignmentDetails to fetch.
     */
    where?: chatAssignmentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatAssignmentDetails to fetch.
     */
    orderBy?: chatAssignmentDetailOrderByWithRelationInput | chatAssignmentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatAssignmentDetails.
     */
    cursor?: chatAssignmentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatAssignmentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatAssignmentDetails.
     */
    skip?: number
    distinct?: ChatAssignmentDetailScalarFieldEnum | ChatAssignmentDetailScalarFieldEnum[]
  }

  /**
   * chatAssignmentDetail create
   */
  export type chatAssignmentDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * The data needed to create a chatAssignmentDetail.
     */
    data?: XOR<chatAssignmentDetailCreateInput, chatAssignmentDetailUncheckedCreateInput>
  }

  /**
   * chatAssignmentDetail createMany
   */
  export type chatAssignmentDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatAssignmentDetails.
     */
    data: chatAssignmentDetailCreateManyInput | chatAssignmentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatAssignmentDetail createManyAndReturn
   */
  export type chatAssignmentDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * The data used to create many chatAssignmentDetails.
     */
    data: chatAssignmentDetailCreateManyInput | chatAssignmentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatAssignmentDetail update
   */
  export type chatAssignmentDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * The data needed to update a chatAssignmentDetail.
     */
    data: XOR<chatAssignmentDetailUpdateInput, chatAssignmentDetailUncheckedUpdateInput>
    /**
     * Choose, which chatAssignmentDetail to update.
     */
    where: chatAssignmentDetailWhereUniqueInput
  }

  /**
   * chatAssignmentDetail updateMany
   */
  export type chatAssignmentDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatAssignmentDetails.
     */
    data: XOR<chatAssignmentDetailUpdateManyMutationInput, chatAssignmentDetailUncheckedUpdateManyInput>
    /**
     * Filter which chatAssignmentDetails to update
     */
    where?: chatAssignmentDetailWhereInput
  }

  /**
   * chatAssignmentDetail updateManyAndReturn
   */
  export type chatAssignmentDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * The data used to update chatAssignmentDetails.
     */
    data: XOR<chatAssignmentDetailUpdateManyMutationInput, chatAssignmentDetailUncheckedUpdateManyInput>
    /**
     * Filter which chatAssignmentDetails to update
     */
    where?: chatAssignmentDetailWhereInput
  }

  /**
   * chatAssignmentDetail upsert
   */
  export type chatAssignmentDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * The filter to search for the chatAssignmentDetail to update in case it exists.
     */
    where: chatAssignmentDetailWhereUniqueInput
    /**
     * In case the chatAssignmentDetail found by the `where` argument doesn't exist, create a new chatAssignmentDetail with this data.
     */
    create: XOR<chatAssignmentDetailCreateInput, chatAssignmentDetailUncheckedCreateInput>
    /**
     * In case the chatAssignmentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatAssignmentDetailUpdateInput, chatAssignmentDetailUncheckedUpdateInput>
  }

  /**
   * chatAssignmentDetail delete
   */
  export type chatAssignmentDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
    /**
     * Filter which chatAssignmentDetail to delete.
     */
    where: chatAssignmentDetailWhereUniqueInput
  }

  /**
   * chatAssignmentDetail deleteMany
   */
  export type chatAssignmentDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatAssignmentDetails to delete
     */
    where?: chatAssignmentDetailWhereInput
  }

  /**
   * chatAssignmentDetail without action
   */
  export type chatAssignmentDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatAssignmentDetail
     */
    select?: chatAssignmentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatAssignmentDetail
     */
    omit?: chatAssignmentDetailOmit<ExtArgs> | null
  }


  /**
   * Model chatTags
   */

  export type AggregateChatTags = {
    _count: ChatTagsCountAggregateOutputType | null
    _avg: ChatTagsAvgAggregateOutputType | null
    _sum: ChatTagsSumAggregateOutputType | null
    _min: ChatTagsMinAggregateOutputType | null
    _max: ChatTagsMaxAggregateOutputType | null
  }

  export type ChatTagsAvgAggregateOutputType = {
    tagId: number | null
    chatTagId: number | null
  }

  export type ChatTagsSumAggregateOutputType = {
    tagId: bigint | null
    chatTagId: bigint | null
  }

  export type ChatTagsMinAggregateOutputType = {
    tagId: bigint | null
    chatTagId: bigint | null
    chatId: string | null
    creationDate: Date | null
    createdBy: string | null
  }

  export type ChatTagsMaxAggregateOutputType = {
    tagId: bigint | null
    chatTagId: bigint | null
    chatId: string | null
    creationDate: Date | null
    createdBy: string | null
  }

  export type ChatTagsCountAggregateOutputType = {
    tagId: number
    chatTagId: number
    chatId: number
    creationDate: number
    createdBy: number
    _all: number
  }


  export type ChatTagsAvgAggregateInputType = {
    tagId?: true
    chatTagId?: true
  }

  export type ChatTagsSumAggregateInputType = {
    tagId?: true
    chatTagId?: true
  }

  export type ChatTagsMinAggregateInputType = {
    tagId?: true
    chatTagId?: true
    chatId?: true
    creationDate?: true
    createdBy?: true
  }

  export type ChatTagsMaxAggregateInputType = {
    tagId?: true
    chatTagId?: true
    chatId?: true
    creationDate?: true
    createdBy?: true
  }

  export type ChatTagsCountAggregateInputType = {
    tagId?: true
    chatTagId?: true
    chatId?: true
    creationDate?: true
    createdBy?: true
    _all?: true
  }

  export type ChatTagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatTags to aggregate.
     */
    where?: chatTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatTags to fetch.
     */
    orderBy?: chatTagsOrderByWithRelationInput | chatTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatTags
    **/
    _count?: true | ChatTagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatTagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatTagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatTagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatTagsMaxAggregateInputType
  }

  export type GetChatTagsAggregateType<T extends ChatTagsAggregateArgs> = {
        [P in keyof T & keyof AggregateChatTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatTags[P]>
      : GetScalarType<T[P], AggregateChatTags[P]>
  }




  export type chatTagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatTagsWhereInput
    orderBy?: chatTagsOrderByWithAggregationInput | chatTagsOrderByWithAggregationInput[]
    by: ChatTagsScalarFieldEnum[] | ChatTagsScalarFieldEnum
    having?: chatTagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatTagsCountAggregateInputType | true
    _avg?: ChatTagsAvgAggregateInputType
    _sum?: ChatTagsSumAggregateInputType
    _min?: ChatTagsMinAggregateInputType
    _max?: ChatTagsMaxAggregateInputType
  }

  export type ChatTagsGroupByOutputType = {
    tagId: bigint
    chatTagId: bigint
    chatId: string | null
    creationDate: Date | null
    createdBy: string | null
    _count: ChatTagsCountAggregateOutputType | null
    _avg: ChatTagsAvgAggregateOutputType | null
    _sum: ChatTagsSumAggregateOutputType | null
    _min: ChatTagsMinAggregateOutputType | null
    _max: ChatTagsMaxAggregateOutputType | null
  }

  type GetChatTagsGroupByPayload<T extends chatTagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatTagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatTagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatTagsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatTagsGroupByOutputType[P]>
        }
      >
    >


  export type chatTagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    chatTagId?: boolean
    chatId?: boolean
    creationDate?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["chatTags"]>

  export type chatTagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    chatTagId?: boolean
    chatId?: boolean
    creationDate?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["chatTags"]>

  export type chatTagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    chatTagId?: boolean
    chatId?: boolean
    creationDate?: boolean
    createdBy?: boolean
  }, ExtArgs["result"]["chatTags"]>

  export type chatTagsSelectScalar = {
    tagId?: boolean
    chatTagId?: boolean
    chatId?: boolean
    creationDate?: boolean
    createdBy?: boolean
  }

  export type chatTagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tagId" | "chatTagId" | "chatId" | "creationDate" | "createdBy", ExtArgs["result"]["chatTags"]>

  export type $chatTagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatTags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tagId: bigint
      chatTagId: bigint
      chatId: string | null
      creationDate: Date | null
      createdBy: string | null
    }, ExtArgs["result"]["chatTags"]>
    composites: {}
  }

  type chatTagsGetPayload<S extends boolean | null | undefined | chatTagsDefaultArgs> = $Result.GetResult<Prisma.$chatTagsPayload, S>

  type chatTagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatTagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatTagsCountAggregateInputType | true
    }

  export interface chatTagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatTags'], meta: { name: 'chatTags' } }
    /**
     * Find zero or one ChatTags that matches the filter.
     * @param {chatTagsFindUniqueArgs} args - Arguments to find a ChatTags
     * @example
     * // Get one ChatTags
     * const chatTags = await prisma.chatTags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatTagsFindUniqueArgs>(args: SelectSubset<T, chatTagsFindUniqueArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one ChatTags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatTagsFindUniqueOrThrowArgs} args - Arguments to find a ChatTags
     * @example
     * // Get one ChatTags
     * const chatTags = await prisma.chatTags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatTagsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatTagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first ChatTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatTagsFindFirstArgs} args - Arguments to find a ChatTags
     * @example
     * // Get one ChatTags
     * const chatTags = await prisma.chatTags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatTagsFindFirstArgs>(args?: SelectSubset<T, chatTagsFindFirstArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first ChatTags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatTagsFindFirstOrThrowArgs} args - Arguments to find a ChatTags
     * @example
     * // Get one ChatTags
     * const chatTags = await prisma.chatTags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatTagsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatTagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more ChatTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatTagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatTags
     * const chatTags = await prisma.chatTags.findMany()
     * 
     * // Get first 10 ChatTags
     * const chatTags = await prisma.chatTags.findMany({ take: 10 })
     * 
     * // Only select the `tagId`
     * const chatTagsWithTagIdOnly = await prisma.chatTags.findMany({ select: { tagId: true } })
     * 
     */
    findMany<T extends chatTagsFindManyArgs>(args?: SelectSubset<T, chatTagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a ChatTags.
     * @param {chatTagsCreateArgs} args - Arguments to create a ChatTags.
     * @example
     * // Create one ChatTags
     * const ChatTags = await prisma.chatTags.create({
     *   data: {
     *     // ... data to create a ChatTags
     *   }
     * })
     * 
     */
    create<T extends chatTagsCreateArgs>(args: SelectSubset<T, chatTagsCreateArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many ChatTags.
     * @param {chatTagsCreateManyArgs} args - Arguments to create many ChatTags.
     * @example
     * // Create many ChatTags
     * const chatTags = await prisma.chatTags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatTagsCreateManyArgs>(args?: SelectSubset<T, chatTagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatTags and returns the data saved in the database.
     * @param {chatTagsCreateManyAndReturnArgs} args - Arguments to create many ChatTags.
     * @example
     * // Create many ChatTags
     * const chatTags = await prisma.chatTags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatTags and only return the `tagId`
     * const chatTagsWithTagIdOnly = await prisma.chatTags.createManyAndReturn({
     *   select: { tagId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatTagsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatTagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a ChatTags.
     * @param {chatTagsDeleteArgs} args - Arguments to delete one ChatTags.
     * @example
     * // Delete one ChatTags
     * const ChatTags = await prisma.chatTags.delete({
     *   where: {
     *     // ... filter to delete one ChatTags
     *   }
     * })
     * 
     */
    delete<T extends chatTagsDeleteArgs>(args: SelectSubset<T, chatTagsDeleteArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one ChatTags.
     * @param {chatTagsUpdateArgs} args - Arguments to update one ChatTags.
     * @example
     * // Update one ChatTags
     * const chatTags = await prisma.chatTags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatTagsUpdateArgs>(args: SelectSubset<T, chatTagsUpdateArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more ChatTags.
     * @param {chatTagsDeleteManyArgs} args - Arguments to filter ChatTags to delete.
     * @example
     * // Delete a few ChatTags
     * const { count } = await prisma.chatTags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatTagsDeleteManyArgs>(args?: SelectSubset<T, chatTagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatTagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatTags
     * const chatTags = await prisma.chatTags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatTagsUpdateManyArgs>(args: SelectSubset<T, chatTagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatTags and returns the data updated in the database.
     * @param {chatTagsUpdateManyAndReturnArgs} args - Arguments to update many ChatTags.
     * @example
     * // Update many ChatTags
     * const chatTags = await prisma.chatTags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChatTags and only return the `tagId`
     * const chatTagsWithTagIdOnly = await prisma.chatTags.updateManyAndReturn({
     *   select: { tagId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatTagsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatTagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one ChatTags.
     * @param {chatTagsUpsertArgs} args - Arguments to update or create a ChatTags.
     * @example
     * // Update or create a ChatTags
     * const chatTags = await prisma.chatTags.upsert({
     *   create: {
     *     // ... data to create a ChatTags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatTags we want to update
     *   }
     * })
     */
    upsert<T extends chatTagsUpsertArgs>(args: SelectSubset<T, chatTagsUpsertArgs<ExtArgs>>): Prisma__chatTagsClient<$Result.GetResult<Prisma.$chatTagsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of ChatTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatTagsCountArgs} args - Arguments to filter ChatTags to count.
     * @example
     * // Count the number of ChatTags
     * const count = await prisma.chatTags.count({
     *   where: {
     *     // ... the filter for the ChatTags we want to count
     *   }
     * })
    **/
    count<T extends chatTagsCountArgs>(
      args?: Subset<T, chatTagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatTagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatTagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatTagsAggregateArgs>(args: Subset<T, ChatTagsAggregateArgs>): Prisma.PrismaPromise<GetChatTagsAggregateType<T>>

    /**
     * Group by ChatTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatTagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatTagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatTagsGroupByArgs['orderBy'] }
        : { orderBy?: chatTagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatTagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatTags model
   */
  readonly fields: chatTagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatTags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatTagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatTags model
   */ 
  interface chatTagsFieldRefs {
    readonly tagId: FieldRef<"chatTags", 'BigInt'>
    readonly chatTagId: FieldRef<"chatTags", 'BigInt'>
    readonly chatId: FieldRef<"chatTags", 'String'>
    readonly creationDate: FieldRef<"chatTags", 'DateTime'>
    readonly createdBy: FieldRef<"chatTags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatTags findUnique
   */
  export type chatTagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * Filter, which chatTags to fetch.
     */
    where: chatTagsWhereUniqueInput
  }

  /**
   * chatTags findUniqueOrThrow
   */
  export type chatTagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * Filter, which chatTags to fetch.
     */
    where: chatTagsWhereUniqueInput
  }

  /**
   * chatTags findFirst
   */
  export type chatTagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * Filter, which chatTags to fetch.
     */
    where?: chatTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatTags to fetch.
     */
    orderBy?: chatTagsOrderByWithRelationInput | chatTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatTags.
     */
    cursor?: chatTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatTags.
     */
    distinct?: ChatTagsScalarFieldEnum | ChatTagsScalarFieldEnum[]
  }

  /**
   * chatTags findFirstOrThrow
   */
  export type chatTagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * Filter, which chatTags to fetch.
     */
    where?: chatTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatTags to fetch.
     */
    orderBy?: chatTagsOrderByWithRelationInput | chatTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatTags.
     */
    cursor?: chatTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatTags.
     */
    distinct?: ChatTagsScalarFieldEnum | ChatTagsScalarFieldEnum[]
  }

  /**
   * chatTags findMany
   */
  export type chatTagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * Filter, which chatTags to fetch.
     */
    where?: chatTagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatTags to fetch.
     */
    orderBy?: chatTagsOrderByWithRelationInput | chatTagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatTags.
     */
    cursor?: chatTagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatTags.
     */
    skip?: number
    distinct?: ChatTagsScalarFieldEnum | ChatTagsScalarFieldEnum[]
  }

  /**
   * chatTags create
   */
  export type chatTagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * The data needed to create a chatTags.
     */
    data?: XOR<chatTagsCreateInput, chatTagsUncheckedCreateInput>
  }

  /**
   * chatTags createMany
   */
  export type chatTagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatTags.
     */
    data: chatTagsCreateManyInput | chatTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatTags createManyAndReturn
   */
  export type chatTagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * The data used to create many chatTags.
     */
    data: chatTagsCreateManyInput | chatTagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatTags update
   */
  export type chatTagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * The data needed to update a chatTags.
     */
    data: XOR<chatTagsUpdateInput, chatTagsUncheckedUpdateInput>
    /**
     * Choose, which chatTags to update.
     */
    where: chatTagsWhereUniqueInput
  }

  /**
   * chatTags updateMany
   */
  export type chatTagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatTags.
     */
    data: XOR<chatTagsUpdateManyMutationInput, chatTagsUncheckedUpdateManyInput>
    /**
     * Filter which chatTags to update
     */
    where?: chatTagsWhereInput
  }

  /**
   * chatTags updateManyAndReturn
   */
  export type chatTagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * The data used to update chatTags.
     */
    data: XOR<chatTagsUpdateManyMutationInput, chatTagsUncheckedUpdateManyInput>
    /**
     * Filter which chatTags to update
     */
    where?: chatTagsWhereInput
  }

  /**
   * chatTags upsert
   */
  export type chatTagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * The filter to search for the chatTags to update in case it exists.
     */
    where: chatTagsWhereUniqueInput
    /**
     * In case the chatTags found by the `where` argument doesn't exist, create a new chatTags with this data.
     */
    create: XOR<chatTagsCreateInput, chatTagsUncheckedCreateInput>
    /**
     * In case the chatTags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatTagsUpdateInput, chatTagsUncheckedUpdateInput>
  }

  /**
   * chatTags delete
   */
  export type chatTagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
    /**
     * Filter which chatTags to delete.
     */
    where: chatTagsWhereUniqueInput
  }

  /**
   * chatTags deleteMany
   */
  export type chatTagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatTags to delete
     */
    where?: chatTagsWhereInput
  }

  /**
   * chatTags without action
   */
  export type chatTagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatTags
     */
    select?: chatTagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatTags
     */
    omit?: chatTagsOmit<ExtArgs> | null
  }


  /**
   * Model chat_status_details
   */

  export type AggregateChat_status_details = {
    _count: Chat_status_detailsCountAggregateOutputType | null
    _avg: Chat_status_detailsAvgAggregateOutputType | null
    _sum: Chat_status_detailsSumAggregateOutputType | null
    _min: Chat_status_detailsMinAggregateOutputType | null
    _max: Chat_status_detailsMaxAggregateOutputType | null
  }

  export type Chat_status_detailsAvgAggregateOutputType = {
    id: number | null
  }

  export type Chat_status_detailsSumAggregateOutputType = {
    id: number | null
  }

  export type Chat_status_detailsMinAggregateOutputType = {
    id: number | null
    chat_id: string | null
    status: string | null
    changed_by: string | null
    changed_at: Date | null
    reason: string | null
    notes: string | null
  }

  export type Chat_status_detailsMaxAggregateOutputType = {
    id: number | null
    chat_id: string | null
    status: string | null
    changed_by: string | null
    changed_at: Date | null
    reason: string | null
    notes: string | null
  }

  export type Chat_status_detailsCountAggregateOutputType = {
    id: number
    chat_id: number
    status: number
    changed_by: number
    changed_at: number
    reason: number
    notes: number
    _all: number
  }


  export type Chat_status_detailsAvgAggregateInputType = {
    id?: true
  }

  export type Chat_status_detailsSumAggregateInputType = {
    id?: true
  }

  export type Chat_status_detailsMinAggregateInputType = {
    id?: true
    chat_id?: true
    status?: true
    changed_by?: true
    changed_at?: true
    reason?: true
    notes?: true
  }

  export type Chat_status_detailsMaxAggregateInputType = {
    id?: true
    chat_id?: true
    status?: true
    changed_by?: true
    changed_at?: true
    reason?: true
    notes?: true
  }

  export type Chat_status_detailsCountAggregateInputType = {
    id?: true
    chat_id?: true
    status?: true
    changed_by?: true
    changed_at?: true
    reason?: true
    notes?: true
    _all?: true
  }

  export type Chat_status_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_status_details to aggregate.
     */
    where?: chat_status_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_status_details to fetch.
     */
    orderBy?: chat_status_detailsOrderByWithRelationInput | chat_status_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chat_status_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_status_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_status_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chat_status_details
    **/
    _count?: true | Chat_status_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Chat_status_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Chat_status_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Chat_status_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Chat_status_detailsMaxAggregateInputType
  }

  export type GetChat_status_detailsAggregateType<T extends Chat_status_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateChat_status_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChat_status_details[P]>
      : GetScalarType<T[P], AggregateChat_status_details[P]>
  }




  export type chat_status_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chat_status_detailsWhereInput
    orderBy?: chat_status_detailsOrderByWithAggregationInput | chat_status_detailsOrderByWithAggregationInput[]
    by: Chat_status_detailsScalarFieldEnum[] | Chat_status_detailsScalarFieldEnum
    having?: chat_status_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Chat_status_detailsCountAggregateInputType | true
    _avg?: Chat_status_detailsAvgAggregateInputType
    _sum?: Chat_status_detailsSumAggregateInputType
    _min?: Chat_status_detailsMinAggregateInputType
    _max?: Chat_status_detailsMaxAggregateInputType
  }

  export type Chat_status_detailsGroupByOutputType = {
    id: number
    chat_id: string
    status: string
    changed_by: string | null
    changed_at: Date | null
    reason: string | null
    notes: string | null
    _count: Chat_status_detailsCountAggregateOutputType | null
    _avg: Chat_status_detailsAvgAggregateOutputType | null
    _sum: Chat_status_detailsSumAggregateOutputType | null
    _min: Chat_status_detailsMinAggregateOutputType | null
    _max: Chat_status_detailsMaxAggregateOutputType | null
  }

  type GetChat_status_detailsGroupByPayload<T extends chat_status_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Chat_status_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Chat_status_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Chat_status_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Chat_status_detailsGroupByOutputType[P]>
        }
      >
    >


  export type chat_status_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chat_id?: boolean
    status?: boolean
    changed_by?: boolean
    changed_at?: boolean
    reason?: boolean
    notes?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat_status_details"]>

  export type chat_status_detailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chat_id?: boolean
    status?: boolean
    changed_by?: boolean
    changed_at?: boolean
    reason?: boolean
    notes?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat_status_details"]>

  export type chat_status_detailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chat_id?: boolean
    status?: boolean
    changed_by?: boolean
    changed_at?: boolean
    reason?: boolean
    notes?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chat_status_details"]>

  export type chat_status_detailsSelectScalar = {
    id?: boolean
    chat_id?: boolean
    status?: boolean
    changed_by?: boolean
    changed_at?: boolean
    reason?: boolean
    notes?: boolean
  }

  export type chat_status_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chat_id" | "status" | "changed_by" | "changed_at" | "reason" | "notes", ExtArgs["result"]["chat_status_details"]>
  export type chat_status_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }
  export type chat_status_detailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }
  export type chat_status_detailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
  }

  export type $chat_status_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chat_status_details"
    objects: {
      chats: Prisma.$chatsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      chat_id: string
      status: string
      changed_by: string | null
      changed_at: Date | null
      reason: string | null
      notes: string | null
    }, ExtArgs["result"]["chat_status_details"]>
    composites: {}
  }

  type chat_status_detailsGetPayload<S extends boolean | null | undefined | chat_status_detailsDefaultArgs> = $Result.GetResult<Prisma.$chat_status_detailsPayload, S>

  type chat_status_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chat_status_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Chat_status_detailsCountAggregateInputType | true
    }

  export interface chat_status_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chat_status_details'], meta: { name: 'chat_status_details' } }
    /**
     * Find zero or one Chat_status_details that matches the filter.
     * @param {chat_status_detailsFindUniqueArgs} args - Arguments to find a Chat_status_details
     * @example
     * // Get one Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chat_status_detailsFindUniqueArgs>(args: SelectSubset<T, chat_status_detailsFindUniqueArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chat_status_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chat_status_detailsFindUniqueOrThrowArgs} args - Arguments to find a Chat_status_details
     * @example
     * // Get one Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chat_status_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, chat_status_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chat_status_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_status_detailsFindFirstArgs} args - Arguments to find a Chat_status_details
     * @example
     * // Get one Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chat_status_detailsFindFirstArgs>(args?: SelectSubset<T, chat_status_detailsFindFirstArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chat_status_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_status_detailsFindFirstOrThrowArgs} args - Arguments to find a Chat_status_details
     * @example
     * // Get one Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chat_status_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, chat_status_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chat_status_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_status_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.findMany()
     * 
     * // Get first 10 Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chat_status_detailsWithIdOnly = await prisma.chat_status_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chat_status_detailsFindManyArgs>(args?: SelectSubset<T, chat_status_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chat_status_details.
     * @param {chat_status_detailsCreateArgs} args - Arguments to create a Chat_status_details.
     * @example
     * // Create one Chat_status_details
     * const Chat_status_details = await prisma.chat_status_details.create({
     *   data: {
     *     // ... data to create a Chat_status_details
     *   }
     * })
     * 
     */
    create<T extends chat_status_detailsCreateArgs>(args: SelectSubset<T, chat_status_detailsCreateArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chat_status_details.
     * @param {chat_status_detailsCreateManyArgs} args - Arguments to create many Chat_status_details.
     * @example
     * // Create many Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chat_status_detailsCreateManyArgs>(args?: SelectSubset<T, chat_status_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chat_status_details and returns the data saved in the database.
     * @param {chat_status_detailsCreateManyAndReturnArgs} args - Arguments to create many Chat_status_details.
     * @example
     * // Create many Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chat_status_details and only return the `id`
     * const chat_status_detailsWithIdOnly = await prisma.chat_status_details.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chat_status_detailsCreateManyAndReturnArgs>(args?: SelectSubset<T, chat_status_detailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Chat_status_details.
     * @param {chat_status_detailsDeleteArgs} args - Arguments to delete one Chat_status_details.
     * @example
     * // Delete one Chat_status_details
     * const Chat_status_details = await prisma.chat_status_details.delete({
     *   where: {
     *     // ... filter to delete one Chat_status_details
     *   }
     * })
     * 
     */
    delete<T extends chat_status_detailsDeleteArgs>(args: SelectSubset<T, chat_status_detailsDeleteArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chat_status_details.
     * @param {chat_status_detailsUpdateArgs} args - Arguments to update one Chat_status_details.
     * @example
     * // Update one Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chat_status_detailsUpdateArgs>(args: SelectSubset<T, chat_status_detailsUpdateArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chat_status_details.
     * @param {chat_status_detailsDeleteManyArgs} args - Arguments to filter Chat_status_details to delete.
     * @example
     * // Delete a few Chat_status_details
     * const { count } = await prisma.chat_status_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chat_status_detailsDeleteManyArgs>(args?: SelectSubset<T, chat_status_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_status_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_status_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chat_status_detailsUpdateManyArgs>(args: SelectSubset<T, chat_status_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chat_status_details and returns the data updated in the database.
     * @param {chat_status_detailsUpdateManyAndReturnArgs} args - Arguments to update many Chat_status_details.
     * @example
     * // Update many Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chat_status_details and only return the `id`
     * const chat_status_detailsWithIdOnly = await prisma.chat_status_details.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chat_status_detailsUpdateManyAndReturnArgs>(args: SelectSubset<T, chat_status_detailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Chat_status_details.
     * @param {chat_status_detailsUpsertArgs} args - Arguments to update or create a Chat_status_details.
     * @example
     * // Update or create a Chat_status_details
     * const chat_status_details = await prisma.chat_status_details.upsert({
     *   create: {
     *     // ... data to create a Chat_status_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chat_status_details we want to update
     *   }
     * })
     */
    upsert<T extends chat_status_detailsUpsertArgs>(args: SelectSubset<T, chat_status_detailsUpsertArgs<ExtArgs>>): Prisma__chat_status_detailsClient<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chat_status_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_status_detailsCountArgs} args - Arguments to filter Chat_status_details to count.
     * @example
     * // Count the number of Chat_status_details
     * const count = await prisma.chat_status_details.count({
     *   where: {
     *     // ... the filter for the Chat_status_details we want to count
     *   }
     * })
    **/
    count<T extends chat_status_detailsCountArgs>(
      args?: Subset<T, chat_status_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Chat_status_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chat_status_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Chat_status_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Chat_status_detailsAggregateArgs>(args: Subset<T, Chat_status_detailsAggregateArgs>): Prisma.PrismaPromise<GetChat_status_detailsAggregateType<T>>

    /**
     * Group by Chat_status_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chat_status_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chat_status_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chat_status_detailsGroupByArgs['orderBy'] }
        : { orderBy?: chat_status_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chat_status_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChat_status_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chat_status_details model
   */
  readonly fields: chat_status_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chat_status_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chat_status_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends chatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatsDefaultArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chat_status_details model
   */ 
  interface chat_status_detailsFieldRefs {
    readonly id: FieldRef<"chat_status_details", 'Int'>
    readonly chat_id: FieldRef<"chat_status_details", 'String'>
    readonly status: FieldRef<"chat_status_details", 'String'>
    readonly changed_by: FieldRef<"chat_status_details", 'String'>
    readonly changed_at: FieldRef<"chat_status_details", 'DateTime'>
    readonly reason: FieldRef<"chat_status_details", 'String'>
    readonly notes: FieldRef<"chat_status_details", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chat_status_details findUnique
   */
  export type chat_status_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * Filter, which chat_status_details to fetch.
     */
    where: chat_status_detailsWhereUniqueInput
  }

  /**
   * chat_status_details findUniqueOrThrow
   */
  export type chat_status_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * Filter, which chat_status_details to fetch.
     */
    where: chat_status_detailsWhereUniqueInput
  }

  /**
   * chat_status_details findFirst
   */
  export type chat_status_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * Filter, which chat_status_details to fetch.
     */
    where?: chat_status_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_status_details to fetch.
     */
    orderBy?: chat_status_detailsOrderByWithRelationInput | chat_status_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_status_details.
     */
    cursor?: chat_status_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_status_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_status_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_status_details.
     */
    distinct?: Chat_status_detailsScalarFieldEnum | Chat_status_detailsScalarFieldEnum[]
  }

  /**
   * chat_status_details findFirstOrThrow
   */
  export type chat_status_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * Filter, which chat_status_details to fetch.
     */
    where?: chat_status_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_status_details to fetch.
     */
    orderBy?: chat_status_detailsOrderByWithRelationInput | chat_status_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chat_status_details.
     */
    cursor?: chat_status_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_status_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_status_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chat_status_details.
     */
    distinct?: Chat_status_detailsScalarFieldEnum | Chat_status_detailsScalarFieldEnum[]
  }

  /**
   * chat_status_details findMany
   */
  export type chat_status_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * Filter, which chat_status_details to fetch.
     */
    where?: chat_status_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chat_status_details to fetch.
     */
    orderBy?: chat_status_detailsOrderByWithRelationInput | chat_status_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chat_status_details.
     */
    cursor?: chat_status_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chat_status_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chat_status_details.
     */
    skip?: number
    distinct?: Chat_status_detailsScalarFieldEnum | Chat_status_detailsScalarFieldEnum[]
  }

  /**
   * chat_status_details create
   */
  export type chat_status_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a chat_status_details.
     */
    data: XOR<chat_status_detailsCreateInput, chat_status_detailsUncheckedCreateInput>
  }

  /**
   * chat_status_details createMany
   */
  export type chat_status_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chat_status_details.
     */
    data: chat_status_detailsCreateManyInput | chat_status_detailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chat_status_details createManyAndReturn
   */
  export type chat_status_detailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * The data used to create many chat_status_details.
     */
    data: chat_status_detailsCreateManyInput | chat_status_detailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_status_details update
   */
  export type chat_status_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a chat_status_details.
     */
    data: XOR<chat_status_detailsUpdateInput, chat_status_detailsUncheckedUpdateInput>
    /**
     * Choose, which chat_status_details to update.
     */
    where: chat_status_detailsWhereUniqueInput
  }

  /**
   * chat_status_details updateMany
   */
  export type chat_status_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chat_status_details.
     */
    data: XOR<chat_status_detailsUpdateManyMutationInput, chat_status_detailsUncheckedUpdateManyInput>
    /**
     * Filter which chat_status_details to update
     */
    where?: chat_status_detailsWhereInput
  }

  /**
   * chat_status_details updateManyAndReturn
   */
  export type chat_status_detailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * The data used to update chat_status_details.
     */
    data: XOR<chat_status_detailsUpdateManyMutationInput, chat_status_detailsUncheckedUpdateManyInput>
    /**
     * Filter which chat_status_details to update
     */
    where?: chat_status_detailsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chat_status_details upsert
   */
  export type chat_status_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the chat_status_details to update in case it exists.
     */
    where: chat_status_detailsWhereUniqueInput
    /**
     * In case the chat_status_details found by the `where` argument doesn't exist, create a new chat_status_details with this data.
     */
    create: XOR<chat_status_detailsCreateInput, chat_status_detailsUncheckedCreateInput>
    /**
     * In case the chat_status_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chat_status_detailsUpdateInput, chat_status_detailsUncheckedUpdateInput>
  }

  /**
   * chat_status_details delete
   */
  export type chat_status_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    /**
     * Filter which chat_status_details to delete.
     */
    where: chat_status_detailsWhereUniqueInput
  }

  /**
   * chat_status_details deleteMany
   */
  export type chat_status_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chat_status_details to delete
     */
    where?: chat_status_detailsWhereInput
  }

  /**
   * chat_status_details without action
   */
  export type chat_status_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
  }


  /**
   * Model chatparticipants
   */

  export type AggregateChatparticipants = {
    _count: ChatparticipantsCountAggregateOutputType | null
    _min: ChatparticipantsMinAggregateOutputType | null
    _max: ChatparticipantsMaxAggregateOutputType | null
  }

  export type ChatparticipantsMinAggregateOutputType = {
    chatid: string | null
    contactid: string | null
  }

  export type ChatparticipantsMaxAggregateOutputType = {
    chatid: string | null
    contactid: string | null
  }

  export type ChatparticipantsCountAggregateOutputType = {
    chatid: number
    contactid: number
    _all: number
  }


  export type ChatparticipantsMinAggregateInputType = {
    chatid?: true
    contactid?: true
  }

  export type ChatparticipantsMaxAggregateInputType = {
    chatid?: true
    contactid?: true
  }

  export type ChatparticipantsCountAggregateInputType = {
    chatid?: true
    contactid?: true
    _all?: true
  }

  export type ChatparticipantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatparticipants to aggregate.
     */
    where?: chatparticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatparticipants to fetch.
     */
    orderBy?: chatparticipantsOrderByWithRelationInput | chatparticipantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatparticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatparticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatparticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chatparticipants
    **/
    _count?: true | ChatparticipantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatparticipantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatparticipantsMaxAggregateInputType
  }

  export type GetChatparticipantsAggregateType<T extends ChatparticipantsAggregateArgs> = {
        [P in keyof T & keyof AggregateChatparticipants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatparticipants[P]>
      : GetScalarType<T[P], AggregateChatparticipants[P]>
  }




  export type chatparticipantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatparticipantsWhereInput
    orderBy?: chatparticipantsOrderByWithAggregationInput | chatparticipantsOrderByWithAggregationInput[]
    by: ChatparticipantsScalarFieldEnum[] | ChatparticipantsScalarFieldEnum
    having?: chatparticipantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatparticipantsCountAggregateInputType | true
    _min?: ChatparticipantsMinAggregateInputType
    _max?: ChatparticipantsMaxAggregateInputType
  }

  export type ChatparticipantsGroupByOutputType = {
    chatid: string
    contactid: string
    _count: ChatparticipantsCountAggregateOutputType | null
    _min: ChatparticipantsMinAggregateOutputType | null
    _max: ChatparticipantsMaxAggregateOutputType | null
  }

  type GetChatparticipantsGroupByPayload<T extends chatparticipantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatparticipantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatparticipantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatparticipantsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatparticipantsGroupByOutputType[P]>
        }
      >
    >


  export type chatparticipantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatid?: boolean
    contactid?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    contacts?: boolean | contactsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatparticipants"]>

  export type chatparticipantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatid?: boolean
    contactid?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    contacts?: boolean | contactsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatparticipants"]>

  export type chatparticipantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    chatid?: boolean
    contactid?: boolean
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    contacts?: boolean | contactsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatparticipants"]>

  export type chatparticipantsSelectScalar = {
    chatid?: boolean
    contactid?: boolean
  }

  export type chatparticipantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"chatid" | "contactid", ExtArgs["result"]["chatparticipants"]>
  export type chatparticipantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    contacts?: boolean | contactsDefaultArgs<ExtArgs>
  }
  export type chatparticipantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    contacts?: boolean | contactsDefaultArgs<ExtArgs>
  }
  export type chatparticipantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | chatsDefaultArgs<ExtArgs>
    contacts?: boolean | contactsDefaultArgs<ExtArgs>
  }

  export type $chatparticipantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chatparticipants"
    objects: {
      chats: Prisma.$chatsPayload<ExtArgs>
      contacts: Prisma.$contactsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      chatid: string
      contactid: string
    }, ExtArgs["result"]["chatparticipants"]>
    composites: {}
  }

  type chatparticipantsGetPayload<S extends boolean | null | undefined | chatparticipantsDefaultArgs> = $Result.GetResult<Prisma.$chatparticipantsPayload, S>

  type chatparticipantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatparticipantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatparticipantsCountAggregateInputType | true
    }

  export interface chatparticipantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chatparticipants'], meta: { name: 'chatparticipants' } }
    /**
     * Find zero or one Chatparticipants that matches the filter.
     * @param {chatparticipantsFindUniqueArgs} args - Arguments to find a Chatparticipants
     * @example
     * // Get one Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatparticipantsFindUniqueArgs>(args: SelectSubset<T, chatparticipantsFindUniqueArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chatparticipants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatparticipantsFindUniqueOrThrowArgs} args - Arguments to find a Chatparticipants
     * @example
     * // Get one Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatparticipantsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatparticipantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chatparticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatparticipantsFindFirstArgs} args - Arguments to find a Chatparticipants
     * @example
     * // Get one Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatparticipantsFindFirstArgs>(args?: SelectSubset<T, chatparticipantsFindFirstArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chatparticipants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatparticipantsFindFirstOrThrowArgs} args - Arguments to find a Chatparticipants
     * @example
     * // Get one Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatparticipantsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatparticipantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chatparticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatparticipantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.findMany()
     * 
     * // Get first 10 Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.findMany({ take: 10 })
     * 
     * // Only select the `chatid`
     * const chatparticipantsWithChatidOnly = await prisma.chatparticipants.findMany({ select: { chatid: true } })
     * 
     */
    findMany<T extends chatparticipantsFindManyArgs>(args?: SelectSubset<T, chatparticipantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chatparticipants.
     * @param {chatparticipantsCreateArgs} args - Arguments to create a Chatparticipants.
     * @example
     * // Create one Chatparticipants
     * const Chatparticipants = await prisma.chatparticipants.create({
     *   data: {
     *     // ... data to create a Chatparticipants
     *   }
     * })
     * 
     */
    create<T extends chatparticipantsCreateArgs>(args: SelectSubset<T, chatparticipantsCreateArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chatparticipants.
     * @param {chatparticipantsCreateManyArgs} args - Arguments to create many Chatparticipants.
     * @example
     * // Create many Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatparticipantsCreateManyArgs>(args?: SelectSubset<T, chatparticipantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chatparticipants and returns the data saved in the database.
     * @param {chatparticipantsCreateManyAndReturnArgs} args - Arguments to create many Chatparticipants.
     * @example
     * // Create many Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chatparticipants and only return the `chatid`
     * const chatparticipantsWithChatidOnly = await prisma.chatparticipants.createManyAndReturn({
     *   select: { chatid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatparticipantsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatparticipantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Chatparticipants.
     * @param {chatparticipantsDeleteArgs} args - Arguments to delete one Chatparticipants.
     * @example
     * // Delete one Chatparticipants
     * const Chatparticipants = await prisma.chatparticipants.delete({
     *   where: {
     *     // ... filter to delete one Chatparticipants
     *   }
     * })
     * 
     */
    delete<T extends chatparticipantsDeleteArgs>(args: SelectSubset<T, chatparticipantsDeleteArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chatparticipants.
     * @param {chatparticipantsUpdateArgs} args - Arguments to update one Chatparticipants.
     * @example
     * // Update one Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatparticipantsUpdateArgs>(args: SelectSubset<T, chatparticipantsUpdateArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chatparticipants.
     * @param {chatparticipantsDeleteManyArgs} args - Arguments to filter Chatparticipants to delete.
     * @example
     * // Delete a few Chatparticipants
     * const { count } = await prisma.chatparticipants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatparticipantsDeleteManyArgs>(args?: SelectSubset<T, chatparticipantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatparticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatparticipantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatparticipantsUpdateManyArgs>(args: SelectSubset<T, chatparticipantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chatparticipants and returns the data updated in the database.
     * @param {chatparticipantsUpdateManyAndReturnArgs} args - Arguments to update many Chatparticipants.
     * @example
     * // Update many Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chatparticipants and only return the `chatid`
     * const chatparticipantsWithChatidOnly = await prisma.chatparticipants.updateManyAndReturn({
     *   select: { chatid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatparticipantsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatparticipantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Chatparticipants.
     * @param {chatparticipantsUpsertArgs} args - Arguments to update or create a Chatparticipants.
     * @example
     * // Update or create a Chatparticipants
     * const chatparticipants = await prisma.chatparticipants.upsert({
     *   create: {
     *     // ... data to create a Chatparticipants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chatparticipants we want to update
     *   }
     * })
     */
    upsert<T extends chatparticipantsUpsertArgs>(args: SelectSubset<T, chatparticipantsUpsertArgs<ExtArgs>>): Prisma__chatparticipantsClient<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chatparticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatparticipantsCountArgs} args - Arguments to filter Chatparticipants to count.
     * @example
     * // Count the number of Chatparticipants
     * const count = await prisma.chatparticipants.count({
     *   where: {
     *     // ... the filter for the Chatparticipants we want to count
     *   }
     * })
    **/
    count<T extends chatparticipantsCountArgs>(
      args?: Subset<T, chatparticipantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatparticipantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chatparticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatparticipantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatparticipantsAggregateArgs>(args: Subset<T, ChatparticipantsAggregateArgs>): Prisma.PrismaPromise<GetChatparticipantsAggregateType<T>>

    /**
     * Group by Chatparticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatparticipantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatparticipantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatparticipantsGroupByArgs['orderBy'] }
        : { orderBy?: chatparticipantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatparticipantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatparticipantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chatparticipants model
   */
  readonly fields: chatparticipantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chatparticipants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatparticipantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chats<T extends chatsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, chatsDefaultArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    contacts<T extends contactsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, contactsDefaultArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chatparticipants model
   */ 
  interface chatparticipantsFieldRefs {
    readonly chatid: FieldRef<"chatparticipants", 'String'>
    readonly contactid: FieldRef<"chatparticipants", 'String'>
  }
    

  // Custom InputTypes
  /**
   * chatparticipants findUnique
   */
  export type chatparticipantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * Filter, which chatparticipants to fetch.
     */
    where: chatparticipantsWhereUniqueInput
  }

  /**
   * chatparticipants findUniqueOrThrow
   */
  export type chatparticipantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * Filter, which chatparticipants to fetch.
     */
    where: chatparticipantsWhereUniqueInput
  }

  /**
   * chatparticipants findFirst
   */
  export type chatparticipantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * Filter, which chatparticipants to fetch.
     */
    where?: chatparticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatparticipants to fetch.
     */
    orderBy?: chatparticipantsOrderByWithRelationInput | chatparticipantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatparticipants.
     */
    cursor?: chatparticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatparticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatparticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatparticipants.
     */
    distinct?: ChatparticipantsScalarFieldEnum | ChatparticipantsScalarFieldEnum[]
  }

  /**
   * chatparticipants findFirstOrThrow
   */
  export type chatparticipantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * Filter, which chatparticipants to fetch.
     */
    where?: chatparticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatparticipants to fetch.
     */
    orderBy?: chatparticipantsOrderByWithRelationInput | chatparticipantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chatparticipants.
     */
    cursor?: chatparticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatparticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatparticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chatparticipants.
     */
    distinct?: ChatparticipantsScalarFieldEnum | ChatparticipantsScalarFieldEnum[]
  }

  /**
   * chatparticipants findMany
   */
  export type chatparticipantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * Filter, which chatparticipants to fetch.
     */
    where?: chatparticipantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chatparticipants to fetch.
     */
    orderBy?: chatparticipantsOrderByWithRelationInput | chatparticipantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chatparticipants.
     */
    cursor?: chatparticipantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chatparticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chatparticipants.
     */
    skip?: number
    distinct?: ChatparticipantsScalarFieldEnum | ChatparticipantsScalarFieldEnum[]
  }

  /**
   * chatparticipants create
   */
  export type chatparticipantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * The data needed to create a chatparticipants.
     */
    data: XOR<chatparticipantsCreateInput, chatparticipantsUncheckedCreateInput>
  }

  /**
   * chatparticipants createMany
   */
  export type chatparticipantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chatparticipants.
     */
    data: chatparticipantsCreateManyInput | chatparticipantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chatparticipants createManyAndReturn
   */
  export type chatparticipantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * The data used to create many chatparticipants.
     */
    data: chatparticipantsCreateManyInput | chatparticipantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatparticipants update
   */
  export type chatparticipantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * The data needed to update a chatparticipants.
     */
    data: XOR<chatparticipantsUpdateInput, chatparticipantsUncheckedUpdateInput>
    /**
     * Choose, which chatparticipants to update.
     */
    where: chatparticipantsWhereUniqueInput
  }

  /**
   * chatparticipants updateMany
   */
  export type chatparticipantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chatparticipants.
     */
    data: XOR<chatparticipantsUpdateManyMutationInput, chatparticipantsUncheckedUpdateManyInput>
    /**
     * Filter which chatparticipants to update
     */
    where?: chatparticipantsWhereInput
  }

  /**
   * chatparticipants updateManyAndReturn
   */
  export type chatparticipantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * The data used to update chatparticipants.
     */
    data: XOR<chatparticipantsUpdateManyMutationInput, chatparticipantsUncheckedUpdateManyInput>
    /**
     * Filter which chatparticipants to update
     */
    where?: chatparticipantsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * chatparticipants upsert
   */
  export type chatparticipantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * The filter to search for the chatparticipants to update in case it exists.
     */
    where: chatparticipantsWhereUniqueInput
    /**
     * In case the chatparticipants found by the `where` argument doesn't exist, create a new chatparticipants with this data.
     */
    create: XOR<chatparticipantsCreateInput, chatparticipantsUncheckedCreateInput>
    /**
     * In case the chatparticipants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatparticipantsUpdateInput, chatparticipantsUncheckedUpdateInput>
  }

  /**
   * chatparticipants delete
   */
  export type chatparticipantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    /**
     * Filter which chatparticipants to delete.
     */
    where: chatparticipantsWhereUniqueInput
  }

  /**
   * chatparticipants deleteMany
   */
  export type chatparticipantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chatparticipants to delete
     */
    where?: chatparticipantsWhereInput
  }

  /**
   * chatparticipants without action
   */
  export type chatparticipantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
  }


  /**
   * Model chats
   */

  export type AggregateChats = {
    _count: ChatsCountAggregateOutputType | null
    _avg: ChatsAvgAggregateOutputType | null
    _sum: ChatsSumAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  export type ChatsAvgAggregateOutputType = {
    unReadCount: number | null
  }

  export type ChatsSumAggregateOutputType = {
    unReadCount: number | null
  }

  export type ChatsMinAggregateOutputType = {
    id: string | null
    lastMessage: string | null
    lastMessageTime: Date | null
    unReadCount: number | null
    isOnline: boolean | null
    contactId: string | null
    isTyping: string | null
    userId: string | null
    pushname: string | null
    assignedTo: string | null
    isarchived: boolean | null
    ismuted: boolean | null
    status: string | null
    closedAt: Date | null
    closeReason: string | null
    avatar: string | null
    isPinned: boolean | null
  }

  export type ChatsMaxAggregateOutputType = {
    id: string | null
    lastMessage: string | null
    lastMessageTime: Date | null
    unReadCount: number | null
    isOnline: boolean | null
    contactId: string | null
    isTyping: string | null
    userId: string | null
    pushname: string | null
    assignedTo: string | null
    isarchived: boolean | null
    ismuted: boolean | null
    status: string | null
    closedAt: Date | null
    closeReason: string | null
    avatar: string | null
    isPinned: boolean | null
  }

  export type ChatsCountAggregateOutputType = {
    id: number
    lastMessage: number
    lastMessageTime: number
    unReadCount: number
    isOnline: number
    contactId: number
    isTyping: number
    userId: number
    pushname: number
    assignedTo: number
    isarchived: number
    ismuted: number
    status: number
    closedAt: number
    closeReason: number
    participants: number
    avatar: number
    isPinned: number
    _all: number
  }


  export type ChatsAvgAggregateInputType = {
    unReadCount?: true
  }

  export type ChatsSumAggregateInputType = {
    unReadCount?: true
  }

  export type ChatsMinAggregateInputType = {
    id?: true
    lastMessage?: true
    lastMessageTime?: true
    unReadCount?: true
    isOnline?: true
    contactId?: true
    isTyping?: true
    userId?: true
    pushname?: true
    assignedTo?: true
    isarchived?: true
    ismuted?: true
    status?: true
    closedAt?: true
    closeReason?: true
    avatar?: true
    isPinned?: true
  }

  export type ChatsMaxAggregateInputType = {
    id?: true
    lastMessage?: true
    lastMessageTime?: true
    unReadCount?: true
    isOnline?: true
    contactId?: true
    isTyping?: true
    userId?: true
    pushname?: true
    assignedTo?: true
    isarchived?: true
    ismuted?: true
    status?: true
    closedAt?: true
    closeReason?: true
    avatar?: true
    isPinned?: true
  }

  export type ChatsCountAggregateInputType = {
    id?: true
    lastMessage?: true
    lastMessageTime?: true
    unReadCount?: true
    isOnline?: true
    contactId?: true
    isTyping?: true
    userId?: true
    pushname?: true
    assignedTo?: true
    isarchived?: true
    ismuted?: true
    status?: true
    closedAt?: true
    closeReason?: true
    participants?: true
    avatar?: true
    isPinned?: true
    _all?: true
  }

  export type ChatsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to aggregate.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned chats
    **/
    _count?: true | ChatsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChatsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChatsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatsMaxAggregateInputType
  }

  export type GetChatsAggregateType<T extends ChatsAggregateArgs> = {
        [P in keyof T & keyof AggregateChats]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChats[P]>
      : GetScalarType<T[P], AggregateChats[P]>
  }




  export type chatsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: chatsWhereInput
    orderBy?: chatsOrderByWithAggregationInput | chatsOrderByWithAggregationInput[]
    by: ChatsScalarFieldEnum[] | ChatsScalarFieldEnum
    having?: chatsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatsCountAggregateInputType | true
    _avg?: ChatsAvgAggregateInputType
    _sum?: ChatsSumAggregateInputType
    _min?: ChatsMinAggregateInputType
    _max?: ChatsMaxAggregateInputType
  }

  export type ChatsGroupByOutputType = {
    id: string
    lastMessage: string | null
    lastMessageTime: Date | null
    unReadCount: number | null
    isOnline: boolean | null
    contactId: string | null
    isTyping: string | null
    userId: string | null
    pushname: string | null
    assignedTo: string | null
    isarchived: boolean | null
    ismuted: boolean | null
    status: string | null
    closedAt: Date | null
    closeReason: string | null
    participants: JsonValue | null
    avatar: string | null
    isPinned: boolean | null
    _count: ChatsCountAggregateOutputType | null
    _avg: ChatsAvgAggregateOutputType | null
    _sum: ChatsSumAggregateOutputType | null
    _min: ChatsMinAggregateOutputType | null
    _max: ChatsMaxAggregateOutputType | null
  }

  type GetChatsGroupByPayload<T extends chatsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatsGroupByOutputType[P]>
            : GetScalarType<T[P], ChatsGroupByOutputType[P]>
        }
      >
    >


  export type chatsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isOnline?: boolean
    contactId?: boolean
    isTyping?: boolean
    userId?: boolean
    pushname?: boolean
    assignedTo?: boolean
    isarchived?: boolean
    ismuted?: boolean
    status?: boolean
    closedAt?: boolean
    closeReason?: boolean
    participants?: boolean
    avatar?: boolean
    isPinned?: boolean
    chat_status_details?: boolean | chats$chat_status_detailsArgs<ExtArgs>
    chatparticipants?: boolean | chats$chatparticipantsArgs<ExtArgs>
    messages?: boolean | chats$messagesArgs<ExtArgs>
    _count?: boolean | ChatsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isOnline?: boolean
    contactId?: boolean
    isTyping?: boolean
    userId?: boolean
    pushname?: boolean
    assignedTo?: boolean
    isarchived?: boolean
    ismuted?: boolean
    status?: boolean
    closedAt?: boolean
    closeReason?: boolean
    participants?: boolean
    avatar?: boolean
    isPinned?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isOnline?: boolean
    contactId?: boolean
    isTyping?: boolean
    userId?: boolean
    pushname?: boolean
    assignedTo?: boolean
    isarchived?: boolean
    ismuted?: boolean
    status?: boolean
    closedAt?: boolean
    closeReason?: boolean
    participants?: boolean
    avatar?: boolean
    isPinned?: boolean
  }, ExtArgs["result"]["chats"]>

  export type chatsSelectScalar = {
    id?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isOnline?: boolean
    contactId?: boolean
    isTyping?: boolean
    userId?: boolean
    pushname?: boolean
    assignedTo?: boolean
    isarchived?: boolean
    ismuted?: boolean
    status?: boolean
    closedAt?: boolean
    closeReason?: boolean
    participants?: boolean
    avatar?: boolean
    isPinned?: boolean
  }

  export type chatsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lastMessage" | "lastMessageTime" | "unReadCount" | "isOnline" | "contactId" | "isTyping" | "userId" | "pushname" | "assignedTo" | "isarchived" | "ismuted" | "status" | "closedAt" | "closeReason" | "participants" | "avatar" | "isPinned", ExtArgs["result"]["chats"]>
  export type chatsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chat_status_details?: boolean | chats$chat_status_detailsArgs<ExtArgs>
    chatparticipants?: boolean | chats$chatparticipantsArgs<ExtArgs>
    messages?: boolean | chats$messagesArgs<ExtArgs>
    _count?: boolean | ChatsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type chatsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type chatsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $chatsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "chats"
    objects: {
      chat_status_details: Prisma.$chat_status_detailsPayload<ExtArgs>[]
      chatparticipants: Prisma.$chatparticipantsPayload<ExtArgs>[]
      messages: Prisma.$messagesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lastMessage: string | null
      lastMessageTime: Date | null
      unReadCount: number | null
      isOnline: boolean | null
      contactId: string | null
      isTyping: string | null
      userId: string | null
      pushname: string | null
      assignedTo: string | null
      isarchived: boolean | null
      ismuted: boolean | null
      status: string | null
      closedAt: Date | null
      closeReason: string | null
      participants: Prisma.JsonValue | null
      avatar: string | null
      isPinned: boolean | null
    }, ExtArgs["result"]["chats"]>
    composites: {}
  }

  type chatsGetPayload<S extends boolean | null | undefined | chatsDefaultArgs> = $Result.GetResult<Prisma.$chatsPayload, S>

  type chatsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<chatsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChatsCountAggregateInputType | true
    }

  export interface chatsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['chats'], meta: { name: 'chats' } }
    /**
     * Find zero or one Chats that matches the filter.
     * @param {chatsFindUniqueArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends chatsFindUniqueArgs>(args: SelectSubset<T, chatsFindUniqueArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Chats that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {chatsFindUniqueOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends chatsFindUniqueOrThrowArgs>(args: SelectSubset<T, chatsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends chatsFindFirstArgs>(args?: SelectSubset<T, chatsFindFirstArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Chats that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindFirstOrThrowArgs} args - Arguments to find a Chats
     * @example
     * // Get one Chats
     * const chats = await prisma.chats.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends chatsFindFirstOrThrowArgs>(args?: SelectSubset<T, chatsFindFirstOrThrowArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Chats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chats
     * const chats = await prisma.chats.findMany()
     * 
     * // Get first 10 Chats
     * const chats = await prisma.chats.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatsWithIdOnly = await prisma.chats.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends chatsFindManyArgs>(args?: SelectSubset<T, chatsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Chats.
     * @param {chatsCreateArgs} args - Arguments to create a Chats.
     * @example
     * // Create one Chats
     * const Chats = await prisma.chats.create({
     *   data: {
     *     // ... data to create a Chats
     *   }
     * })
     * 
     */
    create<T extends chatsCreateArgs>(args: SelectSubset<T, chatsCreateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Chats.
     * @param {chatsCreateManyArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends chatsCreateManyArgs>(args?: SelectSubset<T, chatsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Chats and returns the data saved in the database.
     * @param {chatsCreateManyAndReturnArgs} args - Arguments to create many Chats.
     * @example
     * // Create many Chats
     * const chats = await prisma.chats.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Chats and only return the `id`
     * const chatsWithIdOnly = await prisma.chats.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends chatsCreateManyAndReturnArgs>(args?: SelectSubset<T, chatsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Chats.
     * @param {chatsDeleteArgs} args - Arguments to delete one Chats.
     * @example
     * // Delete one Chats
     * const Chats = await prisma.chats.delete({
     *   where: {
     *     // ... filter to delete one Chats
     *   }
     * })
     * 
     */
    delete<T extends chatsDeleteArgs>(args: SelectSubset<T, chatsDeleteArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Chats.
     * @param {chatsUpdateArgs} args - Arguments to update one Chats.
     * @example
     * // Update one Chats
     * const chats = await prisma.chats.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends chatsUpdateArgs>(args: SelectSubset<T, chatsUpdateArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Chats.
     * @param {chatsDeleteManyArgs} args - Arguments to filter Chats to delete.
     * @example
     * // Delete a few Chats
     * const { count } = await prisma.chats.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends chatsDeleteManyArgs>(args?: SelectSubset<T, chatsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends chatsUpdateManyArgs>(args: SelectSubset<T, chatsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chats and returns the data updated in the database.
     * @param {chatsUpdateManyAndReturnArgs} args - Arguments to update many Chats.
     * @example
     * // Update many Chats
     * const chats = await prisma.chats.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Chats and only return the `id`
     * const chatsWithIdOnly = await prisma.chats.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends chatsUpdateManyAndReturnArgs>(args: SelectSubset<T, chatsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Chats.
     * @param {chatsUpsertArgs} args - Arguments to update or create a Chats.
     * @example
     * // Update or create a Chats
     * const chats = await prisma.chats.upsert({
     *   create: {
     *     // ... data to create a Chats
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chats we want to update
     *   }
     * })
     */
    upsert<T extends chatsUpsertArgs>(args: SelectSubset<T, chatsUpsertArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsCountArgs} args - Arguments to filter Chats to count.
     * @example
     * // Count the number of Chats
     * const count = await prisma.chats.count({
     *   where: {
     *     // ... the filter for the Chats we want to count
     *   }
     * })
    **/
    count<T extends chatsCountArgs>(
      args?: Subset<T, chatsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatsAggregateArgs>(args: Subset<T, ChatsAggregateArgs>): Prisma.PrismaPromise<GetChatsAggregateType<T>>

    /**
     * Group by Chats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {chatsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends chatsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: chatsGroupByArgs['orderBy'] }
        : { orderBy?: chatsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, chatsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the chats model
   */
  readonly fields: chatsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for chats.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__chatsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chat_status_details<T extends chats$chat_status_detailsArgs<ExtArgs> = {}>(args?: Subset<T, chats$chat_status_detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chat_status_detailsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    chatparticipants<T extends chats$chatparticipantsArgs<ExtArgs> = {}>(args?: Subset<T, chats$chatparticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    messages<T extends chats$messagesArgs<ExtArgs> = {}>(args?: Subset<T, chats$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the chats model
   */ 
  interface chatsFieldRefs {
    readonly id: FieldRef<"chats", 'String'>
    readonly lastMessage: FieldRef<"chats", 'String'>
    readonly lastMessageTime: FieldRef<"chats", 'DateTime'>
    readonly unReadCount: FieldRef<"chats", 'Int'>
    readonly isOnline: FieldRef<"chats", 'Boolean'>
    readonly contactId: FieldRef<"chats", 'String'>
    readonly isTyping: FieldRef<"chats", 'String'>
    readonly userId: FieldRef<"chats", 'String'>
    readonly pushname: FieldRef<"chats", 'String'>
    readonly assignedTo: FieldRef<"chats", 'String'>
    readonly isarchived: FieldRef<"chats", 'Boolean'>
    readonly ismuted: FieldRef<"chats", 'Boolean'>
    readonly status: FieldRef<"chats", 'String'>
    readonly closedAt: FieldRef<"chats", 'DateTime'>
    readonly closeReason: FieldRef<"chats", 'String'>
    readonly participants: FieldRef<"chats", 'Json'>
    readonly avatar: FieldRef<"chats", 'String'>
    readonly isPinned: FieldRef<"chats", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * chats findUnique
   */
  export type chatsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findUniqueOrThrow
   */
  export type chatsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats findFirst
   */
  export type chatsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findFirstOrThrow
   */
  export type chatsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of chats.
     */
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats findMany
   */
  export type chatsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter, which chats to fetch.
     */
    where?: chatsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of chats to fetch.
     */
    orderBy?: chatsOrderByWithRelationInput | chatsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing chats.
     */
    cursor?: chatsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` chats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` chats.
     */
    skip?: number
    distinct?: ChatsScalarFieldEnum | ChatsScalarFieldEnum[]
  }

  /**
   * chats create
   */
  export type chatsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The data needed to create a chats.
     */
    data: XOR<chatsCreateInput, chatsUncheckedCreateInput>
  }

  /**
   * chats createMany
   */
  export type chatsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats createManyAndReturn
   */
  export type chatsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to create many chats.
     */
    data: chatsCreateManyInput | chatsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * chats update
   */
  export type chatsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The data needed to update a chats.
     */
    data: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
    /**
     * Choose, which chats to update.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats updateMany
   */
  export type chatsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
  }

  /**
   * chats updateManyAndReturn
   */
  export type chatsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * The data used to update chats.
     */
    data: XOR<chatsUpdateManyMutationInput, chatsUncheckedUpdateManyInput>
    /**
     * Filter which chats to update
     */
    where?: chatsWhereInput
  }

  /**
   * chats upsert
   */
  export type chatsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * The filter to search for the chats to update in case it exists.
     */
    where: chatsWhereUniqueInput
    /**
     * In case the chats found by the `where` argument doesn't exist, create a new chats with this data.
     */
    create: XOR<chatsCreateInput, chatsUncheckedCreateInput>
    /**
     * In case the chats was found with the provided `where` argument, update it with this data.
     */
    update: XOR<chatsUpdateInput, chatsUncheckedUpdateInput>
  }

  /**
   * chats delete
   */
  export type chatsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    /**
     * Filter which chats to delete.
     */
    where: chatsWhereUniqueInput
  }

  /**
   * chats deleteMany
   */
  export type chatsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which chats to delete
     */
    where?: chatsWhereInput
  }

  /**
   * chats.chat_status_details
   */
  export type chats$chat_status_detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chat_status_details
     */
    select?: chat_status_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chat_status_details
     */
    omit?: chat_status_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chat_status_detailsInclude<ExtArgs> | null
    where?: chat_status_detailsWhereInput
    orderBy?: chat_status_detailsOrderByWithRelationInput | chat_status_detailsOrderByWithRelationInput[]
    cursor?: chat_status_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Chat_status_detailsScalarFieldEnum | Chat_status_detailsScalarFieldEnum[]
  }

  /**
   * chats.chatparticipants
   */
  export type chats$chatparticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    where?: chatparticipantsWhereInput
    orderBy?: chatparticipantsOrderByWithRelationInput | chatparticipantsOrderByWithRelationInput[]
    cursor?: chatparticipantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatparticipantsScalarFieldEnum | ChatparticipantsScalarFieldEnum[]
  }

  /**
   * chats.messages
   */
  export type chats$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * chats without action
   */
  export type chatsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
  }


  /**
   * Model cleaned_contacts
   */

  export type AggregateCleaned_contacts = {
    _count: Cleaned_contactsCountAggregateOutputType | null
    _min: Cleaned_contactsMinAggregateOutputType | null
    _max: Cleaned_contactsMaxAggregateOutputType | null
  }

  export type Cleaned_contactsMinAggregateOutputType = {
    phone: string | null
    first_name: string | null
    full_name: string | null
    push_name: string | null
    business_name: string | null
  }

  export type Cleaned_contactsMaxAggregateOutputType = {
    phone: string | null
    first_name: string | null
    full_name: string | null
    push_name: string | null
    business_name: string | null
  }

  export type Cleaned_contactsCountAggregateOutputType = {
    phone: number
    first_name: number
    full_name: number
    push_name: number
    business_name: number
    _all: number
  }


  export type Cleaned_contactsMinAggregateInputType = {
    phone?: true
    first_name?: true
    full_name?: true
    push_name?: true
    business_name?: true
  }

  export type Cleaned_contactsMaxAggregateInputType = {
    phone?: true
    first_name?: true
    full_name?: true
    push_name?: true
    business_name?: true
  }

  export type Cleaned_contactsCountAggregateInputType = {
    phone?: true
    first_name?: true
    full_name?: true
    push_name?: true
    business_name?: true
    _all?: true
  }

  export type Cleaned_contactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cleaned_contacts to aggregate.
     */
    where?: cleaned_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleaned_contacts to fetch.
     */
    orderBy?: cleaned_contactsOrderByWithRelationInput | cleaned_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cleaned_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleaned_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleaned_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cleaned_contacts
    **/
    _count?: true | Cleaned_contactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cleaned_contactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cleaned_contactsMaxAggregateInputType
  }

  export type GetCleaned_contactsAggregateType<T extends Cleaned_contactsAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaned_contacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaned_contacts[P]>
      : GetScalarType<T[P], AggregateCleaned_contacts[P]>
  }




  export type cleaned_contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cleaned_contactsWhereInput
    orderBy?: cleaned_contactsOrderByWithAggregationInput | cleaned_contactsOrderByWithAggregationInput[]
    by: Cleaned_contactsScalarFieldEnum[] | Cleaned_contactsScalarFieldEnum
    having?: cleaned_contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cleaned_contactsCountAggregateInputType | true
    _min?: Cleaned_contactsMinAggregateInputType
    _max?: Cleaned_contactsMaxAggregateInputType
  }

  export type Cleaned_contactsGroupByOutputType = {
    phone: string
    first_name: string | null
    full_name: string | null
    push_name: string | null
    business_name: string | null
    _count: Cleaned_contactsCountAggregateOutputType | null
    _min: Cleaned_contactsMinAggregateOutputType | null
    _max: Cleaned_contactsMaxAggregateOutputType | null
  }

  type GetCleaned_contactsGroupByPayload<T extends cleaned_contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cleaned_contactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cleaned_contactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cleaned_contactsGroupByOutputType[P]>
            : GetScalarType<T[P], Cleaned_contactsGroupByOutputType[P]>
        }
      >
    >


  export type cleaned_contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    phone?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
  }, ExtArgs["result"]["cleaned_contacts"]>

  export type cleaned_contactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    phone?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
  }, ExtArgs["result"]["cleaned_contacts"]>

  export type cleaned_contactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    phone?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
  }, ExtArgs["result"]["cleaned_contacts"]>

  export type cleaned_contactsSelectScalar = {
    phone?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
  }

  export type cleaned_contactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"phone" | "first_name" | "full_name" | "push_name" | "business_name", ExtArgs["result"]["cleaned_contacts"]>

  export type $cleaned_contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cleaned_contacts"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      phone: string
      first_name: string | null
      full_name: string | null
      push_name: string | null
      business_name: string | null
    }, ExtArgs["result"]["cleaned_contacts"]>
    composites: {}
  }

  type cleaned_contactsGetPayload<S extends boolean | null | undefined | cleaned_contactsDefaultArgs> = $Result.GetResult<Prisma.$cleaned_contactsPayload, S>

  type cleaned_contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cleaned_contactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cleaned_contactsCountAggregateInputType | true
    }

  export interface cleaned_contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cleaned_contacts'], meta: { name: 'cleaned_contacts' } }
    /**
     * Find zero or one Cleaned_contacts that matches the filter.
     * @param {cleaned_contactsFindUniqueArgs} args - Arguments to find a Cleaned_contacts
     * @example
     * // Get one Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cleaned_contactsFindUniqueArgs>(args: SelectSubset<T, cleaned_contactsFindUniqueArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Cleaned_contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cleaned_contactsFindUniqueOrThrowArgs} args - Arguments to find a Cleaned_contacts
     * @example
     * // Get one Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cleaned_contactsFindUniqueOrThrowArgs>(args: SelectSubset<T, cleaned_contactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Cleaned_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleaned_contactsFindFirstArgs} args - Arguments to find a Cleaned_contacts
     * @example
     * // Get one Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cleaned_contactsFindFirstArgs>(args?: SelectSubset<T, cleaned_contactsFindFirstArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Cleaned_contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleaned_contactsFindFirstOrThrowArgs} args - Arguments to find a Cleaned_contacts
     * @example
     * // Get one Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cleaned_contactsFindFirstOrThrowArgs>(args?: SelectSubset<T, cleaned_contactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Cleaned_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleaned_contactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.findMany()
     * 
     * // Get first 10 Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.findMany({ take: 10 })
     * 
     * // Only select the `phone`
     * const cleaned_contactsWithPhoneOnly = await prisma.cleaned_contacts.findMany({ select: { phone: true } })
     * 
     */
    findMany<T extends cleaned_contactsFindManyArgs>(args?: SelectSubset<T, cleaned_contactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Cleaned_contacts.
     * @param {cleaned_contactsCreateArgs} args - Arguments to create a Cleaned_contacts.
     * @example
     * // Create one Cleaned_contacts
     * const Cleaned_contacts = await prisma.cleaned_contacts.create({
     *   data: {
     *     // ... data to create a Cleaned_contacts
     *   }
     * })
     * 
     */
    create<T extends cleaned_contactsCreateArgs>(args: SelectSubset<T, cleaned_contactsCreateArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Cleaned_contacts.
     * @param {cleaned_contactsCreateManyArgs} args - Arguments to create many Cleaned_contacts.
     * @example
     * // Create many Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cleaned_contactsCreateManyArgs>(args?: SelectSubset<T, cleaned_contactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cleaned_contacts and returns the data saved in the database.
     * @param {cleaned_contactsCreateManyAndReturnArgs} args - Arguments to create many Cleaned_contacts.
     * @example
     * // Create many Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cleaned_contacts and only return the `phone`
     * const cleaned_contactsWithPhoneOnly = await prisma.cleaned_contacts.createManyAndReturn({
     *   select: { phone: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cleaned_contactsCreateManyAndReturnArgs>(args?: SelectSubset<T, cleaned_contactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Cleaned_contacts.
     * @param {cleaned_contactsDeleteArgs} args - Arguments to delete one Cleaned_contacts.
     * @example
     * // Delete one Cleaned_contacts
     * const Cleaned_contacts = await prisma.cleaned_contacts.delete({
     *   where: {
     *     // ... filter to delete one Cleaned_contacts
     *   }
     * })
     * 
     */
    delete<T extends cleaned_contactsDeleteArgs>(args: SelectSubset<T, cleaned_contactsDeleteArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Cleaned_contacts.
     * @param {cleaned_contactsUpdateArgs} args - Arguments to update one Cleaned_contacts.
     * @example
     * // Update one Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cleaned_contactsUpdateArgs>(args: SelectSubset<T, cleaned_contactsUpdateArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Cleaned_contacts.
     * @param {cleaned_contactsDeleteManyArgs} args - Arguments to filter Cleaned_contacts to delete.
     * @example
     * // Delete a few Cleaned_contacts
     * const { count } = await prisma.cleaned_contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cleaned_contactsDeleteManyArgs>(args?: SelectSubset<T, cleaned_contactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cleaned_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleaned_contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cleaned_contactsUpdateManyArgs>(args: SelectSubset<T, cleaned_contactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cleaned_contacts and returns the data updated in the database.
     * @param {cleaned_contactsUpdateManyAndReturnArgs} args - Arguments to update many Cleaned_contacts.
     * @example
     * // Update many Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cleaned_contacts and only return the `phone`
     * const cleaned_contactsWithPhoneOnly = await prisma.cleaned_contacts.updateManyAndReturn({
     *   select: { phone: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cleaned_contactsUpdateManyAndReturnArgs>(args: SelectSubset<T, cleaned_contactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Cleaned_contacts.
     * @param {cleaned_contactsUpsertArgs} args - Arguments to update or create a Cleaned_contacts.
     * @example
     * // Update or create a Cleaned_contacts
     * const cleaned_contacts = await prisma.cleaned_contacts.upsert({
     *   create: {
     *     // ... data to create a Cleaned_contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cleaned_contacts we want to update
     *   }
     * })
     */
    upsert<T extends cleaned_contactsUpsertArgs>(args: SelectSubset<T, cleaned_contactsUpsertArgs<ExtArgs>>): Prisma__cleaned_contactsClient<$Result.GetResult<Prisma.$cleaned_contactsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Cleaned_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleaned_contactsCountArgs} args - Arguments to filter Cleaned_contacts to count.
     * @example
     * // Count the number of Cleaned_contacts
     * const count = await prisma.cleaned_contacts.count({
     *   where: {
     *     // ... the filter for the Cleaned_contacts we want to count
     *   }
     * })
    **/
    count<T extends cleaned_contactsCountArgs>(
      args?: Subset<T, cleaned_contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cleaned_contactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cleaned_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cleaned_contactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cleaned_contactsAggregateArgs>(args: Subset<T, Cleaned_contactsAggregateArgs>): Prisma.PrismaPromise<GetCleaned_contactsAggregateType<T>>

    /**
     * Group by Cleaned_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cleaned_contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cleaned_contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cleaned_contactsGroupByArgs['orderBy'] }
        : { orderBy?: cleaned_contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cleaned_contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaned_contactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cleaned_contacts model
   */
  readonly fields: cleaned_contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cleaned_contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cleaned_contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cleaned_contacts model
   */ 
  interface cleaned_contactsFieldRefs {
    readonly phone: FieldRef<"cleaned_contacts", 'String'>
    readonly first_name: FieldRef<"cleaned_contacts", 'String'>
    readonly full_name: FieldRef<"cleaned_contacts", 'String'>
    readonly push_name: FieldRef<"cleaned_contacts", 'String'>
    readonly business_name: FieldRef<"cleaned_contacts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cleaned_contacts findUnique
   */
  export type cleaned_contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * Filter, which cleaned_contacts to fetch.
     */
    where: cleaned_contactsWhereUniqueInput
  }

  /**
   * cleaned_contacts findUniqueOrThrow
   */
  export type cleaned_contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * Filter, which cleaned_contacts to fetch.
     */
    where: cleaned_contactsWhereUniqueInput
  }

  /**
   * cleaned_contacts findFirst
   */
  export type cleaned_contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * Filter, which cleaned_contacts to fetch.
     */
    where?: cleaned_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleaned_contacts to fetch.
     */
    orderBy?: cleaned_contactsOrderByWithRelationInput | cleaned_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cleaned_contacts.
     */
    cursor?: cleaned_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleaned_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleaned_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cleaned_contacts.
     */
    distinct?: Cleaned_contactsScalarFieldEnum | Cleaned_contactsScalarFieldEnum[]
  }

  /**
   * cleaned_contacts findFirstOrThrow
   */
  export type cleaned_contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * Filter, which cleaned_contacts to fetch.
     */
    where?: cleaned_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleaned_contacts to fetch.
     */
    orderBy?: cleaned_contactsOrderByWithRelationInput | cleaned_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cleaned_contacts.
     */
    cursor?: cleaned_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleaned_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleaned_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cleaned_contacts.
     */
    distinct?: Cleaned_contactsScalarFieldEnum | Cleaned_contactsScalarFieldEnum[]
  }

  /**
   * cleaned_contacts findMany
   */
  export type cleaned_contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * Filter, which cleaned_contacts to fetch.
     */
    where?: cleaned_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cleaned_contacts to fetch.
     */
    orderBy?: cleaned_contactsOrderByWithRelationInput | cleaned_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cleaned_contacts.
     */
    cursor?: cleaned_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cleaned_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cleaned_contacts.
     */
    skip?: number
    distinct?: Cleaned_contactsScalarFieldEnum | Cleaned_contactsScalarFieldEnum[]
  }

  /**
   * cleaned_contacts create
   */
  export type cleaned_contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * The data needed to create a cleaned_contacts.
     */
    data: XOR<cleaned_contactsCreateInput, cleaned_contactsUncheckedCreateInput>
  }

  /**
   * cleaned_contacts createMany
   */
  export type cleaned_contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cleaned_contacts.
     */
    data: cleaned_contactsCreateManyInput | cleaned_contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cleaned_contacts createManyAndReturn
   */
  export type cleaned_contactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * The data used to create many cleaned_contacts.
     */
    data: cleaned_contactsCreateManyInput | cleaned_contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cleaned_contacts update
   */
  export type cleaned_contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * The data needed to update a cleaned_contacts.
     */
    data: XOR<cleaned_contactsUpdateInput, cleaned_contactsUncheckedUpdateInput>
    /**
     * Choose, which cleaned_contacts to update.
     */
    where: cleaned_contactsWhereUniqueInput
  }

  /**
   * cleaned_contacts updateMany
   */
  export type cleaned_contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cleaned_contacts.
     */
    data: XOR<cleaned_contactsUpdateManyMutationInput, cleaned_contactsUncheckedUpdateManyInput>
    /**
     * Filter which cleaned_contacts to update
     */
    where?: cleaned_contactsWhereInput
  }

  /**
   * cleaned_contacts updateManyAndReturn
   */
  export type cleaned_contactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * The data used to update cleaned_contacts.
     */
    data: XOR<cleaned_contactsUpdateManyMutationInput, cleaned_contactsUncheckedUpdateManyInput>
    /**
     * Filter which cleaned_contacts to update
     */
    where?: cleaned_contactsWhereInput
  }

  /**
   * cleaned_contacts upsert
   */
  export type cleaned_contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * The filter to search for the cleaned_contacts to update in case it exists.
     */
    where: cleaned_contactsWhereUniqueInput
    /**
     * In case the cleaned_contacts found by the `where` argument doesn't exist, create a new cleaned_contacts with this data.
     */
    create: XOR<cleaned_contactsCreateInput, cleaned_contactsUncheckedCreateInput>
    /**
     * In case the cleaned_contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cleaned_contactsUpdateInput, cleaned_contactsUncheckedUpdateInput>
  }

  /**
   * cleaned_contacts delete
   */
  export type cleaned_contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
    /**
     * Filter which cleaned_contacts to delete.
     */
    where: cleaned_contactsWhereUniqueInput
  }

  /**
   * cleaned_contacts deleteMany
   */
  export type cleaned_contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cleaned_contacts to delete
     */
    where?: cleaned_contactsWhereInput
  }

  /**
   * cleaned_contacts without action
   */
  export type cleaned_contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cleaned_contacts
     */
    select?: cleaned_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cleaned_contacts
     */
    omit?: cleaned_contactsOmit<ExtArgs> | null
  }


  /**
   * Model contacts
   */

  export type AggregateContacts = {
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  export type ContactsAvgAggregateOutputType = {
    unReadCount: number | null
  }

  export type ContactsSumAggregateOutputType = {
    unReadCount: number | null
  }

  export type ContactsMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    lastMessage: string | null
    lastMessageTime: Date | null
    unReadCount: number | null
    isTyping: boolean | null
    isOnline: boolean | null
    image: string | null
    lastSeen: Date | null
    chatId: string | null
    contactId: string | null
    userId: string | null
  }

  export type ContactsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    lastMessage: string | null
    lastMessageTime: Date | null
    unReadCount: number | null
    isTyping: boolean | null
    isOnline: boolean | null
    image: string | null
    lastSeen: Date | null
    chatId: string | null
    contactId: string | null
    userId: string | null
  }

  export type ContactsCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    address: number
    city: number
    state: number
    zip: number
    country: number
    lastMessage: number
    lastMessageTime: number
    unReadCount: number
    isTyping: number
    isOnline: number
    image: number
    lastSeen: number
    chatId: number
    contactId: number
    userId: number
    tags: number
    _all: number
  }


  export type ContactsAvgAggregateInputType = {
    unReadCount?: true
  }

  export type ContactsSumAggregateInputType = {
    unReadCount?: true
  }

  export type ContactsMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    lastMessage?: true
    lastMessageTime?: true
    unReadCount?: true
    isTyping?: true
    isOnline?: true
    image?: true
    lastSeen?: true
    chatId?: true
    contactId?: true
    userId?: true
  }

  export type ContactsMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    lastMessage?: true
    lastMessageTime?: true
    unReadCount?: true
    isTyping?: true
    isOnline?: true
    image?: true
    lastSeen?: true
    chatId?: true
    contactId?: true
    userId?: true
  }

  export type ContactsCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    address?: true
    city?: true
    state?: true
    zip?: true
    country?: true
    lastMessage?: true
    lastMessageTime?: true
    unReadCount?: true
    isTyping?: true
    isOnline?: true
    image?: true
    lastSeen?: true
    chatId?: true
    contactId?: true
    userId?: true
    tags?: true
    _all?: true
  }

  export type ContactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to aggregate.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contacts
    **/
    _count?: true | ContactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactsMaxAggregateInputType
  }

  export type GetContactsAggregateType<T extends ContactsAggregateArgs> = {
        [P in keyof T & keyof AggregateContacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContacts[P]>
      : GetScalarType<T[P], AggregateContacts[P]>
  }




  export type contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactsWhereInput
    orderBy?: contactsOrderByWithAggregationInput | contactsOrderByWithAggregationInput[]
    by: ContactsScalarFieldEnum[] | ContactsScalarFieldEnum
    having?: contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactsCountAggregateInputType | true
    _avg?: ContactsAvgAggregateInputType
    _sum?: ContactsSumAggregateInputType
    _min?: ContactsMinAggregateInputType
    _max?: ContactsMaxAggregateInputType
  }

  export type ContactsGroupByOutputType = {
    id: string
    name: string
    phone: string | null
    email: string | null
    address: string | null
    city: string | null
    state: string | null
    zip: string | null
    country: string | null
    lastMessage: string | null
    lastMessageTime: Date | null
    unReadCount: number | null
    isTyping: boolean | null
    isOnline: boolean | null
    image: string | null
    lastSeen: Date | null
    chatId: string | null
    contactId: string | null
    userId: string | null
    tags: JsonValue | null
    _count: ContactsCountAggregateOutputType | null
    _avg: ContactsAvgAggregateOutputType | null
    _sum: ContactsSumAggregateOutputType | null
    _min: ContactsMinAggregateOutputType | null
    _max: ContactsMaxAggregateOutputType | null
  }

  type GetContactsGroupByPayload<T extends contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactsGroupByOutputType[P]>
        }
      >
    >


  export type contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isTyping?: boolean
    isOnline?: boolean
    image?: boolean
    lastSeen?: boolean
    chatId?: boolean
    contactId?: boolean
    userId?: boolean
    tags?: boolean
    chatparticipants?: boolean | contacts$chatparticipantsArgs<ExtArgs>
    _count?: boolean | ContactsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isTyping?: boolean
    isOnline?: boolean
    image?: boolean
    lastSeen?: boolean
    chatId?: boolean
    contactId?: boolean
    userId?: boolean
    tags?: boolean
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isTyping?: boolean
    isOnline?: boolean
    image?: boolean
    lastSeen?: boolean
    chatId?: boolean
    contactId?: boolean
    userId?: boolean
    tags?: boolean
  }, ExtArgs["result"]["contacts"]>

  export type contactsSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    address?: boolean
    city?: boolean
    state?: boolean
    zip?: boolean
    country?: boolean
    lastMessage?: boolean
    lastMessageTime?: boolean
    unReadCount?: boolean
    isTyping?: boolean
    isOnline?: boolean
    image?: boolean
    lastSeen?: boolean
    chatId?: boolean
    contactId?: boolean
    userId?: boolean
    tags?: boolean
  }

  export type contactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "address" | "city" | "state" | "zip" | "country" | "lastMessage" | "lastMessageTime" | "unReadCount" | "isTyping" | "isOnline" | "image" | "lastSeen" | "chatId" | "contactId" | "userId" | "tags", ExtArgs["result"]["contacts"]>
  export type contactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chatparticipants?: boolean | contacts$chatparticipantsArgs<ExtArgs>
    _count?: boolean | ContactsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type contactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type contactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contacts"
    objects: {
      chatparticipants: Prisma.$chatparticipantsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      phone: string | null
      email: string | null
      address: string | null
      city: string | null
      state: string | null
      zip: string | null
      country: string | null
      lastMessage: string | null
      lastMessageTime: Date | null
      unReadCount: number | null
      isTyping: boolean | null
      isOnline: boolean | null
      image: string | null
      lastSeen: Date | null
      chatId: string | null
      contactId: string | null
      userId: string | null
      tags: Prisma.JsonValue | null
    }, ExtArgs["result"]["contacts"]>
    composites: {}
  }

  type contactsGetPayload<S extends boolean | null | undefined | contactsDefaultArgs> = $Result.GetResult<Prisma.$contactsPayload, S>

  type contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<contactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactsCountAggregateInputType | true
    }

  export interface contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contacts'], meta: { name: 'contacts' } }
    /**
     * Find zero or one Contacts that matches the filter.
     * @param {contactsFindUniqueArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactsFindUniqueArgs>(args: SelectSubset<T, contactsFindUniqueArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {contactsFindUniqueOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactsFindUniqueOrThrowArgs>(args: SelectSubset<T, contactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactsFindFirstArgs>(args?: SelectSubset<T, contactsFindFirstArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindFirstOrThrowArgs} args - Arguments to find a Contacts
     * @example
     * // Get one Contacts
     * const contacts = await prisma.contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactsFindFirstOrThrowArgs>(args?: SelectSubset<T, contactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contacts.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contacts.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactsWithIdOnly = await prisma.contacts.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactsFindManyArgs>(args?: SelectSubset<T, contactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Contacts.
     * @param {contactsCreateArgs} args - Arguments to create a Contacts.
     * @example
     * // Create one Contacts
     * const Contacts = await prisma.contacts.create({
     *   data: {
     *     // ... data to create a Contacts
     *   }
     * })
     * 
     */
    create<T extends contactsCreateArgs>(args: SelectSubset<T, contactsCreateArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Contacts.
     * @param {contactsCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactsCreateManyArgs>(args?: SelectSubset<T, contactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {contactsCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contacts = await prisma.contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends contactsCreateManyAndReturnArgs>(args?: SelectSubset<T, contactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Contacts.
     * @param {contactsDeleteArgs} args - Arguments to delete one Contacts.
     * @example
     * // Delete one Contacts
     * const Contacts = await prisma.contacts.delete({
     *   where: {
     *     // ... filter to delete one Contacts
     *   }
     * })
     * 
     */
    delete<T extends contactsDeleteArgs>(args: SelectSubset<T, contactsDeleteArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Contacts.
     * @param {contactsUpdateArgs} args - Arguments to update one Contacts.
     * @example
     * // Update one Contacts
     * const contacts = await prisma.contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactsUpdateArgs>(args: SelectSubset<T, contactsUpdateArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Contacts.
     * @param {contactsDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactsDeleteManyArgs>(args?: SelectSubset<T, contactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactsUpdateManyArgs>(args: SelectSubset<T, contactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {contactsUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contacts = await prisma.contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactsWithIdOnly = await prisma.contacts.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends contactsUpdateManyAndReturnArgs>(args: SelectSubset<T, contactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Contacts.
     * @param {contactsUpsertArgs} args - Arguments to update or create a Contacts.
     * @example
     * // Update or create a Contacts
     * const contacts = await prisma.contacts.upsert({
     *   create: {
     *     // ... data to create a Contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contacts we want to update
     *   }
     * })
     */
    upsert<T extends contactsUpsertArgs>(args: SelectSubset<T, contactsUpsertArgs<ExtArgs>>): Prisma__contactsClient<$Result.GetResult<Prisma.$contactsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contacts.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends contactsCountArgs>(
      args?: Subset<T, contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactsAggregateArgs>(args: Subset<T, ContactsAggregateArgs>): Prisma.PrismaPromise<GetContactsAggregateType<T>>

    /**
     * Group by Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactsGroupByArgs['orderBy'] }
        : { orderBy?: contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contacts model
   */
  readonly fields: contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    chatparticipants<T extends contacts$chatparticipantsArgs<ExtArgs> = {}>(args?: Subset<T, contacts$chatparticipantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$chatparticipantsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contacts model
   */ 
  interface contactsFieldRefs {
    readonly id: FieldRef<"contacts", 'String'>
    readonly name: FieldRef<"contacts", 'String'>
    readonly phone: FieldRef<"contacts", 'String'>
    readonly email: FieldRef<"contacts", 'String'>
    readonly address: FieldRef<"contacts", 'String'>
    readonly city: FieldRef<"contacts", 'String'>
    readonly state: FieldRef<"contacts", 'String'>
    readonly zip: FieldRef<"contacts", 'String'>
    readonly country: FieldRef<"contacts", 'String'>
    readonly lastMessage: FieldRef<"contacts", 'String'>
    readonly lastMessageTime: FieldRef<"contacts", 'DateTime'>
    readonly unReadCount: FieldRef<"contacts", 'Int'>
    readonly isTyping: FieldRef<"contacts", 'Boolean'>
    readonly isOnline: FieldRef<"contacts", 'Boolean'>
    readonly image: FieldRef<"contacts", 'String'>
    readonly lastSeen: FieldRef<"contacts", 'DateTime'>
    readonly chatId: FieldRef<"contacts", 'String'>
    readonly contactId: FieldRef<"contacts", 'String'>
    readonly userId: FieldRef<"contacts", 'String'>
    readonly tags: FieldRef<"contacts", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * contacts findUnique
   */
  export type contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts findUniqueOrThrow
   */
  export type contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts findFirst
   */
  export type contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts findFirstOrThrow
   */
  export type contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contacts.
     */
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts findMany
   */
  export type contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter, which contacts to fetch.
     */
    where?: contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contacts to fetch.
     */
    orderBy?: contactsOrderByWithRelationInput | contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contacts.
     */
    cursor?: contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contacts.
     */
    skip?: number
    distinct?: ContactsScalarFieldEnum | ContactsScalarFieldEnum[]
  }

  /**
   * contacts create
   */
  export type contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to create a contacts.
     */
    data: XOR<contactsCreateInput, contactsUncheckedCreateInput>
  }

  /**
   * contacts createMany
   */
  export type contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contacts createManyAndReturn
   */
  export type contactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * The data used to create many contacts.
     */
    data: contactsCreateManyInput | contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * contacts update
   */
  export type contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The data needed to update a contacts.
     */
    data: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
    /**
     * Choose, which contacts to update.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts updateMany
   */
  export type contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
  }

  /**
   * contacts updateManyAndReturn
   */
  export type contactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * The data used to update contacts.
     */
    data: XOR<contactsUpdateManyMutationInput, contactsUncheckedUpdateManyInput>
    /**
     * Filter which contacts to update
     */
    where?: contactsWhereInput
  }

  /**
   * contacts upsert
   */
  export type contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * The filter to search for the contacts to update in case it exists.
     */
    where: contactsWhereUniqueInput
    /**
     * In case the contacts found by the `where` argument doesn't exist, create a new contacts with this data.
     */
    create: XOR<contactsCreateInput, contactsUncheckedCreateInput>
    /**
     * In case the contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactsUpdateInput, contactsUncheckedUpdateInput>
  }

  /**
   * contacts delete
   */
  export type contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
    /**
     * Filter which contacts to delete.
     */
    where: contactsWhereUniqueInput
  }

  /**
   * contacts deleteMany
   */
  export type contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contacts to delete
     */
    where?: contactsWhereInput
  }

  /**
   * contacts.chatparticipants
   */
  export type contacts$chatparticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chatparticipants
     */
    select?: chatparticipantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chatparticipants
     */
    omit?: chatparticipantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatparticipantsInclude<ExtArgs> | null
    where?: chatparticipantsWhereInput
    orderBy?: chatparticipantsOrderByWithRelationInput | chatparticipantsOrderByWithRelationInput[]
    cursor?: chatparticipantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatparticipantsScalarFieldEnum | ChatparticipantsScalarFieldEnum[]
  }

  /**
   * contacts without action
   */
  export type contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contacts
     */
    select?: contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the contacts
     */
    omit?: contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: contactsInclude<ExtArgs> | null
  }


  /**
   * Model conversations
   */

  export type AggregateConversations = {
    _count: ConversationsCountAggregateOutputType | null
    _avg: ConversationsAvgAggregateOutputType | null
    _sum: ConversationsSumAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  export type ConversationsAvgAggregateOutputType = {
    id: number | null
  }

  export type ConversationsSumAggregateOutputType = {
    id: number | null
  }

  export type ConversationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    is_group: boolean | null
    created_at: Date | null
  }

  export type ConversationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    is_group: boolean | null
    created_at: Date | null
  }

  export type ConversationsCountAggregateOutputType = {
    id: number
    name: number
    is_group: number
    created_at: number
    _all: number
  }


  export type ConversationsAvgAggregateInputType = {
    id?: true
  }

  export type ConversationsSumAggregateInputType = {
    id?: true
  }

  export type ConversationsMinAggregateInputType = {
    id?: true
    name?: true
    is_group?: true
    created_at?: true
  }

  export type ConversationsMaxAggregateInputType = {
    id?: true
    name?: true
    is_group?: true
    created_at?: true
  }

  export type ConversationsCountAggregateInputType = {
    id?: true
    name?: true
    is_group?: true
    created_at?: true
    _all?: true
  }

  export type ConversationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to aggregate.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned conversations
    **/
    _count?: true | ConversationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConversationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConversationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationsMaxAggregateInputType
  }

  export type GetConversationsAggregateType<T extends ConversationsAggregateArgs> = {
        [P in keyof T & keyof AggregateConversations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversations[P]>
      : GetScalarType<T[P], AggregateConversations[P]>
  }




  export type conversationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: conversationsWhereInput
    orderBy?: conversationsOrderByWithAggregationInput | conversationsOrderByWithAggregationInput[]
    by: ConversationsScalarFieldEnum[] | ConversationsScalarFieldEnum
    having?: conversationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationsCountAggregateInputType | true
    _avg?: ConversationsAvgAggregateInputType
    _sum?: ConversationsSumAggregateInputType
    _min?: ConversationsMinAggregateInputType
    _max?: ConversationsMaxAggregateInputType
  }

  export type ConversationsGroupByOutputType = {
    id: number
    name: string | null
    is_group: boolean | null
    created_at: Date | null
    _count: ConversationsCountAggregateOutputType | null
    _avg: ConversationsAvgAggregateOutputType | null
    _sum: ConversationsSumAggregateOutputType | null
    _min: ConversationsMinAggregateOutputType | null
    _max: ConversationsMaxAggregateOutputType | null
  }

  type GetConversationsGroupByPayload<T extends conversationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationsGroupByOutputType[P]>
        }
      >
    >


  export type conversationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_group?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_group?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    is_group?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["conversations"]>

  export type conversationsSelectScalar = {
    id?: boolean
    name?: boolean
    is_group?: boolean
    created_at?: boolean
  }

  export type conversationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "is_group" | "created_at", ExtArgs["result"]["conversations"]>

  export type $conversationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "conversations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      is_group: boolean | null
      created_at: Date | null
    }, ExtArgs["result"]["conversations"]>
    composites: {}
  }

  type conversationsGetPayload<S extends boolean | null | undefined | conversationsDefaultArgs> = $Result.GetResult<Prisma.$conversationsPayload, S>

  type conversationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<conversationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationsCountAggregateInputType | true
    }

  export interface conversationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['conversations'], meta: { name: 'conversations' } }
    /**
     * Find zero or one Conversations that matches the filter.
     * @param {conversationsFindUniqueArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends conversationsFindUniqueArgs>(args: SelectSubset<T, conversationsFindUniqueArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Conversations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {conversationsFindUniqueOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends conversationsFindUniqueOrThrowArgs>(args: SelectSubset<T, conversationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends conversationsFindFirstArgs>(args?: SelectSubset<T, conversationsFindFirstArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Conversations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindFirstOrThrowArgs} args - Arguments to find a Conversations
     * @example
     * // Get one Conversations
     * const conversations = await prisma.conversations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends conversationsFindFirstOrThrowArgs>(args?: SelectSubset<T, conversationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversations.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationsWithIdOnly = await prisma.conversations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends conversationsFindManyArgs>(args?: SelectSubset<T, conversationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Conversations.
     * @param {conversationsCreateArgs} args - Arguments to create a Conversations.
     * @example
     * // Create one Conversations
     * const Conversations = await prisma.conversations.create({
     *   data: {
     *     // ... data to create a Conversations
     *   }
     * })
     * 
     */
    create<T extends conversationsCreateArgs>(args: SelectSubset<T, conversationsCreateArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Conversations.
     * @param {conversationsCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversations = await prisma.conversations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends conversationsCreateManyArgs>(args?: SelectSubset<T, conversationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {conversationsCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversations = await prisma.conversations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationsWithIdOnly = await prisma.conversations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends conversationsCreateManyAndReturnArgs>(args?: SelectSubset<T, conversationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Conversations.
     * @param {conversationsDeleteArgs} args - Arguments to delete one Conversations.
     * @example
     * // Delete one Conversations
     * const Conversations = await prisma.conversations.delete({
     *   where: {
     *     // ... filter to delete one Conversations
     *   }
     * })
     * 
     */
    delete<T extends conversationsDeleteArgs>(args: SelectSubset<T, conversationsDeleteArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Conversations.
     * @param {conversationsUpdateArgs} args - Arguments to update one Conversations.
     * @example
     * // Update one Conversations
     * const conversations = await prisma.conversations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends conversationsUpdateArgs>(args: SelectSubset<T, conversationsUpdateArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Conversations.
     * @param {conversationsDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends conversationsDeleteManyArgs>(args?: SelectSubset<T, conversationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversations = await prisma.conversations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends conversationsUpdateManyArgs>(args: SelectSubset<T, conversationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {conversationsUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversations = await prisma.conversations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationsWithIdOnly = await prisma.conversations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends conversationsUpdateManyAndReturnArgs>(args: SelectSubset<T, conversationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Conversations.
     * @param {conversationsUpsertArgs} args - Arguments to update or create a Conversations.
     * @example
     * // Update or create a Conversations
     * const conversations = await prisma.conversations.upsert({
     *   create: {
     *     // ... data to create a Conversations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversations we want to update
     *   }
     * })
     */
    upsert<T extends conversationsUpsertArgs>(args: SelectSubset<T, conversationsUpsertArgs<ExtArgs>>): Prisma__conversationsClient<$Result.GetResult<Prisma.$conversationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversations.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends conversationsCountArgs>(
      args?: Subset<T, conversationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationsAggregateArgs>(args: Subset<T, ConversationsAggregateArgs>): Prisma.PrismaPromise<GetConversationsAggregateType<T>>

    /**
     * Group by Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {conversationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends conversationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: conversationsGroupByArgs['orderBy'] }
        : { orderBy?: conversationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, conversationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the conversations model
   */
  readonly fields: conversationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for conversations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__conversationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the conversations model
   */ 
  interface conversationsFieldRefs {
    readonly id: FieldRef<"conversations", 'Int'>
    readonly name: FieldRef<"conversations", 'String'>
    readonly is_group: FieldRef<"conversations", 'Boolean'>
    readonly created_at: FieldRef<"conversations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * conversations findUnique
   */
  export type conversationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations findUniqueOrThrow
   */
  export type conversationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations findFirst
   */
  export type conversationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations findFirstOrThrow
   */
  export type conversationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of conversations.
     */
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations findMany
   */
  export type conversationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * Filter, which conversations to fetch.
     */
    where?: conversationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of conversations to fetch.
     */
    orderBy?: conversationsOrderByWithRelationInput | conversationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing conversations.
     */
    cursor?: conversationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` conversations.
     */
    skip?: number
    distinct?: ConversationsScalarFieldEnum | ConversationsScalarFieldEnum[]
  }

  /**
   * conversations create
   */
  export type conversationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * The data needed to create a conversations.
     */
    data?: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
  }

  /**
   * conversations createMany
   */
  export type conversationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversations createManyAndReturn
   */
  export type conversationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * The data used to create many conversations.
     */
    data: conversationsCreateManyInput | conversationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * conversations update
   */
  export type conversationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * The data needed to update a conversations.
     */
    data: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
    /**
     * Choose, which conversations to update.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations updateMany
   */
  export type conversationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations updateManyAndReturn
   */
  export type conversationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * The data used to update conversations.
     */
    data: XOR<conversationsUpdateManyMutationInput, conversationsUncheckedUpdateManyInput>
    /**
     * Filter which conversations to update
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations upsert
   */
  export type conversationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * The filter to search for the conversations to update in case it exists.
     */
    where: conversationsWhereUniqueInput
    /**
     * In case the conversations found by the `where` argument doesn't exist, create a new conversations with this data.
     */
    create: XOR<conversationsCreateInput, conversationsUncheckedCreateInput>
    /**
     * In case the conversations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<conversationsUpdateInput, conversationsUncheckedUpdateInput>
  }

  /**
   * conversations delete
   */
  export type conversationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
    /**
     * Filter which conversations to delete.
     */
    where: conversationsWhereUniqueInput
  }

  /**
   * conversations deleteMany
   */
  export type conversationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which conversations to delete
     */
    where?: conversationsWhereInput
  }

  /**
   * conversations without action
   */
  export type conversationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the conversations
     */
    select?: conversationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the conversations
     */
    omit?: conversationsOmit<ExtArgs> | null
  }


  /**
   * Model groups
   */

  export type AggregateGroups = {
    _count: GroupsCountAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  export type GroupsMinAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GroupsMaxAggregateOutputType = {
    id: string | null
    name: string | null
  }

  export type GroupsCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type GroupsMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type GroupsMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type GroupsCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type GroupsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to aggregate.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned groups
    **/
    _count?: true | GroupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GroupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GroupsMaxAggregateInputType
  }

  export type GetGroupsAggregateType<T extends GroupsAggregateArgs> = {
        [P in keyof T & keyof AggregateGroups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGroups[P]>
      : GetScalarType<T[P], AggregateGroups[P]>
  }




  export type groupsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: groupsWhereInput
    orderBy?: groupsOrderByWithAggregationInput | groupsOrderByWithAggregationInput[]
    by: GroupsScalarFieldEnum[] | GroupsScalarFieldEnum
    having?: groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GroupsCountAggregateInputType | true
    _min?: GroupsMinAggregateInputType
    _max?: GroupsMaxAggregateInputType
  }

  export type GroupsGroupByOutputType = {
    id: string
    name: string | null
    _count: GroupsCountAggregateOutputType | null
    _min: GroupsMinAggregateOutputType | null
    _max: GroupsMaxAggregateOutputType | null
  }

  type GetGroupsGroupByPayload<T extends groupsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GroupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GroupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GroupsGroupByOutputType[P]>
            : GetScalarType<T[P], GroupsGroupByOutputType[P]>
        }
      >
    >


  export type groupsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["groups"]>

  export type groupsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["groups"]>

  export type groupsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
  }, ExtArgs["result"]["groups"]>

  export type groupsSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type groupsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name", ExtArgs["result"]["groups"]>

  export type $groupsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "groups"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
    }, ExtArgs["result"]["groups"]>
    composites: {}
  }

  type groupsGetPayload<S extends boolean | null | undefined | groupsDefaultArgs> = $Result.GetResult<Prisma.$groupsPayload, S>

  type groupsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<groupsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GroupsCountAggregateInputType | true
    }

  export interface groupsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['groups'], meta: { name: 'groups' } }
    /**
     * Find zero or one Groups that matches the filter.
     * @param {groupsFindUniqueArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends groupsFindUniqueArgs>(args: SelectSubset<T, groupsFindUniqueArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Groups that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {groupsFindUniqueOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends groupsFindUniqueOrThrowArgs>(args: SelectSubset<T, groupsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindFirstArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends groupsFindFirstArgs>(args?: SelectSubset<T, groupsFindFirstArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Groups that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindFirstOrThrowArgs} args - Arguments to find a Groups
     * @example
     * // Get one Groups
     * const groups = await prisma.groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends groupsFindFirstOrThrowArgs>(args?: SelectSubset<T, groupsFindFirstOrThrowArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Groups
     * const groups = await prisma.groups.findMany()
     * 
     * // Get first 10 Groups
     * const groups = await prisma.groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const groupsWithIdOnly = await prisma.groups.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends groupsFindManyArgs>(args?: SelectSubset<T, groupsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Groups.
     * @param {groupsCreateArgs} args - Arguments to create a Groups.
     * @example
     * // Create one Groups
     * const Groups = await prisma.groups.create({
     *   data: {
     *     // ... data to create a Groups
     *   }
     * })
     * 
     */
    create<T extends groupsCreateArgs>(args: SelectSubset<T, groupsCreateArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Groups.
     * @param {groupsCreateManyArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends groupsCreateManyArgs>(args?: SelectSubset<T, groupsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Groups and returns the data saved in the database.
     * @param {groupsCreateManyAndReturnArgs} args - Arguments to create many Groups.
     * @example
     * // Create many Groups
     * const groups = await prisma.groups.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Groups and only return the `id`
     * const groupsWithIdOnly = await prisma.groups.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends groupsCreateManyAndReturnArgs>(args?: SelectSubset<T, groupsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Groups.
     * @param {groupsDeleteArgs} args - Arguments to delete one Groups.
     * @example
     * // Delete one Groups
     * const Groups = await prisma.groups.delete({
     *   where: {
     *     // ... filter to delete one Groups
     *   }
     * })
     * 
     */
    delete<T extends groupsDeleteArgs>(args: SelectSubset<T, groupsDeleteArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Groups.
     * @param {groupsUpdateArgs} args - Arguments to update one Groups.
     * @example
     * // Update one Groups
     * const groups = await prisma.groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends groupsUpdateArgs>(args: SelectSubset<T, groupsUpdateArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Groups.
     * @param {groupsDeleteManyArgs} args - Arguments to filter Groups to delete.
     * @example
     * // Delete a few Groups
     * const { count } = await prisma.groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends groupsDeleteManyArgs>(args?: SelectSubset<T, groupsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends groupsUpdateManyArgs>(args: SelectSubset<T, groupsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Groups and returns the data updated in the database.
     * @param {groupsUpdateManyAndReturnArgs} args - Arguments to update many Groups.
     * @example
     * // Update many Groups
     * const groups = await prisma.groups.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Groups and only return the `id`
     * const groupsWithIdOnly = await prisma.groups.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends groupsUpdateManyAndReturnArgs>(args: SelectSubset<T, groupsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Groups.
     * @param {groupsUpsertArgs} args - Arguments to update or create a Groups.
     * @example
     * // Update or create a Groups
     * const groups = await prisma.groups.upsert({
     *   create: {
     *     // ... data to create a Groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Groups we want to update
     *   }
     * })
     */
    upsert<T extends groupsUpsertArgs>(args: SelectSubset<T, groupsUpsertArgs<ExtArgs>>): Prisma__groupsClient<$Result.GetResult<Prisma.$groupsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsCountArgs} args - Arguments to filter Groups to count.
     * @example
     * // Count the number of Groups
     * const count = await prisma.groups.count({
     *   where: {
     *     // ... the filter for the Groups we want to count
     *   }
     * })
    **/
    count<T extends groupsCountArgs>(
      args?: Subset<T, groupsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GroupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GroupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GroupsAggregateArgs>(args: Subset<T, GroupsAggregateArgs>): Prisma.PrismaPromise<GetGroupsAggregateType<T>>

    /**
     * Group by Groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: groupsGroupByArgs['orderBy'] }
        : { orderBy?: groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGroupsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the groups model
   */
  readonly fields: groupsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__groupsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the groups model
   */ 
  interface groupsFieldRefs {
    readonly id: FieldRef<"groups", 'String'>
    readonly name: FieldRef<"groups", 'String'>
  }
    

  // Custom InputTypes
  /**
   * groups findUnique
   */
  export type groupsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups findUniqueOrThrow
   */
  export type groupsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups findFirst
   */
  export type groupsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * groups findFirstOrThrow
   */
  export type groupsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of groups.
     */
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * groups findMany
   */
  export type groupsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * Filter, which groups to fetch.
     */
    where?: groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of groups to fetch.
     */
    orderBy?: groupsOrderByWithRelationInput | groupsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing groups.
     */
    cursor?: groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` groups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` groups.
     */
    skip?: number
    distinct?: GroupsScalarFieldEnum | GroupsScalarFieldEnum[]
  }

  /**
   * groups create
   */
  export type groupsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * The data needed to create a groups.
     */
    data: XOR<groupsCreateInput, groupsUncheckedCreateInput>
  }

  /**
   * groups createMany
   */
  export type groupsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many groups.
     */
    data: groupsCreateManyInput | groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groups createManyAndReturn
   */
  export type groupsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * The data used to create many groups.
     */
    data: groupsCreateManyInput | groupsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * groups update
   */
  export type groupsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * The data needed to update a groups.
     */
    data: XOR<groupsUpdateInput, groupsUncheckedUpdateInput>
    /**
     * Choose, which groups to update.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups updateMany
   */
  export type groupsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update groups.
     */
    data: XOR<groupsUpdateManyMutationInput, groupsUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupsWhereInput
  }

  /**
   * groups updateManyAndReturn
   */
  export type groupsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * The data used to update groups.
     */
    data: XOR<groupsUpdateManyMutationInput, groupsUncheckedUpdateManyInput>
    /**
     * Filter which groups to update
     */
    where?: groupsWhereInput
  }

  /**
   * groups upsert
   */
  export type groupsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * The filter to search for the groups to update in case it exists.
     */
    where: groupsWhereUniqueInput
    /**
     * In case the groups found by the `where` argument doesn't exist, create a new groups with this data.
     */
    create: XOR<groupsCreateInput, groupsUncheckedCreateInput>
    /**
     * In case the groups was found with the provided `where` argument, update it with this data.
     */
    update: XOR<groupsUpdateInput, groupsUncheckedUpdateInput>
  }

  /**
   * groups delete
   */
  export type groupsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
    /**
     * Filter which groups to delete.
     */
    where: groupsWhereUniqueInput
  }

  /**
   * groups deleteMany
   */
  export type groupsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which groups to delete
     */
    where?: groupsWhereInput
  }

  /**
   * groups without action
   */
  export type groupsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the groups
     */
    select?: groupsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the groups
     */
    omit?: groupsOmit<ExtArgs> | null
  }


  /**
   * Model messageTemplates
   */

  export type AggregateMessageTemplates = {
    _count: MessageTemplatesCountAggregateOutputType | null
    _avg: MessageTemplatesAvgAggregateOutputType | null
    _sum: MessageTemplatesSumAggregateOutputType | null
    _min: MessageTemplatesMinAggregateOutputType | null
    _max: MessageTemplatesMaxAggregateOutputType | null
  }

  export type MessageTemplatesAvgAggregateOutputType = {
    id: number | null
  }

  export type MessageTemplatesSumAggregateOutputType = {
    id: number | null
  }

  export type MessageTemplatesMinAggregateOutputType = {
    id: number | null
    name: string | null
    content: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedat: Date | null
    imagePath: string | null
    mediaPath: string | null
  }

  export type MessageTemplatesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    content: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedat: Date | null
    imagePath: string | null
    mediaPath: string | null
  }

  export type MessageTemplatesCountAggregateOutputType = {
    id: number
    name: number
    content: number
    createdBy: number
    createdAt: number
    updatedat: number
    imagePath: number
    mediaPath: number
    _all: number
  }


  export type MessageTemplatesAvgAggregateInputType = {
    id?: true
  }

  export type MessageTemplatesSumAggregateInputType = {
    id?: true
  }

  export type MessageTemplatesMinAggregateInputType = {
    id?: true
    name?: true
    content?: true
    createdBy?: true
    createdAt?: true
    updatedat?: true
    imagePath?: true
    mediaPath?: true
  }

  export type MessageTemplatesMaxAggregateInputType = {
    id?: true
    name?: true
    content?: true
    createdBy?: true
    createdAt?: true
    updatedat?: true
    imagePath?: true
    mediaPath?: true
  }

  export type MessageTemplatesCountAggregateInputType = {
    id?: true
    name?: true
    content?: true
    createdBy?: true
    createdAt?: true
    updatedat?: true
    imagePath?: true
    mediaPath?: true
    _all?: true
  }

  export type MessageTemplatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messageTemplates to aggregate.
     */
    where?: messageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messageTemplates to fetch.
     */
    orderBy?: messageTemplatesOrderByWithRelationInput | messageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messageTemplates
    **/
    _count?: true | MessageTemplatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessageTemplatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessageTemplatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageTemplatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageTemplatesMaxAggregateInputType
  }

  export type GetMessageTemplatesAggregateType<T extends MessageTemplatesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageTemplates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageTemplates[P]>
      : GetScalarType<T[P], AggregateMessageTemplates[P]>
  }




  export type messageTemplatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messageTemplatesWhereInput
    orderBy?: messageTemplatesOrderByWithAggregationInput | messageTemplatesOrderByWithAggregationInput[]
    by: MessageTemplatesScalarFieldEnum[] | MessageTemplatesScalarFieldEnum
    having?: messageTemplatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageTemplatesCountAggregateInputType | true
    _avg?: MessageTemplatesAvgAggregateInputType
    _sum?: MessageTemplatesSumAggregateInputType
    _min?: MessageTemplatesMinAggregateInputType
    _max?: MessageTemplatesMaxAggregateInputType
  }

  export type MessageTemplatesGroupByOutputType = {
    id: number
    name: string
    content: string
    createdBy: string
    createdAt: Date | null
    updatedat: Date | null
    imagePath: string | null
    mediaPath: string | null
    _count: MessageTemplatesCountAggregateOutputType | null
    _avg: MessageTemplatesAvgAggregateOutputType | null
    _sum: MessageTemplatesSumAggregateOutputType | null
    _min: MessageTemplatesMinAggregateOutputType | null
    _max: MessageTemplatesMaxAggregateOutputType | null
  }

  type GetMessageTemplatesGroupByPayload<T extends messageTemplatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageTemplatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageTemplatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageTemplatesGroupByOutputType[P]>
            : GetScalarType<T[P], MessageTemplatesGroupByOutputType[P]>
        }
      >
    >


  export type messageTemplatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedat?: boolean
    imagePath?: boolean
    mediaPath?: boolean
  }, ExtArgs["result"]["messageTemplates"]>

  export type messageTemplatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedat?: boolean
    imagePath?: boolean
    mediaPath?: boolean
  }, ExtArgs["result"]["messageTemplates"]>

  export type messageTemplatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    content?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedat?: boolean
    imagePath?: boolean
    mediaPath?: boolean
  }, ExtArgs["result"]["messageTemplates"]>

  export type messageTemplatesSelectScalar = {
    id?: boolean
    name?: boolean
    content?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedat?: boolean
    imagePath?: boolean
    mediaPath?: boolean
  }

  export type messageTemplatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "content" | "createdBy" | "createdAt" | "updatedat" | "imagePath" | "mediaPath", ExtArgs["result"]["messageTemplates"]>

  export type $messageTemplatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messageTemplates"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      content: string
      createdBy: string
      createdAt: Date | null
      updatedat: Date | null
      imagePath: string | null
      mediaPath: string | null
    }, ExtArgs["result"]["messageTemplates"]>
    composites: {}
  }

  type messageTemplatesGetPayload<S extends boolean | null | undefined | messageTemplatesDefaultArgs> = $Result.GetResult<Prisma.$messageTemplatesPayload, S>

  type messageTemplatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messageTemplatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageTemplatesCountAggregateInputType | true
    }

  export interface messageTemplatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messageTemplates'], meta: { name: 'messageTemplates' } }
    /**
     * Find zero or one MessageTemplates that matches the filter.
     * @param {messageTemplatesFindUniqueArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messageTemplatesFindUniqueArgs>(args: SelectSubset<T, messageTemplatesFindUniqueArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one MessageTemplates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messageTemplatesFindUniqueOrThrowArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messageTemplatesFindUniqueOrThrowArgs>(args: SelectSubset<T, messageTemplatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageTemplatesFindFirstArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messageTemplatesFindFirstArgs>(args?: SelectSubset<T, messageTemplatesFindFirstArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first MessageTemplates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageTemplatesFindFirstOrThrowArgs} args - Arguments to find a MessageTemplates
     * @example
     * // Get one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messageTemplatesFindFirstOrThrowArgs>(args?: SelectSubset<T, messageTemplatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more MessageTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageTemplatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findMany()
     * 
     * // Get first 10 MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageTemplatesWithIdOnly = await prisma.messageTemplates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messageTemplatesFindManyArgs>(args?: SelectSubset<T, messageTemplatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a MessageTemplates.
     * @param {messageTemplatesCreateArgs} args - Arguments to create a MessageTemplates.
     * @example
     * // Create one MessageTemplates
     * const MessageTemplates = await prisma.messageTemplates.create({
     *   data: {
     *     // ... data to create a MessageTemplates
     *   }
     * })
     * 
     */
    create<T extends messageTemplatesCreateArgs>(args: SelectSubset<T, messageTemplatesCreateArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many MessageTemplates.
     * @param {messageTemplatesCreateManyArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messageTemplatesCreateManyArgs>(args?: SelectSubset<T, messageTemplatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageTemplates and returns the data saved in the database.
     * @param {messageTemplatesCreateManyAndReturnArgs} args - Arguments to create many MessageTemplates.
     * @example
     * // Create many MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageTemplates and only return the `id`
     * const messageTemplatesWithIdOnly = await prisma.messageTemplates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messageTemplatesCreateManyAndReturnArgs>(args?: SelectSubset<T, messageTemplatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a MessageTemplates.
     * @param {messageTemplatesDeleteArgs} args - Arguments to delete one MessageTemplates.
     * @example
     * // Delete one MessageTemplates
     * const MessageTemplates = await prisma.messageTemplates.delete({
     *   where: {
     *     // ... filter to delete one MessageTemplates
     *   }
     * })
     * 
     */
    delete<T extends messageTemplatesDeleteArgs>(args: SelectSubset<T, messageTemplatesDeleteArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one MessageTemplates.
     * @param {messageTemplatesUpdateArgs} args - Arguments to update one MessageTemplates.
     * @example
     * // Update one MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messageTemplatesUpdateArgs>(args: SelectSubset<T, messageTemplatesUpdateArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more MessageTemplates.
     * @param {messageTemplatesDeleteManyArgs} args - Arguments to filter MessageTemplates to delete.
     * @example
     * // Delete a few MessageTemplates
     * const { count } = await prisma.messageTemplates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messageTemplatesDeleteManyArgs>(args?: SelectSubset<T, messageTemplatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageTemplatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messageTemplatesUpdateManyArgs>(args: SelectSubset<T, messageTemplatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageTemplates and returns the data updated in the database.
     * @param {messageTemplatesUpdateManyAndReturnArgs} args - Arguments to update many MessageTemplates.
     * @example
     * // Update many MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageTemplates and only return the `id`
     * const messageTemplatesWithIdOnly = await prisma.messageTemplates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messageTemplatesUpdateManyAndReturnArgs>(args: SelectSubset<T, messageTemplatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one MessageTemplates.
     * @param {messageTemplatesUpsertArgs} args - Arguments to update or create a MessageTemplates.
     * @example
     * // Update or create a MessageTemplates
     * const messageTemplates = await prisma.messageTemplates.upsert({
     *   create: {
     *     // ... data to create a MessageTemplates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageTemplates we want to update
     *   }
     * })
     */
    upsert<T extends messageTemplatesUpsertArgs>(args: SelectSubset<T, messageTemplatesUpsertArgs<ExtArgs>>): Prisma__messageTemplatesClient<$Result.GetResult<Prisma.$messageTemplatesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageTemplatesCountArgs} args - Arguments to filter MessageTemplates to count.
     * @example
     * // Count the number of MessageTemplates
     * const count = await prisma.messageTemplates.count({
     *   where: {
     *     // ... the filter for the MessageTemplates we want to count
     *   }
     * })
    **/
    count<T extends messageTemplatesCountArgs>(
      args?: Subset<T, messageTemplatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageTemplatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageTemplatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageTemplatesAggregateArgs>(args: Subset<T, MessageTemplatesAggregateArgs>): Prisma.PrismaPromise<GetMessageTemplatesAggregateType<T>>

    /**
     * Group by MessageTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messageTemplatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messageTemplatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messageTemplatesGroupByArgs['orderBy'] }
        : { orderBy?: messageTemplatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messageTemplatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageTemplatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messageTemplates model
   */
  readonly fields: messageTemplatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messageTemplates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messageTemplatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messageTemplates model
   */ 
  interface messageTemplatesFieldRefs {
    readonly id: FieldRef<"messageTemplates", 'Int'>
    readonly name: FieldRef<"messageTemplates", 'String'>
    readonly content: FieldRef<"messageTemplates", 'String'>
    readonly createdBy: FieldRef<"messageTemplates", 'String'>
    readonly createdAt: FieldRef<"messageTemplates", 'DateTime'>
    readonly updatedat: FieldRef<"messageTemplates", 'DateTime'>
    readonly imagePath: FieldRef<"messageTemplates", 'String'>
    readonly mediaPath: FieldRef<"messageTemplates", 'String'>
  }
    

  // Custom InputTypes
  /**
   * messageTemplates findUnique
   */
  export type messageTemplatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * Filter, which messageTemplates to fetch.
     */
    where: messageTemplatesWhereUniqueInput
  }

  /**
   * messageTemplates findUniqueOrThrow
   */
  export type messageTemplatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * Filter, which messageTemplates to fetch.
     */
    where: messageTemplatesWhereUniqueInput
  }

  /**
   * messageTemplates findFirst
   */
  export type messageTemplatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * Filter, which messageTemplates to fetch.
     */
    where?: messageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messageTemplates to fetch.
     */
    orderBy?: messageTemplatesOrderByWithRelationInput | messageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messageTemplates.
     */
    cursor?: messageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messageTemplates.
     */
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * messageTemplates findFirstOrThrow
   */
  export type messageTemplatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * Filter, which messageTemplates to fetch.
     */
    where?: messageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messageTemplates to fetch.
     */
    orderBy?: messageTemplatesOrderByWithRelationInput | messageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messageTemplates.
     */
    cursor?: messageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messageTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messageTemplates.
     */
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * messageTemplates findMany
   */
  export type messageTemplatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * Filter, which messageTemplates to fetch.
     */
    where?: messageTemplatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messageTemplates to fetch.
     */
    orderBy?: messageTemplatesOrderByWithRelationInput | messageTemplatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messageTemplates.
     */
    cursor?: messageTemplatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messageTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messageTemplates.
     */
    skip?: number
    distinct?: MessageTemplatesScalarFieldEnum | MessageTemplatesScalarFieldEnum[]
  }

  /**
   * messageTemplates create
   */
  export type messageTemplatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * The data needed to create a messageTemplates.
     */
    data: XOR<messageTemplatesCreateInput, messageTemplatesUncheckedCreateInput>
  }

  /**
   * messageTemplates createMany
   */
  export type messageTemplatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messageTemplates.
     */
    data: messageTemplatesCreateManyInput | messageTemplatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messageTemplates createManyAndReturn
   */
  export type messageTemplatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * The data used to create many messageTemplates.
     */
    data: messageTemplatesCreateManyInput | messageTemplatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messageTemplates update
   */
  export type messageTemplatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * The data needed to update a messageTemplates.
     */
    data: XOR<messageTemplatesUpdateInput, messageTemplatesUncheckedUpdateInput>
    /**
     * Choose, which messageTemplates to update.
     */
    where: messageTemplatesWhereUniqueInput
  }

  /**
   * messageTemplates updateMany
   */
  export type messageTemplatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messageTemplates.
     */
    data: XOR<messageTemplatesUpdateManyMutationInput, messageTemplatesUncheckedUpdateManyInput>
    /**
     * Filter which messageTemplates to update
     */
    where?: messageTemplatesWhereInput
  }

  /**
   * messageTemplates updateManyAndReturn
   */
  export type messageTemplatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * The data used to update messageTemplates.
     */
    data: XOR<messageTemplatesUpdateManyMutationInput, messageTemplatesUncheckedUpdateManyInput>
    /**
     * Filter which messageTemplates to update
     */
    where?: messageTemplatesWhereInput
  }

  /**
   * messageTemplates upsert
   */
  export type messageTemplatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * The filter to search for the messageTemplates to update in case it exists.
     */
    where: messageTemplatesWhereUniqueInput
    /**
     * In case the messageTemplates found by the `where` argument doesn't exist, create a new messageTemplates with this data.
     */
    create: XOR<messageTemplatesCreateInput, messageTemplatesUncheckedCreateInput>
    /**
     * In case the messageTemplates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messageTemplatesUpdateInput, messageTemplatesUncheckedUpdateInput>
  }

  /**
   * messageTemplates delete
   */
  export type messageTemplatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
    /**
     * Filter which messageTemplates to delete.
     */
    where: messageTemplatesWhereUniqueInput
  }

  /**
   * messageTemplates deleteMany
   */
  export type messageTemplatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messageTemplates to delete
     */
    where?: messageTemplatesWhereInput
  }

  /**
   * messageTemplates without action
   */
  export type messageTemplatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messageTemplates
     */
    select?: messageTemplatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messageTemplates
     */
    omit?: messageTemplatesOmit<ExtArgs> | null
  }


  /**
   * Model message_history
   */

  export type AggregateMessage_history = {
    _count: Message_historyCountAggregateOutputType | null
    _avg: Message_historyAvgAggregateOutputType | null
    _sum: Message_historySumAggregateOutputType | null
    _min: Message_historyMinAggregateOutputType | null
    _max: Message_historyMaxAggregateOutputType | null
  }

  export type Message_historyAvgAggregateOutputType = {
    id: number | null
  }

  export type Message_historySumAggregateOutputType = {
    id: number | null
  }

  export type Message_historyMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    chat_jid: string | null
    sender_jid: string | null
    message_id: string | null
    timestamp: Date | null
    message_type: string | null
    text_content: string | null
    media_link: string | null
    quoted_message_id: string | null
    datajson: string | null
  }

  export type Message_historyMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    chat_jid: string | null
    sender_jid: string | null
    message_id: string | null
    timestamp: Date | null
    message_type: string | null
    text_content: string | null
    media_link: string | null
    quoted_message_id: string | null
    datajson: string | null
  }

  export type Message_historyCountAggregateOutputType = {
    id: number
    user_id: number
    chat_jid: number
    sender_jid: number
    message_id: number
    timestamp: number
    message_type: number
    text_content: number
    media_link: number
    quoted_message_id: number
    datajson: number
    _all: number
  }


  export type Message_historyAvgAggregateInputType = {
    id?: true
  }

  export type Message_historySumAggregateInputType = {
    id?: true
  }

  export type Message_historyMinAggregateInputType = {
    id?: true
    user_id?: true
    chat_jid?: true
    sender_jid?: true
    message_id?: true
    timestamp?: true
    message_type?: true
    text_content?: true
    media_link?: true
    quoted_message_id?: true
    datajson?: true
  }

  export type Message_historyMaxAggregateInputType = {
    id?: true
    user_id?: true
    chat_jid?: true
    sender_jid?: true
    message_id?: true
    timestamp?: true
    message_type?: true
    text_content?: true
    media_link?: true
    quoted_message_id?: true
    datajson?: true
  }

  export type Message_historyCountAggregateInputType = {
    id?: true
    user_id?: true
    chat_jid?: true
    sender_jid?: true
    message_id?: true
    timestamp?: true
    message_type?: true
    text_content?: true
    media_link?: true
    quoted_message_id?: true
    datajson?: true
    _all?: true
  }

  export type Message_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_history to aggregate.
     */
    where?: message_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_histories to fetch.
     */
    orderBy?: message_historyOrderByWithRelationInput | message_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: message_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned message_histories
    **/
    _count?: true | Message_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Message_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Message_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Message_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Message_historyMaxAggregateInputType
  }

  export type GetMessage_historyAggregateType<T extends Message_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage_history[P]>
      : GetScalarType<T[P], AggregateMessage_history[P]>
  }




  export type message_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_historyWhereInput
    orderBy?: message_historyOrderByWithAggregationInput | message_historyOrderByWithAggregationInput[]
    by: Message_historyScalarFieldEnum[] | Message_historyScalarFieldEnum
    having?: message_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Message_historyCountAggregateInputType | true
    _avg?: Message_historyAvgAggregateInputType
    _sum?: Message_historySumAggregateInputType
    _min?: Message_historyMinAggregateInputType
    _max?: Message_historyMaxAggregateInputType
  }

  export type Message_historyGroupByOutputType = {
    id: number
    user_id: string
    chat_jid: string
    sender_jid: string
    message_id: string
    timestamp: Date
    message_type: string
    text_content: string | null
    media_link: string | null
    quoted_message_id: string | null
    datajson: string | null
    _count: Message_historyCountAggregateOutputType | null
    _avg: Message_historyAvgAggregateOutputType | null
    _sum: Message_historySumAggregateOutputType | null
    _min: Message_historyMinAggregateOutputType | null
    _max: Message_historyMaxAggregateOutputType | null
  }

  type GetMessage_historyGroupByPayload<T extends message_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Message_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Message_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Message_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Message_historyGroupByOutputType[P]>
        }
      >
    >


  export type message_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    timestamp?: boolean
    message_type?: boolean
    text_content?: boolean
    media_link?: boolean
    quoted_message_id?: boolean
    datajson?: boolean
  }, ExtArgs["result"]["message_history"]>

  export type message_historySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    timestamp?: boolean
    message_type?: boolean
    text_content?: boolean
    media_link?: boolean
    quoted_message_id?: boolean
    datajson?: boolean
  }, ExtArgs["result"]["message_history"]>

  export type message_historySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    timestamp?: boolean
    message_type?: boolean
    text_content?: boolean
    media_link?: boolean
    quoted_message_id?: boolean
    datajson?: boolean
  }, ExtArgs["result"]["message_history"]>

  export type message_historySelectScalar = {
    id?: boolean
    user_id?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    timestamp?: boolean
    message_type?: boolean
    text_content?: boolean
    media_link?: boolean
    quoted_message_id?: boolean
    datajson?: boolean
  }

  export type message_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "chat_jid" | "sender_jid" | "message_id" | "timestamp" | "message_type" | "text_content" | "media_link" | "quoted_message_id" | "datajson", ExtArgs["result"]["message_history"]>

  export type $message_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message_history"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      chat_jid: string
      sender_jid: string
      message_id: string
      timestamp: Date
      message_type: string
      text_content: string | null
      media_link: string | null
      quoted_message_id: string | null
      datajson: string | null
    }, ExtArgs["result"]["message_history"]>
    composites: {}
  }

  type message_historyGetPayload<S extends boolean | null | undefined | message_historyDefaultArgs> = $Result.GetResult<Prisma.$message_historyPayload, S>

  type message_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<message_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Message_historyCountAggregateInputType | true
    }

  export interface message_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message_history'], meta: { name: 'message_history' } }
    /**
     * Find zero or one Message_history that matches the filter.
     * @param {message_historyFindUniqueArgs} args - Arguments to find a Message_history
     * @example
     * // Get one Message_history
     * const message_history = await prisma.message_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends message_historyFindUniqueArgs>(args: SelectSubset<T, message_historyFindUniqueArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Message_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {message_historyFindUniqueOrThrowArgs} args - Arguments to find a Message_history
     * @example
     * // Get one Message_history
     * const message_history = await prisma.message_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends message_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, message_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Message_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_historyFindFirstArgs} args - Arguments to find a Message_history
     * @example
     * // Get one Message_history
     * const message_history = await prisma.message_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends message_historyFindFirstArgs>(args?: SelectSubset<T, message_historyFindFirstArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Message_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_historyFindFirstOrThrowArgs} args - Arguments to find a Message_history
     * @example
     * // Get one Message_history
     * const message_history = await prisma.message_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends message_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, message_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Message_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Message_histories
     * const message_histories = await prisma.message_history.findMany()
     * 
     * // Get first 10 Message_histories
     * const message_histories = await prisma.message_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const message_historyWithIdOnly = await prisma.message_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends message_historyFindManyArgs>(args?: SelectSubset<T, message_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Message_history.
     * @param {message_historyCreateArgs} args - Arguments to create a Message_history.
     * @example
     * // Create one Message_history
     * const Message_history = await prisma.message_history.create({
     *   data: {
     *     // ... data to create a Message_history
     *   }
     * })
     * 
     */
    create<T extends message_historyCreateArgs>(args: SelectSubset<T, message_historyCreateArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Message_histories.
     * @param {message_historyCreateManyArgs} args - Arguments to create many Message_histories.
     * @example
     * // Create many Message_histories
     * const message_history = await prisma.message_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends message_historyCreateManyArgs>(args?: SelectSubset<T, message_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Message_histories and returns the data saved in the database.
     * @param {message_historyCreateManyAndReturnArgs} args - Arguments to create many Message_histories.
     * @example
     * // Create many Message_histories
     * const message_history = await prisma.message_history.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Message_histories and only return the `id`
     * const message_historyWithIdOnly = await prisma.message_history.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends message_historyCreateManyAndReturnArgs>(args?: SelectSubset<T, message_historyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Message_history.
     * @param {message_historyDeleteArgs} args - Arguments to delete one Message_history.
     * @example
     * // Delete one Message_history
     * const Message_history = await prisma.message_history.delete({
     *   where: {
     *     // ... filter to delete one Message_history
     *   }
     * })
     * 
     */
    delete<T extends message_historyDeleteArgs>(args: SelectSubset<T, message_historyDeleteArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Message_history.
     * @param {message_historyUpdateArgs} args - Arguments to update one Message_history.
     * @example
     * // Update one Message_history
     * const message_history = await prisma.message_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends message_historyUpdateArgs>(args: SelectSubset<T, message_historyUpdateArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Message_histories.
     * @param {message_historyDeleteManyArgs} args - Arguments to filter Message_histories to delete.
     * @example
     * // Delete a few Message_histories
     * const { count } = await prisma.message_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends message_historyDeleteManyArgs>(args?: SelectSubset<T, message_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Message_histories
     * const message_history = await prisma.message_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends message_historyUpdateManyArgs>(args: SelectSubset<T, message_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_histories and returns the data updated in the database.
     * @param {message_historyUpdateManyAndReturnArgs} args - Arguments to update many Message_histories.
     * @example
     * // Update many Message_histories
     * const message_history = await prisma.message_history.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Message_histories and only return the `id`
     * const message_historyWithIdOnly = await prisma.message_history.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends message_historyUpdateManyAndReturnArgs>(args: SelectSubset<T, message_historyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Message_history.
     * @param {message_historyUpsertArgs} args - Arguments to update or create a Message_history.
     * @example
     * // Update or create a Message_history
     * const message_history = await prisma.message_history.upsert({
     *   create: {
     *     // ... data to create a Message_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message_history we want to update
     *   }
     * })
     */
    upsert<T extends message_historyUpsertArgs>(args: SelectSubset<T, message_historyUpsertArgs<ExtArgs>>): Prisma__message_historyClient<$Result.GetResult<Prisma.$message_historyPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Message_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_historyCountArgs} args - Arguments to filter Message_histories to count.
     * @example
     * // Count the number of Message_histories
     * const count = await prisma.message_history.count({
     *   where: {
     *     // ... the filter for the Message_histories we want to count
     *   }
     * })
    **/
    count<T extends message_historyCountArgs>(
      args?: Subset<T, message_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Message_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Message_historyAggregateArgs>(args: Subset<T, Message_historyAggregateArgs>): Prisma.PrismaPromise<GetMessage_historyAggregateType<T>>

    /**
     * Group by Message_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends message_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: message_historyGroupByArgs['orderBy'] }
        : { orderBy?: message_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, message_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessage_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message_history model
   */
  readonly fields: message_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__message_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message_history model
   */ 
  interface message_historyFieldRefs {
    readonly id: FieldRef<"message_history", 'Int'>
    readonly user_id: FieldRef<"message_history", 'String'>
    readonly chat_jid: FieldRef<"message_history", 'String'>
    readonly sender_jid: FieldRef<"message_history", 'String'>
    readonly message_id: FieldRef<"message_history", 'String'>
    readonly timestamp: FieldRef<"message_history", 'DateTime'>
    readonly message_type: FieldRef<"message_history", 'String'>
    readonly text_content: FieldRef<"message_history", 'String'>
    readonly media_link: FieldRef<"message_history", 'String'>
    readonly quoted_message_id: FieldRef<"message_history", 'String'>
    readonly datajson: FieldRef<"message_history", 'String'>
  }
    

  // Custom InputTypes
  /**
   * message_history findUnique
   */
  export type message_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * Filter, which message_history to fetch.
     */
    where: message_historyWhereUniqueInput
  }

  /**
   * message_history findUniqueOrThrow
   */
  export type message_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * Filter, which message_history to fetch.
     */
    where: message_historyWhereUniqueInput
  }

  /**
   * message_history findFirst
   */
  export type message_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * Filter, which message_history to fetch.
     */
    where?: message_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_histories to fetch.
     */
    orderBy?: message_historyOrderByWithRelationInput | message_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_histories.
     */
    cursor?: message_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_histories.
     */
    distinct?: Message_historyScalarFieldEnum | Message_historyScalarFieldEnum[]
  }

  /**
   * message_history findFirstOrThrow
   */
  export type message_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * Filter, which message_history to fetch.
     */
    where?: message_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_histories to fetch.
     */
    orderBy?: message_historyOrderByWithRelationInput | message_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_histories.
     */
    cursor?: message_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_histories.
     */
    distinct?: Message_historyScalarFieldEnum | Message_historyScalarFieldEnum[]
  }

  /**
   * message_history findMany
   */
  export type message_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * Filter, which message_histories to fetch.
     */
    where?: message_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_histories to fetch.
     */
    orderBy?: message_historyOrderByWithRelationInput | message_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing message_histories.
     */
    cursor?: message_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_histories.
     */
    skip?: number
    distinct?: Message_historyScalarFieldEnum | Message_historyScalarFieldEnum[]
  }

  /**
   * message_history create
   */
  export type message_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * The data needed to create a message_history.
     */
    data: XOR<message_historyCreateInput, message_historyUncheckedCreateInput>
  }

  /**
   * message_history createMany
   */
  export type message_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many message_histories.
     */
    data: message_historyCreateManyInput | message_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message_history createManyAndReturn
   */
  export type message_historyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * The data used to create many message_histories.
     */
    data: message_historyCreateManyInput | message_historyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message_history update
   */
  export type message_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * The data needed to update a message_history.
     */
    data: XOR<message_historyUpdateInput, message_historyUncheckedUpdateInput>
    /**
     * Choose, which message_history to update.
     */
    where: message_historyWhereUniqueInput
  }

  /**
   * message_history updateMany
   */
  export type message_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update message_histories.
     */
    data: XOR<message_historyUpdateManyMutationInput, message_historyUncheckedUpdateManyInput>
    /**
     * Filter which message_histories to update
     */
    where?: message_historyWhereInput
  }

  /**
   * message_history updateManyAndReturn
   */
  export type message_historyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * The data used to update message_histories.
     */
    data: XOR<message_historyUpdateManyMutationInput, message_historyUncheckedUpdateManyInput>
    /**
     * Filter which message_histories to update
     */
    where?: message_historyWhereInput
  }

  /**
   * message_history upsert
   */
  export type message_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * The filter to search for the message_history to update in case it exists.
     */
    where: message_historyWhereUniqueInput
    /**
     * In case the message_history found by the `where` argument doesn't exist, create a new message_history with this data.
     */
    create: XOR<message_historyCreateInput, message_historyUncheckedCreateInput>
    /**
     * In case the message_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<message_historyUpdateInput, message_historyUncheckedUpdateInput>
  }

  /**
   * message_history delete
   */
  export type message_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
    /**
     * Filter which message_history to delete.
     */
    where: message_historyWhereUniqueInput
  }

  /**
   * message_history deleteMany
   */
  export type message_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_histories to delete
     */
    where?: message_historyWhereInput
  }

  /**
   * message_history without action
   */
  export type message_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_history
     */
    select?: message_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_history
     */
    omit?: message_historyOmit<ExtArgs> | null
  }


  /**
   * Model message_reactions
   */

  export type AggregateMessage_reactions = {
    _count: Message_reactionsCountAggregateOutputType | null
    _min: Message_reactionsMinAggregateOutputType | null
    _max: Message_reactionsMaxAggregateOutputType | null
  }

  export type Message_reactionsMinAggregateOutputType = {
    messageId: string | null
    participant: string | null
    emoji: string | null
    createdAt: Date | null
    userId: string | null
    id: string | null
  }

  export type Message_reactionsMaxAggregateOutputType = {
    messageId: string | null
    participant: string | null
    emoji: string | null
    createdAt: Date | null
    userId: string | null
    id: string | null
  }

  export type Message_reactionsCountAggregateOutputType = {
    messageId: number
    participant: number
    emoji: number
    createdAt: number
    userId: number
    id: number
    _all: number
  }


  export type Message_reactionsMinAggregateInputType = {
    messageId?: true
    participant?: true
    emoji?: true
    createdAt?: true
    userId?: true
    id?: true
  }

  export type Message_reactionsMaxAggregateInputType = {
    messageId?: true
    participant?: true
    emoji?: true
    createdAt?: true
    userId?: true
    id?: true
  }

  export type Message_reactionsCountAggregateInputType = {
    messageId?: true
    participant?: true
    emoji?: true
    createdAt?: true
    userId?: true
    id?: true
    _all?: true
  }

  export type Message_reactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_reactions to aggregate.
     */
    where?: message_reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionsOrderByWithRelationInput | message_reactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: message_reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned message_reactions
    **/
    _count?: true | Message_reactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Message_reactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Message_reactionsMaxAggregateInputType
  }

  export type GetMessage_reactionsAggregateType<T extends Message_reactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage_reactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage_reactions[P]>
      : GetScalarType<T[P], AggregateMessage_reactions[P]>
  }




  export type message_reactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: message_reactionsWhereInput
    orderBy?: message_reactionsOrderByWithAggregationInput | message_reactionsOrderByWithAggregationInput[]
    by: Message_reactionsScalarFieldEnum[] | Message_reactionsScalarFieldEnum
    having?: message_reactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Message_reactionsCountAggregateInputType | true
    _min?: Message_reactionsMinAggregateInputType
    _max?: Message_reactionsMaxAggregateInputType
  }

  export type Message_reactionsGroupByOutputType = {
    messageId: string
    participant: string | null
    emoji: string
    createdAt: Date | null
    userId: string | null
    id: string
    _count: Message_reactionsCountAggregateOutputType | null
    _min: Message_reactionsMinAggregateOutputType | null
    _max: Message_reactionsMaxAggregateOutputType | null
  }

  type GetMessage_reactionsGroupByPayload<T extends message_reactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Message_reactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Message_reactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Message_reactionsGroupByOutputType[P]>
            : GetScalarType<T[P], Message_reactionsGroupByOutputType[P]>
        }
      >
    >


  export type message_reactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    participant?: boolean
    emoji?: boolean
    createdAt?: boolean
    userId?: boolean
    id?: boolean
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_reactions"]>

  export type message_reactionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    participant?: boolean
    emoji?: boolean
    createdAt?: boolean
    userId?: boolean
    id?: boolean
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_reactions"]>

  export type message_reactionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    messageId?: boolean
    participant?: boolean
    emoji?: boolean
    createdAt?: boolean
    userId?: boolean
    id?: boolean
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message_reactions"]>

  export type message_reactionsSelectScalar = {
    messageId?: boolean
    participant?: boolean
    emoji?: boolean
    createdAt?: boolean
    userId?: boolean
    id?: boolean
  }

  export type message_reactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"messageId" | "participant" | "emoji" | "createdAt" | "userId" | "id", ExtArgs["result"]["message_reactions"]>
  export type message_reactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }
  export type message_reactionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }
  export type message_reactionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | messagesDefaultArgs<ExtArgs>
  }

  export type $message_reactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "message_reactions"
    objects: {
      messages: Prisma.$messagesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      messageId: string
      participant: string | null
      emoji: string
      createdAt: Date | null
      userId: string | null
      id: string
    }, ExtArgs["result"]["message_reactions"]>
    composites: {}
  }

  type message_reactionsGetPayload<S extends boolean | null | undefined | message_reactionsDefaultArgs> = $Result.GetResult<Prisma.$message_reactionsPayload, S>

  type message_reactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<message_reactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Message_reactionsCountAggregateInputType | true
    }

  export interface message_reactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['message_reactions'], meta: { name: 'message_reactions' } }
    /**
     * Find zero or one Message_reactions that matches the filter.
     * @param {message_reactionsFindUniqueArgs} args - Arguments to find a Message_reactions
     * @example
     * // Get one Message_reactions
     * const message_reactions = await prisma.message_reactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends message_reactionsFindUniqueArgs>(args: SelectSubset<T, message_reactionsFindUniqueArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Message_reactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {message_reactionsFindUniqueOrThrowArgs} args - Arguments to find a Message_reactions
     * @example
     * // Get one Message_reactions
     * const message_reactions = await prisma.message_reactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends message_reactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, message_reactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Message_reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionsFindFirstArgs} args - Arguments to find a Message_reactions
     * @example
     * // Get one Message_reactions
     * const message_reactions = await prisma.message_reactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends message_reactionsFindFirstArgs>(args?: SelectSubset<T, message_reactionsFindFirstArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Message_reactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionsFindFirstOrThrowArgs} args - Arguments to find a Message_reactions
     * @example
     * // Get one Message_reactions
     * const message_reactions = await prisma.message_reactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends message_reactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, message_reactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Message_reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Message_reactions
     * const message_reactions = await prisma.message_reactions.findMany()
     * 
     * // Get first 10 Message_reactions
     * const message_reactions = await prisma.message_reactions.findMany({ take: 10 })
     * 
     * // Only select the `messageId`
     * const message_reactionsWithMessageIdOnly = await prisma.message_reactions.findMany({ select: { messageId: true } })
     * 
     */
    findMany<T extends message_reactionsFindManyArgs>(args?: SelectSubset<T, message_reactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Message_reactions.
     * @param {message_reactionsCreateArgs} args - Arguments to create a Message_reactions.
     * @example
     * // Create one Message_reactions
     * const Message_reactions = await prisma.message_reactions.create({
     *   data: {
     *     // ... data to create a Message_reactions
     *   }
     * })
     * 
     */
    create<T extends message_reactionsCreateArgs>(args: SelectSubset<T, message_reactionsCreateArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Message_reactions.
     * @param {message_reactionsCreateManyArgs} args - Arguments to create many Message_reactions.
     * @example
     * // Create many Message_reactions
     * const message_reactions = await prisma.message_reactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends message_reactionsCreateManyArgs>(args?: SelectSubset<T, message_reactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Message_reactions and returns the data saved in the database.
     * @param {message_reactionsCreateManyAndReturnArgs} args - Arguments to create many Message_reactions.
     * @example
     * // Create many Message_reactions
     * const message_reactions = await prisma.message_reactions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Message_reactions and only return the `messageId`
     * const message_reactionsWithMessageIdOnly = await prisma.message_reactions.createManyAndReturn({
     *   select: { messageId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends message_reactionsCreateManyAndReturnArgs>(args?: SelectSubset<T, message_reactionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Message_reactions.
     * @param {message_reactionsDeleteArgs} args - Arguments to delete one Message_reactions.
     * @example
     * // Delete one Message_reactions
     * const Message_reactions = await prisma.message_reactions.delete({
     *   where: {
     *     // ... filter to delete one Message_reactions
     *   }
     * })
     * 
     */
    delete<T extends message_reactionsDeleteArgs>(args: SelectSubset<T, message_reactionsDeleteArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Message_reactions.
     * @param {message_reactionsUpdateArgs} args - Arguments to update one Message_reactions.
     * @example
     * // Update one Message_reactions
     * const message_reactions = await prisma.message_reactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends message_reactionsUpdateArgs>(args: SelectSubset<T, message_reactionsUpdateArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Message_reactions.
     * @param {message_reactionsDeleteManyArgs} args - Arguments to filter Message_reactions to delete.
     * @example
     * // Delete a few Message_reactions
     * const { count } = await prisma.message_reactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends message_reactionsDeleteManyArgs>(args?: SelectSubset<T, message_reactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Message_reactions
     * const message_reactions = await prisma.message_reactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends message_reactionsUpdateManyArgs>(args: SelectSubset<T, message_reactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Message_reactions and returns the data updated in the database.
     * @param {message_reactionsUpdateManyAndReturnArgs} args - Arguments to update many Message_reactions.
     * @example
     * // Update many Message_reactions
     * const message_reactions = await prisma.message_reactions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Message_reactions and only return the `messageId`
     * const message_reactionsWithMessageIdOnly = await prisma.message_reactions.updateManyAndReturn({
     *   select: { messageId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends message_reactionsUpdateManyAndReturnArgs>(args: SelectSubset<T, message_reactionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Message_reactions.
     * @param {message_reactionsUpsertArgs} args - Arguments to update or create a Message_reactions.
     * @example
     * // Update or create a Message_reactions
     * const message_reactions = await prisma.message_reactions.upsert({
     *   create: {
     *     // ... data to create a Message_reactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message_reactions we want to update
     *   }
     * })
     */
    upsert<T extends message_reactionsUpsertArgs>(args: SelectSubset<T, message_reactionsUpsertArgs<ExtArgs>>): Prisma__message_reactionsClient<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Message_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionsCountArgs} args - Arguments to filter Message_reactions to count.
     * @example
     * // Count the number of Message_reactions
     * const count = await prisma.message_reactions.count({
     *   where: {
     *     // ... the filter for the Message_reactions we want to count
     *   }
     * })
    **/
    count<T extends message_reactionsCountArgs>(
      args?: Subset<T, message_reactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Message_reactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Message_reactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Message_reactionsAggregateArgs>(args: Subset<T, Message_reactionsAggregateArgs>): Prisma.PrismaPromise<GetMessage_reactionsAggregateType<T>>

    /**
     * Group by Message_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {message_reactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends message_reactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: message_reactionsGroupByArgs['orderBy'] }
        : { orderBy?: message_reactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, message_reactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessage_reactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the message_reactions model
   */
  readonly fields: message_reactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for message_reactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__message_reactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends messagesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, messagesDefaultArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the message_reactions model
   */ 
  interface message_reactionsFieldRefs {
    readonly messageId: FieldRef<"message_reactions", 'String'>
    readonly participant: FieldRef<"message_reactions", 'String'>
    readonly emoji: FieldRef<"message_reactions", 'String'>
    readonly createdAt: FieldRef<"message_reactions", 'DateTime'>
    readonly userId: FieldRef<"message_reactions", 'String'>
    readonly id: FieldRef<"message_reactions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * message_reactions findUnique
   */
  export type message_reactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * Filter, which message_reactions to fetch.
     */
    where: message_reactionsWhereUniqueInput
  }

  /**
   * message_reactions findUniqueOrThrow
   */
  export type message_reactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * Filter, which message_reactions to fetch.
     */
    where: message_reactionsWhereUniqueInput
  }

  /**
   * message_reactions findFirst
   */
  export type message_reactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * Filter, which message_reactions to fetch.
     */
    where?: message_reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionsOrderByWithRelationInput | message_reactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_reactions.
     */
    cursor?: message_reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_reactions.
     */
    distinct?: Message_reactionsScalarFieldEnum | Message_reactionsScalarFieldEnum[]
  }

  /**
   * message_reactions findFirstOrThrow
   */
  export type message_reactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * Filter, which message_reactions to fetch.
     */
    where?: message_reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionsOrderByWithRelationInput | message_reactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for message_reactions.
     */
    cursor?: message_reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of message_reactions.
     */
    distinct?: Message_reactionsScalarFieldEnum | Message_reactionsScalarFieldEnum[]
  }

  /**
   * message_reactions findMany
   */
  export type message_reactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * Filter, which message_reactions to fetch.
     */
    where?: message_reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of message_reactions to fetch.
     */
    orderBy?: message_reactionsOrderByWithRelationInput | message_reactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing message_reactions.
     */
    cursor?: message_reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` message_reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` message_reactions.
     */
    skip?: number
    distinct?: Message_reactionsScalarFieldEnum | Message_reactionsScalarFieldEnum[]
  }

  /**
   * message_reactions create
   */
  export type message_reactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a message_reactions.
     */
    data: XOR<message_reactionsCreateInput, message_reactionsUncheckedCreateInput>
  }

  /**
   * message_reactions createMany
   */
  export type message_reactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many message_reactions.
     */
    data: message_reactionsCreateManyInput | message_reactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * message_reactions createManyAndReturn
   */
  export type message_reactionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * The data used to create many message_reactions.
     */
    data: message_reactionsCreateManyInput | message_reactionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * message_reactions update
   */
  export type message_reactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a message_reactions.
     */
    data: XOR<message_reactionsUpdateInput, message_reactionsUncheckedUpdateInput>
    /**
     * Choose, which message_reactions to update.
     */
    where: message_reactionsWhereUniqueInput
  }

  /**
   * message_reactions updateMany
   */
  export type message_reactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update message_reactions.
     */
    data: XOR<message_reactionsUpdateManyMutationInput, message_reactionsUncheckedUpdateManyInput>
    /**
     * Filter which message_reactions to update
     */
    where?: message_reactionsWhereInput
  }

  /**
   * message_reactions updateManyAndReturn
   */
  export type message_reactionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * The data used to update message_reactions.
     */
    data: XOR<message_reactionsUpdateManyMutationInput, message_reactionsUncheckedUpdateManyInput>
    /**
     * Filter which message_reactions to update
     */
    where?: message_reactionsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * message_reactions upsert
   */
  export type message_reactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the message_reactions to update in case it exists.
     */
    where: message_reactionsWhereUniqueInput
    /**
     * In case the message_reactions found by the `where` argument doesn't exist, create a new message_reactions with this data.
     */
    create: XOR<message_reactionsCreateInput, message_reactionsUncheckedCreateInput>
    /**
     * In case the message_reactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<message_reactionsUpdateInput, message_reactionsUncheckedUpdateInput>
  }

  /**
   * message_reactions delete
   */
  export type message_reactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    /**
     * Filter which message_reactions to delete.
     */
    where: message_reactionsWhereUniqueInput
  }

  /**
   * message_reactions deleteMany
   */
  export type message_reactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which message_reactions to delete
     */
    where?: message_reactionsWhereInput
  }

  /**
   * message_reactions without action
   */
  export type message_reactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesMinAggregateOutputType = {
    id: string | null
    chatId: string | null
    message: string | null
    timeStamp: Date | null
    isDelivered: boolean | null
    isRead: boolean | null
    messageType: string | null
    isFromMe: boolean | null
    contactId: string | null
    isEdit: boolean | null
    pushname: string | null
    mediaPath: string | null
    note: string | null
    isPinned: boolean | null
    userId: string | null
    replyToMessageId: string | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: string | null
    chatId: string | null
    message: string | null
    timeStamp: Date | null
    isDelivered: boolean | null
    isRead: boolean | null
    messageType: string | null
    isFromMe: boolean | null
    contactId: string | null
    isEdit: boolean | null
    pushname: string | null
    mediaPath: string | null
    note: string | null
    isPinned: boolean | null
    userId: string | null
    replyToMessageId: string | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    chatId: number
    message: number
    timeStamp: number
    isDelivered: number
    isRead: number
    messageType: number
    isFromMe: number
    contactId: number
    isEdit: number
    pushname: number
    mediaPath: number
    note: number
    isPinned: number
    userId: number
    replyToMessageId: number
    _all: number
  }


  export type MessagesMinAggregateInputType = {
    id?: true
    chatId?: true
    message?: true
    timeStamp?: true
    isDelivered?: true
    isRead?: true
    messageType?: true
    isFromMe?: true
    contactId?: true
    isEdit?: true
    pushname?: true
    mediaPath?: true
    note?: true
    isPinned?: true
    userId?: true
    replyToMessageId?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    chatId?: true
    message?: true
    timeStamp?: true
    isDelivered?: true
    isRead?: true
    messageType?: true
    isFromMe?: true
    contactId?: true
    isEdit?: true
    pushname?: true
    mediaPath?: true
    note?: true
    isPinned?: true
    userId?: true
    replyToMessageId?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    chatId?: true
    message?: true
    timeStamp?: true
    isDelivered?: true
    isRead?: true
    messageType?: true
    isFromMe?: true
    contactId?: true
    isEdit?: true
    pushname?: true
    mediaPath?: true
    note?: true
    isPinned?: true
    userId?: true
    replyToMessageId?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: string
    chatId: string | null
    message: string
    timeStamp: Date | null
    isDelivered: boolean | null
    isRead: boolean | null
    messageType: string | null
    isFromMe: boolean | null
    contactId: string | null
    isEdit: boolean | null
    pushname: string | null
    mediaPath: string | null
    note: string | null
    isPinned: boolean | null
    userId: string | null
    replyToMessageId: string | null
    _count: MessagesCountAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    message?: boolean
    timeStamp?: boolean
    isDelivered?: boolean
    isRead?: boolean
    messageType?: boolean
    isFromMe?: boolean
    contactId?: boolean
    isEdit?: boolean
    pushname?: boolean
    mediaPath?: boolean
    note?: boolean
    isPinned?: boolean
    userId?: boolean
    replyToMessageId?: boolean
    message_reactions?: boolean | messages$message_reactionsArgs<ExtArgs>
    chats?: boolean | messages$chatsArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    message?: boolean
    timeStamp?: boolean
    isDelivered?: boolean
    isRead?: boolean
    messageType?: boolean
    isFromMe?: boolean
    contactId?: boolean
    isEdit?: boolean
    pushname?: boolean
    mediaPath?: boolean
    note?: boolean
    isPinned?: boolean
    userId?: boolean
    replyToMessageId?: boolean
    chats?: boolean | messages$chatsArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chatId?: boolean
    message?: boolean
    timeStamp?: boolean
    isDelivered?: boolean
    isRead?: boolean
    messageType?: boolean
    isFromMe?: boolean
    contactId?: boolean
    isEdit?: boolean
    pushname?: boolean
    mediaPath?: boolean
    note?: boolean
    isPinned?: boolean
    userId?: boolean
    replyToMessageId?: boolean
    chats?: boolean | messages$chatsArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectScalar = {
    id?: boolean
    chatId?: boolean
    message?: boolean
    timeStamp?: boolean
    isDelivered?: boolean
    isRead?: boolean
    messageType?: boolean
    isFromMe?: boolean
    contactId?: boolean
    isEdit?: boolean
    pushname?: boolean
    mediaPath?: boolean
    note?: boolean
    isPinned?: boolean
    userId?: boolean
    replyToMessageId?: boolean
  }

  export type messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chatId" | "message" | "timeStamp" | "isDelivered" | "isRead" | "messageType" | "isFromMe" | "contactId" | "isEdit" | "pushname" | "mediaPath" | "note" | "isPinned" | "userId" | "replyToMessageId", ExtArgs["result"]["messages"]>
  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message_reactions?: boolean | messages$message_reactionsArgs<ExtArgs>
    chats?: boolean | messages$chatsArgs<ExtArgs>
    _count?: boolean | MessagesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | messages$chatsArgs<ExtArgs>
  }
  export type messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    chats?: boolean | messages$chatsArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      message_reactions: Prisma.$message_reactionsPayload<ExtArgs>[]
      chats: Prisma.$chatsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      chatId: string | null
      message: string
      timeStamp: Date | null
      isDelivered: boolean | null
      isRead: boolean | null
      messageType: string | null
      isFromMe: boolean | null
      contactId: string | null
      isEdit: boolean | null
      pushname: string | null
      mediaPath: string | null
      note: string | null
      isPinned: boolean | null
      userId: string | null
      replyToMessageId: string | null
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message_reactions<T extends messages$message_reactionsArgs<ExtArgs> = {}>(args?: Subset<T, messages$message_reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$message_reactionsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    chats<T extends messages$chatsArgs<ExtArgs> = {}>(args?: Subset<T, messages$chatsArgs<ExtArgs>>): Prisma__chatsClient<$Result.GetResult<Prisma.$chatsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | null, null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */ 
  interface messagesFieldRefs {
    readonly id: FieldRef<"messages", 'String'>
    readonly chatId: FieldRef<"messages", 'String'>
    readonly message: FieldRef<"messages", 'String'>
    readonly timeStamp: FieldRef<"messages", 'DateTime'>
    readonly isDelivered: FieldRef<"messages", 'Boolean'>
    readonly isRead: FieldRef<"messages", 'Boolean'>
    readonly messageType: FieldRef<"messages", 'String'>
    readonly isFromMe: FieldRef<"messages", 'Boolean'>
    readonly contactId: FieldRef<"messages", 'String'>
    readonly isEdit: FieldRef<"messages", 'Boolean'>
    readonly pushname: FieldRef<"messages", 'String'>
    readonly mediaPath: FieldRef<"messages", 'String'>
    readonly note: FieldRef<"messages", 'String'>
    readonly isPinned: FieldRef<"messages", 'Boolean'>
    readonly userId: FieldRef<"messages", 'String'>
    readonly replyToMessageId: FieldRef<"messages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages createManyAndReturn
   */
  export type messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
  }

  /**
   * messages updateManyAndReturn
   */
  export type messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
  }

  /**
   * messages.message_reactions
   */
  export type messages$message_reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the message_reactions
     */
    select?: message_reactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the message_reactions
     */
    omit?: message_reactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: message_reactionsInclude<ExtArgs> | null
    where?: message_reactionsWhereInput
    orderBy?: message_reactionsOrderByWithRelationInput | message_reactionsOrderByWithRelationInput[]
    cursor?: message_reactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Message_reactionsScalarFieldEnum | Message_reactionsScalarFieldEnum[]
  }

  /**
   * messages.chats
   */
  export type messages$chatsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the chats
     */
    select?: chatsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the chats
     */
    omit?: chatsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: chatsInclude<ExtArgs> | null
    where?: chatsWhereInput
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    name: string | null
    applied_at: Date | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    applied_at: Date | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    name: number
    applied_at: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    name?: true
    applied_at?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    name: string
    applied_at: Date | null
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }, ExtArgs["result"]["migrations"]>

  export type migrationsSelectScalar = {
    id?: boolean
    name?: boolean
    applied_at?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "applied_at", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      applied_at: Date | null
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Migrations and returns the data saved in the database.
     * @param {migrationsCreateManyAndReturnArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends migrationsCreateManyAndReturnArgs>(args?: SelectSubset<T, migrationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations and returns the data updated in the database.
     * @param {migrationsUpdateManyAndReturnArgs} args - Arguments to update many Migrations.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Migrations and only return the `id`
     * const migrationsWithIdOnly = await prisma.migrations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends migrationsUpdateManyAndReturnArgs>(args: SelectSubset<T, migrationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */ 
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly name: FieldRef<"migrations", 'String'>
    readonly applied_at: FieldRef<"migrations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations createManyAndReturn
   */
  export type migrationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
  }

  /**
   * migrations updateManyAndReturn
   */
  export type migrationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model tags
   */

  export type AggregateTags = {
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  export type TagsAvgAggregateOutputType = {
    tagId: number | null
  }

  export type TagsSumAggregateOutputType = {
    tagId: bigint | null
  }

  export type TagsMinAggregateOutputType = {
    tagId: bigint | null
    tagName: string | null
  }

  export type TagsMaxAggregateOutputType = {
    tagId: bigint | null
    tagName: string | null
  }

  export type TagsCountAggregateOutputType = {
    tagId: number
    tagName: number
    _all: number
  }


  export type TagsAvgAggregateInputType = {
    tagId?: true
  }

  export type TagsSumAggregateInputType = {
    tagId?: true
  }

  export type TagsMinAggregateInputType = {
    tagId?: true
    tagName?: true
  }

  export type TagsMaxAggregateInputType = {
    tagId?: true
    tagName?: true
  }

  export type TagsCountAggregateInputType = {
    tagId?: true
    tagName?: true
    _all?: true
  }

  export type TagsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to aggregate.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tags
    **/
    _count?: true | TagsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagsMaxAggregateInputType
  }

  export type GetTagsAggregateType<T extends TagsAggregateArgs> = {
        [P in keyof T & keyof AggregateTags]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTags[P]>
      : GetScalarType<T[P], AggregateTags[P]>
  }




  export type tagsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: tagsWhereInput
    orderBy?: tagsOrderByWithAggregationInput | tagsOrderByWithAggregationInput[]
    by: TagsScalarFieldEnum[] | TagsScalarFieldEnum
    having?: tagsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagsCountAggregateInputType | true
    _avg?: TagsAvgAggregateInputType
    _sum?: TagsSumAggregateInputType
    _min?: TagsMinAggregateInputType
    _max?: TagsMaxAggregateInputType
  }

  export type TagsGroupByOutputType = {
    tagId: bigint
    tagName: string | null
    _count: TagsCountAggregateOutputType | null
    _avg: TagsAvgAggregateOutputType | null
    _sum: TagsSumAggregateOutputType | null
    _min: TagsMinAggregateOutputType | null
    _max: TagsMaxAggregateOutputType | null
  }

  type GetTagsGroupByPayload<T extends tagsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagsGroupByOutputType[P]>
            : GetScalarType<T[P], TagsGroupByOutputType[P]>
        }
      >
    >


  export type tagsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    tagName?: boolean
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    tagName?: boolean
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    tagId?: boolean
    tagName?: boolean
  }, ExtArgs["result"]["tags"]>

  export type tagsSelectScalar = {
    tagId?: boolean
    tagName?: boolean
  }

  export type tagsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"tagId" | "tagName", ExtArgs["result"]["tags"]>

  export type $tagsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "tags"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      tagId: bigint
      tagName: string | null
    }, ExtArgs["result"]["tags"]>
    composites: {}
  }

  type tagsGetPayload<S extends boolean | null | undefined | tagsDefaultArgs> = $Result.GetResult<Prisma.$tagsPayload, S>

  type tagsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<tagsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagsCountAggregateInputType | true
    }

  export interface tagsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['tags'], meta: { name: 'tags' } }
    /**
     * Find zero or one Tags that matches the filter.
     * @param {tagsFindUniqueArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends tagsFindUniqueArgs>(args: SelectSubset<T, tagsFindUniqueArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Tags that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {tagsFindUniqueOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends tagsFindUniqueOrThrowArgs>(args: SelectSubset<T, tagsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends tagsFindFirstArgs>(args?: SelectSubset<T, tagsFindFirstArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Tags that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindFirstOrThrowArgs} args - Arguments to find a Tags
     * @example
     * // Get one Tags
     * const tags = await prisma.tags.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends tagsFindFirstOrThrowArgs>(args?: SelectSubset<T, tagsFindFirstOrThrowArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tags.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tags.findMany({ take: 10 })
     * 
     * // Only select the `tagId`
     * const tagsWithTagIdOnly = await prisma.tags.findMany({ select: { tagId: true } })
     * 
     */
    findMany<T extends tagsFindManyArgs>(args?: SelectSubset<T, tagsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Tags.
     * @param {tagsCreateArgs} args - Arguments to create a Tags.
     * @example
     * // Create one Tags
     * const Tags = await prisma.tags.create({
     *   data: {
     *     // ... data to create a Tags
     *   }
     * })
     * 
     */
    create<T extends tagsCreateArgs>(args: SelectSubset<T, tagsCreateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Tags.
     * @param {tagsCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends tagsCreateManyArgs>(args?: SelectSubset<T, tagsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {tagsCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tags = await prisma.tags.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `tagId`
     * const tagsWithTagIdOnly = await prisma.tags.createManyAndReturn({
     *   select: { tagId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends tagsCreateManyAndReturnArgs>(args?: SelectSubset<T, tagsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Tags.
     * @param {tagsDeleteArgs} args - Arguments to delete one Tags.
     * @example
     * // Delete one Tags
     * const Tags = await prisma.tags.delete({
     *   where: {
     *     // ... filter to delete one Tags
     *   }
     * })
     * 
     */
    delete<T extends tagsDeleteArgs>(args: SelectSubset<T, tagsDeleteArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Tags.
     * @param {tagsUpdateArgs} args - Arguments to update one Tags.
     * @example
     * // Update one Tags
     * const tags = await prisma.tags.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends tagsUpdateArgs>(args: SelectSubset<T, tagsUpdateArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Tags.
     * @param {tagsDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tags.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends tagsDeleteManyArgs>(args?: SelectSubset<T, tagsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends tagsUpdateManyArgs>(args: SelectSubset<T, tagsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {tagsUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tags = await prisma.tags.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `tagId`
     * const tagsWithTagIdOnly = await prisma.tags.updateManyAndReturn({
     *   select: { tagId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends tagsUpdateManyAndReturnArgs>(args: SelectSubset<T, tagsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Tags.
     * @param {tagsUpsertArgs} args - Arguments to update or create a Tags.
     * @example
     * // Update or create a Tags
     * const tags = await prisma.tags.upsert({
     *   create: {
     *     // ... data to create a Tags
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tags we want to update
     *   }
     * })
     */
    upsert<T extends tagsUpsertArgs>(args: SelectSubset<T, tagsUpsertArgs<ExtArgs>>): Prisma__tagsClient<$Result.GetResult<Prisma.$tagsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tags.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends tagsCountArgs>(
      args?: Subset<T, tagsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagsAggregateArgs>(args: Subset<T, TagsAggregateArgs>): Prisma.PrismaPromise<GetTagsAggregateType<T>>

    /**
     * Group by Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tagsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends tagsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: tagsGroupByArgs['orderBy'] }
        : { orderBy?: tagsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, tagsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the tags model
   */
  readonly fields: tagsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for tags.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__tagsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the tags model
   */ 
  interface tagsFieldRefs {
    readonly tagId: FieldRef<"tags", 'BigInt'>
    readonly tagName: FieldRef<"tags", 'String'>
  }
    

  // Custom InputTypes
  /**
   * tags findUnique
   */
  export type tagsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findUniqueOrThrow
   */
  export type tagsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags findFirst
   */
  export type tagsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findFirstOrThrow
   */
  export type tagsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tags.
     */
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags findMany
   */
  export type tagsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Filter, which tags to fetch.
     */
    where?: tagsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tags to fetch.
     */
    orderBy?: tagsOrderByWithRelationInput | tagsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tags.
     */
    cursor?: tagsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tags.
     */
    skip?: number
    distinct?: TagsScalarFieldEnum | TagsScalarFieldEnum[]
  }

  /**
   * tags create
   */
  export type tagsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data needed to create a tags.
     */
    data?: XOR<tagsCreateInput, tagsUncheckedCreateInput>
  }

  /**
   * tags createMany
   */
  export type tagsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags createManyAndReturn
   */
  export type tagsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to create many tags.
     */
    data: tagsCreateManyInput | tagsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * tags update
   */
  export type tagsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data needed to update a tags.
     */
    data: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
    /**
     * Choose, which tags to update.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags updateMany
   */
  export type tagsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
  }

  /**
   * tags updateManyAndReturn
   */
  export type tagsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The data used to update tags.
     */
    data: XOR<tagsUpdateManyMutationInput, tagsUncheckedUpdateManyInput>
    /**
     * Filter which tags to update
     */
    where?: tagsWhereInput
  }

  /**
   * tags upsert
   */
  export type tagsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * The filter to search for the tags to update in case it exists.
     */
    where: tagsWhereUniqueInput
    /**
     * In case the tags found by the `where` argument doesn't exist, create a new tags with this data.
     */
    create: XOR<tagsCreateInput, tagsUncheckedCreateInput>
    /**
     * In case the tags was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tagsUpdateInput, tagsUncheckedUpdateInput>
  }

  /**
   * tags delete
   */
  export type tagsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
    /**
     * Filter which tags to delete.
     */
    where: tagsWhereUniqueInput
  }

  /**
   * tags deleteMany
   */
  export type tagsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which tags to delete
     */
    where?: tagsWhereInput
  }

  /**
   * tags without action
   */
  export type tagsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the tags
     */
    select?: tagsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the tags
     */
    omit?: tagsOmit<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    connected: number | null
    expiration: number | null
    s3_retention_days: number | null
    history: number | null
  }

  export type UsersSumAggregateOutputType = {
    connected: number | null
    expiration: number | null
    s3_retention_days: number | null
    history: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    token: string | null
    webhook: string | null
    jid: string | null
    qrcode: string | null
    connected: number | null
    expiration: number | null
    events: string | null
    proxy_url: string | null
    s3_enabled: boolean | null
    s3_endpoint: string | null
    s3_region: string | null
    s3_bucket: string | null
    s3_access_key: string | null
    s3_secret_key: string | null
    s3_path_style: boolean | null
    s3_public_url: string | null
    media_delivery: string | null
    s3_retention_days: number | null
    history: number | null
    hmac_key: Uint8Array | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    token: string | null
    webhook: string | null
    jid: string | null
    qrcode: string | null
    connected: number | null
    expiration: number | null
    events: string | null
    proxy_url: string | null
    s3_enabled: boolean | null
    s3_endpoint: string | null
    s3_region: string | null
    s3_bucket: string | null
    s3_access_key: string | null
    s3_secret_key: string | null
    s3_path_style: boolean | null
    s3_public_url: string | null
    media_delivery: string | null
    s3_retention_days: number | null
    history: number | null
    hmac_key: Uint8Array | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    token: number
    webhook: number
    jid: number
    qrcode: number
    connected: number
    expiration: number
    events: number
    proxy_url: number
    s3_enabled: number
    s3_endpoint: number
    s3_region: number
    s3_bucket: number
    s3_access_key: number
    s3_secret_key: number
    s3_path_style: number
    s3_public_url: number
    media_delivery: number
    s3_retention_days: number
    history: number
    hmac_key: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    connected?: true
    expiration?: true
    s3_retention_days?: true
    history?: true
  }

  export type UsersSumAggregateInputType = {
    connected?: true
    expiration?: true
    s3_retention_days?: true
    history?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    token?: true
    webhook?: true
    jid?: true
    qrcode?: true
    connected?: true
    expiration?: true
    events?: true
    proxy_url?: true
    s3_enabled?: true
    s3_endpoint?: true
    s3_region?: true
    s3_bucket?: true
    s3_access_key?: true
    s3_secret_key?: true
    s3_path_style?: true
    s3_public_url?: true
    media_delivery?: true
    s3_retention_days?: true
    history?: true
    hmac_key?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    token?: true
    webhook?: true
    jid?: true
    qrcode?: true
    connected?: true
    expiration?: true
    events?: true
    proxy_url?: true
    s3_enabled?: true
    s3_endpoint?: true
    s3_region?: true
    s3_bucket?: true
    s3_access_key?: true
    s3_secret_key?: true
    s3_path_style?: true
    s3_public_url?: true
    media_delivery?: true
    s3_retention_days?: true
    history?: true
    hmac_key?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    token?: true
    webhook?: true
    jid?: true
    qrcode?: true
    connected?: true
    expiration?: true
    events?: true
    proxy_url?: true
    s3_enabled?: true
    s3_endpoint?: true
    s3_region?: true
    s3_bucket?: true
    s3_access_key?: true
    s3_secret_key?: true
    s3_path_style?: true
    s3_public_url?: true
    media_delivery?: true
    s3_retention_days?: true
    history?: true
    hmac_key?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string
    token: string
    webhook: string
    jid: string
    qrcode: string
    connected: number | null
    expiration: number | null
    events: string
    proxy_url: string | null
    s3_enabled: boolean | null
    s3_endpoint: string | null
    s3_region: string | null
    s3_bucket: string | null
    s3_access_key: string | null
    s3_secret_key: string | null
    s3_path_style: boolean | null
    s3_public_url: string | null
    media_delivery: string | null
    s3_retention_days: number | null
    history: number | null
    hmac_key: Uint8Array | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    token?: boolean
    webhook?: boolean
    jid?: boolean
    qrcode?: boolean
    connected?: boolean
    expiration?: boolean
    events?: boolean
    proxy_url?: boolean
    s3_enabled?: boolean
    s3_endpoint?: boolean
    s3_region?: boolean
    s3_bucket?: boolean
    s3_access_key?: boolean
    s3_secret_key?: boolean
    s3_path_style?: boolean
    s3_public_url?: boolean
    media_delivery?: boolean
    s3_retention_days?: boolean
    history?: boolean
    hmac_key?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    token?: boolean
    webhook?: boolean
    jid?: boolean
    qrcode?: boolean
    connected?: boolean
    expiration?: boolean
    events?: boolean
    proxy_url?: boolean
    s3_enabled?: boolean
    s3_endpoint?: boolean
    s3_region?: boolean
    s3_bucket?: boolean
    s3_access_key?: boolean
    s3_secret_key?: boolean
    s3_path_style?: boolean
    s3_public_url?: boolean
    media_delivery?: boolean
    s3_retention_days?: boolean
    history?: boolean
    hmac_key?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    token?: boolean
    webhook?: boolean
    jid?: boolean
    qrcode?: boolean
    connected?: boolean
    expiration?: boolean
    events?: boolean
    proxy_url?: boolean
    s3_enabled?: boolean
    s3_endpoint?: boolean
    s3_region?: boolean
    s3_bucket?: boolean
    s3_access_key?: boolean
    s3_secret_key?: boolean
    s3_path_style?: boolean
    s3_public_url?: boolean
    media_delivery?: boolean
    s3_retention_days?: boolean
    history?: boolean
    hmac_key?: boolean
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    token?: boolean
    webhook?: boolean
    jid?: boolean
    qrcode?: boolean
    connected?: boolean
    expiration?: boolean
    events?: boolean
    proxy_url?: boolean
    s3_enabled?: boolean
    s3_endpoint?: boolean
    s3_region?: boolean
    s3_bucket?: boolean
    s3_access_key?: boolean
    s3_secret_key?: boolean
    s3_path_style?: boolean
    s3_public_url?: boolean
    media_delivery?: boolean
    s3_retention_days?: boolean
    history?: boolean
    hmac_key?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "token" | "webhook" | "jid" | "qrcode" | "connected" | "expiration" | "events" | "proxy_url" | "s3_enabled" | "s3_endpoint" | "s3_region" | "s3_bucket" | "s3_access_key" | "s3_secret_key" | "s3_path_style" | "s3_public_url" | "media_delivery" | "s3_retention_days" | "history" | "hmac_key", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      token: string
      webhook: string
      jid: string
      qrcode: string
      connected: number | null
      expiration: number | null
      events: string
      proxy_url: string | null
      s3_enabled: boolean | null
      s3_endpoint: string | null
      s3_region: string | null
      s3_bucket: string | null
      s3_access_key: string | null
      s3_secret_key: string | null
      s3_path_style: boolean | null
      s3_public_url: string | null
      media_delivery: string | null
      s3_retention_days: number | null
      history: number | null
      hmac_key: Uint8Array | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */ 
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly token: FieldRef<"users", 'String'>
    readonly webhook: FieldRef<"users", 'String'>
    readonly jid: FieldRef<"users", 'String'>
    readonly qrcode: FieldRef<"users", 'String'>
    readonly connected: FieldRef<"users", 'Int'>
    readonly expiration: FieldRef<"users", 'Int'>
    readonly events: FieldRef<"users", 'String'>
    readonly proxy_url: FieldRef<"users", 'String'>
    readonly s3_enabled: FieldRef<"users", 'Boolean'>
    readonly s3_endpoint: FieldRef<"users", 'String'>
    readonly s3_region: FieldRef<"users", 'String'>
    readonly s3_bucket: FieldRef<"users", 'String'>
    readonly s3_access_key: FieldRef<"users", 'String'>
    readonly s3_secret_key: FieldRef<"users", 'String'>
    readonly s3_path_style: FieldRef<"users", 'Boolean'>
    readonly s3_public_url: FieldRef<"users", 'String'>
    readonly media_delivery: FieldRef<"users", 'String'>
    readonly s3_retention_days: FieldRef<"users", 'Int'>
    readonly history: FieldRef<"users", 'Int'>
    readonly hmac_key: FieldRef<"users", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model whatsmeow_app_state_mutation_macs
   */

  export type AggregateWhatsmeow_app_state_mutation_macs = {
    _count: Whatsmeow_app_state_mutation_macsCountAggregateOutputType | null
    _avg: Whatsmeow_app_state_mutation_macsAvgAggregateOutputType | null
    _sum: Whatsmeow_app_state_mutation_macsSumAggregateOutputType | null
    _min: Whatsmeow_app_state_mutation_macsMinAggregateOutputType | null
    _max: Whatsmeow_app_state_mutation_macsMaxAggregateOutputType | null
  }

  export type Whatsmeow_app_state_mutation_macsAvgAggregateOutputType = {
    version: number | null
  }

  export type Whatsmeow_app_state_mutation_macsSumAggregateOutputType = {
    version: bigint | null
  }

  export type Whatsmeow_app_state_mutation_macsMinAggregateOutputType = {
    jid: string | null
    name: string | null
    version: bigint | null
    index_mac: Uint8Array | null
    value_mac: Uint8Array | null
  }

  export type Whatsmeow_app_state_mutation_macsMaxAggregateOutputType = {
    jid: string | null
    name: string | null
    version: bigint | null
    index_mac: Uint8Array | null
    value_mac: Uint8Array | null
  }

  export type Whatsmeow_app_state_mutation_macsCountAggregateOutputType = {
    jid: number
    name: number
    version: number
    index_mac: number
    value_mac: number
    _all: number
  }


  export type Whatsmeow_app_state_mutation_macsAvgAggregateInputType = {
    version?: true
  }

  export type Whatsmeow_app_state_mutation_macsSumAggregateInputType = {
    version?: true
  }

  export type Whatsmeow_app_state_mutation_macsMinAggregateInputType = {
    jid?: true
    name?: true
    version?: true
    index_mac?: true
    value_mac?: true
  }

  export type Whatsmeow_app_state_mutation_macsMaxAggregateInputType = {
    jid?: true
    name?: true
    version?: true
    index_mac?: true
    value_mac?: true
  }

  export type Whatsmeow_app_state_mutation_macsCountAggregateInputType = {
    jid?: true
    name?: true
    version?: true
    index_mac?: true
    value_mac?: true
    _all?: true
  }

  export type Whatsmeow_app_state_mutation_macsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_app_state_mutation_macs to aggregate.
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_mutation_macs to fetch.
     */
    orderBy?: whatsmeow_app_state_mutation_macsOrderByWithRelationInput | whatsmeow_app_state_mutation_macsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_app_state_mutation_macsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_mutation_macs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_mutation_macs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_app_state_mutation_macs
    **/
    _count?: true | Whatsmeow_app_state_mutation_macsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_app_state_mutation_macsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_app_state_mutation_macsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_app_state_mutation_macsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_app_state_mutation_macsMaxAggregateInputType
  }

  export type GetWhatsmeow_app_state_mutation_macsAggregateType<T extends Whatsmeow_app_state_mutation_macsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_app_state_mutation_macs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_app_state_mutation_macs[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_app_state_mutation_macs[P]>
  }




  export type whatsmeow_app_state_mutation_macsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_app_state_mutation_macsWhereInput
    orderBy?: whatsmeow_app_state_mutation_macsOrderByWithAggregationInput | whatsmeow_app_state_mutation_macsOrderByWithAggregationInput[]
    by: Whatsmeow_app_state_mutation_macsScalarFieldEnum[] | Whatsmeow_app_state_mutation_macsScalarFieldEnum
    having?: whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_app_state_mutation_macsCountAggregateInputType | true
    _avg?: Whatsmeow_app_state_mutation_macsAvgAggregateInputType
    _sum?: Whatsmeow_app_state_mutation_macsSumAggregateInputType
    _min?: Whatsmeow_app_state_mutation_macsMinAggregateInputType
    _max?: Whatsmeow_app_state_mutation_macsMaxAggregateInputType
  }

  export type Whatsmeow_app_state_mutation_macsGroupByOutputType = {
    jid: string
    name: string
    version: bigint
    index_mac: Uint8Array
    value_mac: Uint8Array
    _count: Whatsmeow_app_state_mutation_macsCountAggregateOutputType | null
    _avg: Whatsmeow_app_state_mutation_macsAvgAggregateOutputType | null
    _sum: Whatsmeow_app_state_mutation_macsSumAggregateOutputType | null
    _min: Whatsmeow_app_state_mutation_macsMinAggregateOutputType | null
    _max: Whatsmeow_app_state_mutation_macsMaxAggregateOutputType | null
  }

  type GetWhatsmeow_app_state_mutation_macsGroupByPayload<T extends whatsmeow_app_state_mutation_macsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_app_state_mutation_macsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_app_state_mutation_macsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_app_state_mutation_macsGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_app_state_mutation_macsGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_app_state_mutation_macsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    name?: boolean
    version?: boolean
    index_mac?: boolean
    value_mac?: boolean
    whatsmeow_app_state_version?: boolean | whatsmeow_app_state_versionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_mutation_macs"]>

  export type whatsmeow_app_state_mutation_macsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    name?: boolean
    version?: boolean
    index_mac?: boolean
    value_mac?: boolean
    whatsmeow_app_state_version?: boolean | whatsmeow_app_state_versionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_mutation_macs"]>

  export type whatsmeow_app_state_mutation_macsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    name?: boolean
    version?: boolean
    index_mac?: boolean
    value_mac?: boolean
    whatsmeow_app_state_version?: boolean | whatsmeow_app_state_versionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_mutation_macs"]>

  export type whatsmeow_app_state_mutation_macsSelectScalar = {
    jid?: boolean
    name?: boolean
    version?: boolean
    index_mac?: boolean
    value_mac?: boolean
  }

  export type whatsmeow_app_state_mutation_macsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jid" | "name" | "version" | "index_mac" | "value_mac", ExtArgs["result"]["whatsmeow_app_state_mutation_macs"]>
  export type whatsmeow_app_state_mutation_macsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_version?: boolean | whatsmeow_app_state_versionDefaultArgs<ExtArgs>
  }
  export type whatsmeow_app_state_mutation_macsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_version?: boolean | whatsmeow_app_state_versionDefaultArgs<ExtArgs>
  }
  export type whatsmeow_app_state_mutation_macsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_version?: boolean | whatsmeow_app_state_versionDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_app_state_mutation_macsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_app_state_mutation_macs"
    objects: {
      whatsmeow_app_state_version: Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jid: string
      name: string
      version: bigint
      index_mac: Uint8Array
      value_mac: Uint8Array
    }, ExtArgs["result"]["whatsmeow_app_state_mutation_macs"]>
    composites: {}
  }

  type whatsmeow_app_state_mutation_macsGetPayload<S extends boolean | null | undefined | whatsmeow_app_state_mutation_macsDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload, S>

  type whatsmeow_app_state_mutation_macsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_app_state_mutation_macsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_app_state_mutation_macsCountAggregateInputType | true
    }

  export interface whatsmeow_app_state_mutation_macsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_app_state_mutation_macs'], meta: { name: 'whatsmeow_app_state_mutation_macs' } }
    /**
     * Find zero or one Whatsmeow_app_state_mutation_macs that matches the filter.
     * @param {whatsmeow_app_state_mutation_macsFindUniqueArgs} args - Arguments to find a Whatsmeow_app_state_mutation_macs
     * @example
     * // Get one Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_app_state_mutation_macsFindUniqueArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_app_state_mutation_macs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_app_state_mutation_macsFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_app_state_mutation_macs
     * @example
     * // Get one Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_app_state_mutation_macsFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_app_state_mutation_macs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_mutation_macsFindFirstArgs} args - Arguments to find a Whatsmeow_app_state_mutation_macs
     * @example
     * // Get one Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_app_state_mutation_macsFindFirstArgs>(args?: SelectSubset<T, whatsmeow_app_state_mutation_macsFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_app_state_mutation_macs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_mutation_macsFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_app_state_mutation_macs
     * @example
     * // Get one Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_app_state_mutation_macsFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_app_state_mutation_macsFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_app_state_mutation_macs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_mutation_macsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findMany()
     * 
     * // Get first 10 Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.findMany({ take: 10 })
     * 
     * // Only select the `jid`
     * const whatsmeow_app_state_mutation_macsWithJidOnly = await prisma.whatsmeow_app_state_mutation_macs.findMany({ select: { jid: true } })
     * 
     */
    findMany<T extends whatsmeow_app_state_mutation_macsFindManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_mutation_macsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_app_state_mutation_macs.
     * @param {whatsmeow_app_state_mutation_macsCreateArgs} args - Arguments to create a Whatsmeow_app_state_mutation_macs.
     * @example
     * // Create one Whatsmeow_app_state_mutation_macs
     * const Whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.create({
     *   data: {
     *     // ... data to create a Whatsmeow_app_state_mutation_macs
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_app_state_mutation_macsCreateArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsCreateArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_app_state_mutation_macs.
     * @param {whatsmeow_app_state_mutation_macsCreateManyArgs} args - Arguments to create many Whatsmeow_app_state_mutation_macs.
     * @example
     * // Create many Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_app_state_mutation_macsCreateManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_mutation_macsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_app_state_mutation_macs and returns the data saved in the database.
     * @param {whatsmeow_app_state_mutation_macsCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_app_state_mutation_macs.
     * @example
     * // Create many Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_app_state_mutation_macs and only return the `jid`
     * const whatsmeow_app_state_mutation_macsWithJidOnly = await prisma.whatsmeow_app_state_mutation_macs.createManyAndReturn({
     *   select: { jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_app_state_mutation_macsCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_app_state_mutation_macsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_app_state_mutation_macs.
     * @param {whatsmeow_app_state_mutation_macsDeleteArgs} args - Arguments to delete one Whatsmeow_app_state_mutation_macs.
     * @example
     * // Delete one Whatsmeow_app_state_mutation_macs
     * const Whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_app_state_mutation_macs
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_app_state_mutation_macsDeleteArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsDeleteArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_app_state_mutation_macs.
     * @param {whatsmeow_app_state_mutation_macsUpdateArgs} args - Arguments to update one Whatsmeow_app_state_mutation_macs.
     * @example
     * // Update one Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_app_state_mutation_macsUpdateArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsUpdateArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_app_state_mutation_macs.
     * @param {whatsmeow_app_state_mutation_macsDeleteManyArgs} args - Arguments to filter Whatsmeow_app_state_mutation_macs to delete.
     * @example
     * // Delete a few Whatsmeow_app_state_mutation_macs
     * const { count } = await prisma.whatsmeow_app_state_mutation_macs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_app_state_mutation_macsDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_mutation_macsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_app_state_mutation_macs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_mutation_macsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_app_state_mutation_macsUpdateManyArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_app_state_mutation_macs and returns the data updated in the database.
     * @param {whatsmeow_app_state_mutation_macsUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_app_state_mutation_macs.
     * @example
     * // Update many Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_app_state_mutation_macs and only return the `jid`
     * const whatsmeow_app_state_mutation_macsWithJidOnly = await prisma.whatsmeow_app_state_mutation_macs.updateManyAndReturn({
     *   select: { jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_app_state_mutation_macsUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_app_state_mutation_macs.
     * @param {whatsmeow_app_state_mutation_macsUpsertArgs} args - Arguments to update or create a Whatsmeow_app_state_mutation_macs.
     * @example
     * // Update or create a Whatsmeow_app_state_mutation_macs
     * const whatsmeow_app_state_mutation_macs = await prisma.whatsmeow_app_state_mutation_macs.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_app_state_mutation_macs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_app_state_mutation_macs we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_app_state_mutation_macsUpsertArgs>(args: SelectSubset<T, whatsmeow_app_state_mutation_macsUpsertArgs<ExtArgs>>): Prisma__whatsmeow_app_state_mutation_macsClient<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_app_state_mutation_macs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_mutation_macsCountArgs} args - Arguments to filter Whatsmeow_app_state_mutation_macs to count.
     * @example
     * // Count the number of Whatsmeow_app_state_mutation_macs
     * const count = await prisma.whatsmeow_app_state_mutation_macs.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_app_state_mutation_macs we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_app_state_mutation_macsCountArgs>(
      args?: Subset<T, whatsmeow_app_state_mutation_macsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_app_state_mutation_macsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_app_state_mutation_macs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_app_state_mutation_macsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_app_state_mutation_macsAggregateArgs>(args: Subset<T, Whatsmeow_app_state_mutation_macsAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_app_state_mutation_macsAggregateType<T>>

    /**
     * Group by Whatsmeow_app_state_mutation_macs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_mutation_macsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_app_state_mutation_macsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_app_state_mutation_macsGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_app_state_mutation_macsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_app_state_mutation_macsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_app_state_mutation_macsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_app_state_mutation_macs model
   */
  readonly fields: whatsmeow_app_state_mutation_macsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_app_state_mutation_macs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_app_state_mutation_macsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_app_state_version<T extends whatsmeow_app_state_versionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_app_state_versionDefaultArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_app_state_mutation_macs model
   */ 
  interface whatsmeow_app_state_mutation_macsFieldRefs {
    readonly jid: FieldRef<"whatsmeow_app_state_mutation_macs", 'String'>
    readonly name: FieldRef<"whatsmeow_app_state_mutation_macs", 'String'>
    readonly version: FieldRef<"whatsmeow_app_state_mutation_macs", 'BigInt'>
    readonly index_mac: FieldRef<"whatsmeow_app_state_mutation_macs", 'Bytes'>
    readonly value_mac: FieldRef<"whatsmeow_app_state_mutation_macs", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_app_state_mutation_macs findUnique
   */
  export type whatsmeow_app_state_mutation_macsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_mutation_macs to fetch.
     */
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_mutation_macs findUniqueOrThrow
   */
  export type whatsmeow_app_state_mutation_macsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_mutation_macs to fetch.
     */
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_mutation_macs findFirst
   */
  export type whatsmeow_app_state_mutation_macsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_mutation_macs to fetch.
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_mutation_macs to fetch.
     */
    orderBy?: whatsmeow_app_state_mutation_macsOrderByWithRelationInput | whatsmeow_app_state_mutation_macsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_app_state_mutation_macs.
     */
    cursor?: whatsmeow_app_state_mutation_macsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_mutation_macs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_mutation_macs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_app_state_mutation_macs.
     */
    distinct?: Whatsmeow_app_state_mutation_macsScalarFieldEnum | Whatsmeow_app_state_mutation_macsScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_mutation_macs findFirstOrThrow
   */
  export type whatsmeow_app_state_mutation_macsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_mutation_macs to fetch.
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_mutation_macs to fetch.
     */
    orderBy?: whatsmeow_app_state_mutation_macsOrderByWithRelationInput | whatsmeow_app_state_mutation_macsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_app_state_mutation_macs.
     */
    cursor?: whatsmeow_app_state_mutation_macsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_mutation_macs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_mutation_macs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_app_state_mutation_macs.
     */
    distinct?: Whatsmeow_app_state_mutation_macsScalarFieldEnum | Whatsmeow_app_state_mutation_macsScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_mutation_macs findMany
   */
  export type whatsmeow_app_state_mutation_macsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_mutation_macs to fetch.
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_mutation_macs to fetch.
     */
    orderBy?: whatsmeow_app_state_mutation_macsOrderByWithRelationInput | whatsmeow_app_state_mutation_macsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_app_state_mutation_macs.
     */
    cursor?: whatsmeow_app_state_mutation_macsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_mutation_macs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_mutation_macs.
     */
    skip?: number
    distinct?: Whatsmeow_app_state_mutation_macsScalarFieldEnum | Whatsmeow_app_state_mutation_macsScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_mutation_macs create
   */
  export type whatsmeow_app_state_mutation_macsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_app_state_mutation_macs.
     */
    data: XOR<whatsmeow_app_state_mutation_macsCreateInput, whatsmeow_app_state_mutation_macsUncheckedCreateInput>
  }

  /**
   * whatsmeow_app_state_mutation_macs createMany
   */
  export type whatsmeow_app_state_mutation_macsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_app_state_mutation_macs.
     */
    data: whatsmeow_app_state_mutation_macsCreateManyInput | whatsmeow_app_state_mutation_macsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_app_state_mutation_macs createManyAndReturn
   */
  export type whatsmeow_app_state_mutation_macsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_app_state_mutation_macs.
     */
    data: whatsmeow_app_state_mutation_macsCreateManyInput | whatsmeow_app_state_mutation_macsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_app_state_mutation_macs update
   */
  export type whatsmeow_app_state_mutation_macsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_app_state_mutation_macs.
     */
    data: XOR<whatsmeow_app_state_mutation_macsUpdateInput, whatsmeow_app_state_mutation_macsUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_app_state_mutation_macs to update.
     */
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_mutation_macs updateMany
   */
  export type whatsmeow_app_state_mutation_macsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_app_state_mutation_macs.
     */
    data: XOR<whatsmeow_app_state_mutation_macsUpdateManyMutationInput, whatsmeow_app_state_mutation_macsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_app_state_mutation_macs to update
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
  }

  /**
   * whatsmeow_app_state_mutation_macs updateManyAndReturn
   */
  export type whatsmeow_app_state_mutation_macsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_app_state_mutation_macs.
     */
    data: XOR<whatsmeow_app_state_mutation_macsUpdateManyMutationInput, whatsmeow_app_state_mutation_macsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_app_state_mutation_macs to update
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_app_state_mutation_macs upsert
   */
  export type whatsmeow_app_state_mutation_macsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_app_state_mutation_macs to update in case it exists.
     */
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
    /**
     * In case the whatsmeow_app_state_mutation_macs found by the `where` argument doesn't exist, create a new whatsmeow_app_state_mutation_macs with this data.
     */
    create: XOR<whatsmeow_app_state_mutation_macsCreateInput, whatsmeow_app_state_mutation_macsUncheckedCreateInput>
    /**
     * In case the whatsmeow_app_state_mutation_macs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_app_state_mutation_macsUpdateInput, whatsmeow_app_state_mutation_macsUncheckedUpdateInput>
  }

  /**
   * whatsmeow_app_state_mutation_macs delete
   */
  export type whatsmeow_app_state_mutation_macsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_app_state_mutation_macs to delete.
     */
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_mutation_macs deleteMany
   */
  export type whatsmeow_app_state_mutation_macsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_app_state_mutation_macs to delete
     */
    where?: whatsmeow_app_state_mutation_macsWhereInput
  }

  /**
   * whatsmeow_app_state_mutation_macs without action
   */
  export type whatsmeow_app_state_mutation_macsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_app_state_sync_keys
   */

  export type AggregateWhatsmeow_app_state_sync_keys = {
    _count: Whatsmeow_app_state_sync_keysCountAggregateOutputType | null
    _avg: Whatsmeow_app_state_sync_keysAvgAggregateOutputType | null
    _sum: Whatsmeow_app_state_sync_keysSumAggregateOutputType | null
    _min: Whatsmeow_app_state_sync_keysMinAggregateOutputType | null
    _max: Whatsmeow_app_state_sync_keysMaxAggregateOutputType | null
  }

  export type Whatsmeow_app_state_sync_keysAvgAggregateOutputType = {
    timestamp: number | null
  }

  export type Whatsmeow_app_state_sync_keysSumAggregateOutputType = {
    timestamp: bigint | null
  }

  export type Whatsmeow_app_state_sync_keysMinAggregateOutputType = {
    jid: string | null
    key_id: Uint8Array | null
    key_data: Uint8Array | null
    timestamp: bigint | null
    fingerprint: Uint8Array | null
  }

  export type Whatsmeow_app_state_sync_keysMaxAggregateOutputType = {
    jid: string | null
    key_id: Uint8Array | null
    key_data: Uint8Array | null
    timestamp: bigint | null
    fingerprint: Uint8Array | null
  }

  export type Whatsmeow_app_state_sync_keysCountAggregateOutputType = {
    jid: number
    key_id: number
    key_data: number
    timestamp: number
    fingerprint: number
    _all: number
  }


  export type Whatsmeow_app_state_sync_keysAvgAggregateInputType = {
    timestamp?: true
  }

  export type Whatsmeow_app_state_sync_keysSumAggregateInputType = {
    timestamp?: true
  }

  export type Whatsmeow_app_state_sync_keysMinAggregateInputType = {
    jid?: true
    key_id?: true
    key_data?: true
    timestamp?: true
    fingerprint?: true
  }

  export type Whatsmeow_app_state_sync_keysMaxAggregateInputType = {
    jid?: true
    key_id?: true
    key_data?: true
    timestamp?: true
    fingerprint?: true
  }

  export type Whatsmeow_app_state_sync_keysCountAggregateInputType = {
    jid?: true
    key_id?: true
    key_data?: true
    timestamp?: true
    fingerprint?: true
    _all?: true
  }

  export type Whatsmeow_app_state_sync_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_app_state_sync_keys to aggregate.
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_sync_keys to fetch.
     */
    orderBy?: whatsmeow_app_state_sync_keysOrderByWithRelationInput | whatsmeow_app_state_sync_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_app_state_sync_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_sync_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_sync_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_app_state_sync_keys
    **/
    _count?: true | Whatsmeow_app_state_sync_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_app_state_sync_keysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_app_state_sync_keysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_app_state_sync_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_app_state_sync_keysMaxAggregateInputType
  }

  export type GetWhatsmeow_app_state_sync_keysAggregateType<T extends Whatsmeow_app_state_sync_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_app_state_sync_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_app_state_sync_keys[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_app_state_sync_keys[P]>
  }




  export type whatsmeow_app_state_sync_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_app_state_sync_keysWhereInput
    orderBy?: whatsmeow_app_state_sync_keysOrderByWithAggregationInput | whatsmeow_app_state_sync_keysOrderByWithAggregationInput[]
    by: Whatsmeow_app_state_sync_keysScalarFieldEnum[] | Whatsmeow_app_state_sync_keysScalarFieldEnum
    having?: whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_app_state_sync_keysCountAggregateInputType | true
    _avg?: Whatsmeow_app_state_sync_keysAvgAggregateInputType
    _sum?: Whatsmeow_app_state_sync_keysSumAggregateInputType
    _min?: Whatsmeow_app_state_sync_keysMinAggregateInputType
    _max?: Whatsmeow_app_state_sync_keysMaxAggregateInputType
  }

  export type Whatsmeow_app_state_sync_keysGroupByOutputType = {
    jid: string
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint
    fingerprint: Uint8Array
    _count: Whatsmeow_app_state_sync_keysCountAggregateOutputType | null
    _avg: Whatsmeow_app_state_sync_keysAvgAggregateOutputType | null
    _sum: Whatsmeow_app_state_sync_keysSumAggregateOutputType | null
    _min: Whatsmeow_app_state_sync_keysMinAggregateOutputType | null
    _max: Whatsmeow_app_state_sync_keysMaxAggregateOutputType | null
  }

  type GetWhatsmeow_app_state_sync_keysGroupByPayload<T extends whatsmeow_app_state_sync_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_app_state_sync_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_app_state_sync_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_app_state_sync_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_app_state_sync_keysGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_app_state_sync_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    key_id?: boolean
    key_data?: boolean
    timestamp?: boolean
    fingerprint?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_sync_keys"]>

  export type whatsmeow_app_state_sync_keysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    key_id?: boolean
    key_data?: boolean
    timestamp?: boolean
    fingerprint?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_sync_keys"]>

  export type whatsmeow_app_state_sync_keysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    key_id?: boolean
    key_data?: boolean
    timestamp?: boolean
    fingerprint?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_sync_keys"]>

  export type whatsmeow_app_state_sync_keysSelectScalar = {
    jid?: boolean
    key_id?: boolean
    key_data?: boolean
    timestamp?: boolean
    fingerprint?: boolean
  }

  export type whatsmeow_app_state_sync_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jid" | "key_id" | "key_data" | "timestamp" | "fingerprint", ExtArgs["result"]["whatsmeow_app_state_sync_keys"]>
  export type whatsmeow_app_state_sync_keysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_app_state_sync_keysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_app_state_sync_keysIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_app_state_sync_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_app_state_sync_keys"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jid: string
      key_id: Uint8Array
      key_data: Uint8Array
      timestamp: bigint
      fingerprint: Uint8Array
    }, ExtArgs["result"]["whatsmeow_app_state_sync_keys"]>
    composites: {}
  }

  type whatsmeow_app_state_sync_keysGetPayload<S extends boolean | null | undefined | whatsmeow_app_state_sync_keysDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload, S>

  type whatsmeow_app_state_sync_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_app_state_sync_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_app_state_sync_keysCountAggregateInputType | true
    }

  export interface whatsmeow_app_state_sync_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_app_state_sync_keys'], meta: { name: 'whatsmeow_app_state_sync_keys' } }
    /**
     * Find zero or one Whatsmeow_app_state_sync_keys that matches the filter.
     * @param {whatsmeow_app_state_sync_keysFindUniqueArgs} args - Arguments to find a Whatsmeow_app_state_sync_keys
     * @example
     * // Get one Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_app_state_sync_keysFindUniqueArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_app_state_sync_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_app_state_sync_keysFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_app_state_sync_keys
     * @example
     * // Get one Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_app_state_sync_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_app_state_sync_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_sync_keysFindFirstArgs} args - Arguments to find a Whatsmeow_app_state_sync_keys
     * @example
     * // Get one Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_app_state_sync_keysFindFirstArgs>(args?: SelectSubset<T, whatsmeow_app_state_sync_keysFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_app_state_sync_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_sync_keysFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_app_state_sync_keys
     * @example
     * // Get one Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_app_state_sync_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_app_state_sync_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_app_state_sync_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_sync_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findMany()
     * 
     * // Get first 10 Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.findMany({ take: 10 })
     * 
     * // Only select the `jid`
     * const whatsmeow_app_state_sync_keysWithJidOnly = await prisma.whatsmeow_app_state_sync_keys.findMany({ select: { jid: true } })
     * 
     */
    findMany<T extends whatsmeow_app_state_sync_keysFindManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_sync_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_app_state_sync_keys.
     * @param {whatsmeow_app_state_sync_keysCreateArgs} args - Arguments to create a Whatsmeow_app_state_sync_keys.
     * @example
     * // Create one Whatsmeow_app_state_sync_keys
     * const Whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.create({
     *   data: {
     *     // ... data to create a Whatsmeow_app_state_sync_keys
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_app_state_sync_keysCreateArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysCreateArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_app_state_sync_keys.
     * @param {whatsmeow_app_state_sync_keysCreateManyArgs} args - Arguments to create many Whatsmeow_app_state_sync_keys.
     * @example
     * // Create many Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_app_state_sync_keysCreateManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_sync_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_app_state_sync_keys and returns the data saved in the database.
     * @param {whatsmeow_app_state_sync_keysCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_app_state_sync_keys.
     * @example
     * // Create many Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_app_state_sync_keys and only return the `jid`
     * const whatsmeow_app_state_sync_keysWithJidOnly = await prisma.whatsmeow_app_state_sync_keys.createManyAndReturn({
     *   select: { jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_app_state_sync_keysCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_app_state_sync_keysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_app_state_sync_keys.
     * @param {whatsmeow_app_state_sync_keysDeleteArgs} args - Arguments to delete one Whatsmeow_app_state_sync_keys.
     * @example
     * // Delete one Whatsmeow_app_state_sync_keys
     * const Whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_app_state_sync_keys
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_app_state_sync_keysDeleteArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysDeleteArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_app_state_sync_keys.
     * @param {whatsmeow_app_state_sync_keysUpdateArgs} args - Arguments to update one Whatsmeow_app_state_sync_keys.
     * @example
     * // Update one Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_app_state_sync_keysUpdateArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysUpdateArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_app_state_sync_keys.
     * @param {whatsmeow_app_state_sync_keysDeleteManyArgs} args - Arguments to filter Whatsmeow_app_state_sync_keys to delete.
     * @example
     * // Delete a few Whatsmeow_app_state_sync_keys
     * const { count } = await prisma.whatsmeow_app_state_sync_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_app_state_sync_keysDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_sync_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_app_state_sync_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_sync_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_app_state_sync_keysUpdateManyArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_app_state_sync_keys and returns the data updated in the database.
     * @param {whatsmeow_app_state_sync_keysUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_app_state_sync_keys.
     * @example
     * // Update many Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_app_state_sync_keys and only return the `jid`
     * const whatsmeow_app_state_sync_keysWithJidOnly = await prisma.whatsmeow_app_state_sync_keys.updateManyAndReturn({
     *   select: { jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_app_state_sync_keysUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_app_state_sync_keys.
     * @param {whatsmeow_app_state_sync_keysUpsertArgs} args - Arguments to update or create a Whatsmeow_app_state_sync_keys.
     * @example
     * // Update or create a Whatsmeow_app_state_sync_keys
     * const whatsmeow_app_state_sync_keys = await prisma.whatsmeow_app_state_sync_keys.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_app_state_sync_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_app_state_sync_keys we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_app_state_sync_keysUpsertArgs>(args: SelectSubset<T, whatsmeow_app_state_sync_keysUpsertArgs<ExtArgs>>): Prisma__whatsmeow_app_state_sync_keysClient<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_app_state_sync_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_sync_keysCountArgs} args - Arguments to filter Whatsmeow_app_state_sync_keys to count.
     * @example
     * // Count the number of Whatsmeow_app_state_sync_keys
     * const count = await prisma.whatsmeow_app_state_sync_keys.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_app_state_sync_keys we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_app_state_sync_keysCountArgs>(
      args?: Subset<T, whatsmeow_app_state_sync_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_app_state_sync_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_app_state_sync_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_app_state_sync_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_app_state_sync_keysAggregateArgs>(args: Subset<T, Whatsmeow_app_state_sync_keysAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_app_state_sync_keysAggregateType<T>>

    /**
     * Group by Whatsmeow_app_state_sync_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_sync_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_app_state_sync_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_app_state_sync_keysGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_app_state_sync_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_app_state_sync_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_app_state_sync_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_app_state_sync_keys model
   */
  readonly fields: whatsmeow_app_state_sync_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_app_state_sync_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_app_state_sync_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_app_state_sync_keys model
   */ 
  interface whatsmeow_app_state_sync_keysFieldRefs {
    readonly jid: FieldRef<"whatsmeow_app_state_sync_keys", 'String'>
    readonly key_id: FieldRef<"whatsmeow_app_state_sync_keys", 'Bytes'>
    readonly key_data: FieldRef<"whatsmeow_app_state_sync_keys", 'Bytes'>
    readonly timestamp: FieldRef<"whatsmeow_app_state_sync_keys", 'BigInt'>
    readonly fingerprint: FieldRef<"whatsmeow_app_state_sync_keys", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_app_state_sync_keys findUnique
   */
  export type whatsmeow_app_state_sync_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_sync_keys to fetch.
     */
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_sync_keys findUniqueOrThrow
   */
  export type whatsmeow_app_state_sync_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_sync_keys to fetch.
     */
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_sync_keys findFirst
   */
  export type whatsmeow_app_state_sync_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_sync_keys to fetch.
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_sync_keys to fetch.
     */
    orderBy?: whatsmeow_app_state_sync_keysOrderByWithRelationInput | whatsmeow_app_state_sync_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_app_state_sync_keys.
     */
    cursor?: whatsmeow_app_state_sync_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_sync_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_sync_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_app_state_sync_keys.
     */
    distinct?: Whatsmeow_app_state_sync_keysScalarFieldEnum | Whatsmeow_app_state_sync_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_sync_keys findFirstOrThrow
   */
  export type whatsmeow_app_state_sync_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_sync_keys to fetch.
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_sync_keys to fetch.
     */
    orderBy?: whatsmeow_app_state_sync_keysOrderByWithRelationInput | whatsmeow_app_state_sync_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_app_state_sync_keys.
     */
    cursor?: whatsmeow_app_state_sync_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_sync_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_sync_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_app_state_sync_keys.
     */
    distinct?: Whatsmeow_app_state_sync_keysScalarFieldEnum | Whatsmeow_app_state_sync_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_sync_keys findMany
   */
  export type whatsmeow_app_state_sync_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_sync_keys to fetch.
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_sync_keys to fetch.
     */
    orderBy?: whatsmeow_app_state_sync_keysOrderByWithRelationInput | whatsmeow_app_state_sync_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_app_state_sync_keys.
     */
    cursor?: whatsmeow_app_state_sync_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_sync_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_sync_keys.
     */
    skip?: number
    distinct?: Whatsmeow_app_state_sync_keysScalarFieldEnum | Whatsmeow_app_state_sync_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_sync_keys create
   */
  export type whatsmeow_app_state_sync_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_app_state_sync_keys.
     */
    data: XOR<whatsmeow_app_state_sync_keysCreateInput, whatsmeow_app_state_sync_keysUncheckedCreateInput>
  }

  /**
   * whatsmeow_app_state_sync_keys createMany
   */
  export type whatsmeow_app_state_sync_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_app_state_sync_keys.
     */
    data: whatsmeow_app_state_sync_keysCreateManyInput | whatsmeow_app_state_sync_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_app_state_sync_keys createManyAndReturn
   */
  export type whatsmeow_app_state_sync_keysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_app_state_sync_keys.
     */
    data: whatsmeow_app_state_sync_keysCreateManyInput | whatsmeow_app_state_sync_keysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_app_state_sync_keys update
   */
  export type whatsmeow_app_state_sync_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_app_state_sync_keys.
     */
    data: XOR<whatsmeow_app_state_sync_keysUpdateInput, whatsmeow_app_state_sync_keysUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_app_state_sync_keys to update.
     */
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_sync_keys updateMany
   */
  export type whatsmeow_app_state_sync_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_app_state_sync_keys.
     */
    data: XOR<whatsmeow_app_state_sync_keysUpdateManyMutationInput, whatsmeow_app_state_sync_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_app_state_sync_keys to update
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
  }

  /**
   * whatsmeow_app_state_sync_keys updateManyAndReturn
   */
  export type whatsmeow_app_state_sync_keysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_app_state_sync_keys.
     */
    data: XOR<whatsmeow_app_state_sync_keysUpdateManyMutationInput, whatsmeow_app_state_sync_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_app_state_sync_keys to update
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_app_state_sync_keys upsert
   */
  export type whatsmeow_app_state_sync_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_app_state_sync_keys to update in case it exists.
     */
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
    /**
     * In case the whatsmeow_app_state_sync_keys found by the `where` argument doesn't exist, create a new whatsmeow_app_state_sync_keys with this data.
     */
    create: XOR<whatsmeow_app_state_sync_keysCreateInput, whatsmeow_app_state_sync_keysUncheckedCreateInput>
    /**
     * In case the whatsmeow_app_state_sync_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_app_state_sync_keysUpdateInput, whatsmeow_app_state_sync_keysUncheckedUpdateInput>
  }

  /**
   * whatsmeow_app_state_sync_keys delete
   */
  export type whatsmeow_app_state_sync_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_app_state_sync_keys to delete.
     */
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_sync_keys deleteMany
   */
  export type whatsmeow_app_state_sync_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_app_state_sync_keys to delete
     */
    where?: whatsmeow_app_state_sync_keysWhereInput
  }

  /**
   * whatsmeow_app_state_sync_keys without action
   */
  export type whatsmeow_app_state_sync_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_app_state_version
   */

  export type AggregateWhatsmeow_app_state_version = {
    _count: Whatsmeow_app_state_versionCountAggregateOutputType | null
    _avg: Whatsmeow_app_state_versionAvgAggregateOutputType | null
    _sum: Whatsmeow_app_state_versionSumAggregateOutputType | null
    _min: Whatsmeow_app_state_versionMinAggregateOutputType | null
    _max: Whatsmeow_app_state_versionMaxAggregateOutputType | null
  }

  export type Whatsmeow_app_state_versionAvgAggregateOutputType = {
    version: number | null
  }

  export type Whatsmeow_app_state_versionSumAggregateOutputType = {
    version: bigint | null
  }

  export type Whatsmeow_app_state_versionMinAggregateOutputType = {
    jid: string | null
    name: string | null
    version: bigint | null
    hash: Uint8Array | null
  }

  export type Whatsmeow_app_state_versionMaxAggregateOutputType = {
    jid: string | null
    name: string | null
    version: bigint | null
    hash: Uint8Array | null
  }

  export type Whatsmeow_app_state_versionCountAggregateOutputType = {
    jid: number
    name: number
    version: number
    hash: number
    _all: number
  }


  export type Whatsmeow_app_state_versionAvgAggregateInputType = {
    version?: true
  }

  export type Whatsmeow_app_state_versionSumAggregateInputType = {
    version?: true
  }

  export type Whatsmeow_app_state_versionMinAggregateInputType = {
    jid?: true
    name?: true
    version?: true
    hash?: true
  }

  export type Whatsmeow_app_state_versionMaxAggregateInputType = {
    jid?: true
    name?: true
    version?: true
    hash?: true
  }

  export type Whatsmeow_app_state_versionCountAggregateInputType = {
    jid?: true
    name?: true
    version?: true
    hash?: true
    _all?: true
  }

  export type Whatsmeow_app_state_versionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_app_state_version to aggregate.
     */
    where?: whatsmeow_app_state_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_versions to fetch.
     */
    orderBy?: whatsmeow_app_state_versionOrderByWithRelationInput | whatsmeow_app_state_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_app_state_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_app_state_versions
    **/
    _count?: true | Whatsmeow_app_state_versionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_app_state_versionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_app_state_versionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_app_state_versionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_app_state_versionMaxAggregateInputType
  }

  export type GetWhatsmeow_app_state_versionAggregateType<T extends Whatsmeow_app_state_versionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_app_state_version]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_app_state_version[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_app_state_version[P]>
  }




  export type whatsmeow_app_state_versionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_app_state_versionWhereInput
    orderBy?: whatsmeow_app_state_versionOrderByWithAggregationInput | whatsmeow_app_state_versionOrderByWithAggregationInput[]
    by: Whatsmeow_app_state_versionScalarFieldEnum[] | Whatsmeow_app_state_versionScalarFieldEnum
    having?: whatsmeow_app_state_versionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_app_state_versionCountAggregateInputType | true
    _avg?: Whatsmeow_app_state_versionAvgAggregateInputType
    _sum?: Whatsmeow_app_state_versionSumAggregateInputType
    _min?: Whatsmeow_app_state_versionMinAggregateInputType
    _max?: Whatsmeow_app_state_versionMaxAggregateInputType
  }

  export type Whatsmeow_app_state_versionGroupByOutputType = {
    jid: string
    name: string
    version: bigint
    hash: Uint8Array
    _count: Whatsmeow_app_state_versionCountAggregateOutputType | null
    _avg: Whatsmeow_app_state_versionAvgAggregateOutputType | null
    _sum: Whatsmeow_app_state_versionSumAggregateOutputType | null
    _min: Whatsmeow_app_state_versionMinAggregateOutputType | null
    _max: Whatsmeow_app_state_versionMaxAggregateOutputType | null
  }

  type GetWhatsmeow_app_state_versionGroupByPayload<T extends whatsmeow_app_state_versionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_app_state_versionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_app_state_versionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_app_state_versionGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_app_state_versionGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_app_state_versionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    name?: boolean
    version?: boolean
    hash?: boolean
    whatsmeow_app_state_mutation_macs?: boolean | whatsmeow_app_state_version$whatsmeow_app_state_mutation_macsArgs<ExtArgs>
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
    _count?: boolean | Whatsmeow_app_state_versionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_version"]>

  export type whatsmeow_app_state_versionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    name?: boolean
    version?: boolean
    hash?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_version"]>

  export type whatsmeow_app_state_versionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    name?: boolean
    version?: boolean
    hash?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_app_state_version"]>

  export type whatsmeow_app_state_versionSelectScalar = {
    jid?: boolean
    name?: boolean
    version?: boolean
    hash?: boolean
  }

  export type whatsmeow_app_state_versionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jid" | "name" | "version" | "hash", ExtArgs["result"]["whatsmeow_app_state_version"]>
  export type whatsmeow_app_state_versionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_mutation_macs?: boolean | whatsmeow_app_state_version$whatsmeow_app_state_mutation_macsArgs<ExtArgs>
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
    _count?: boolean | Whatsmeow_app_state_versionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type whatsmeow_app_state_versionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_app_state_versionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_app_state_versionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_app_state_version"
    objects: {
      whatsmeow_app_state_mutation_macs: Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>[]
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jid: string
      name: string
      version: bigint
      hash: Uint8Array
    }, ExtArgs["result"]["whatsmeow_app_state_version"]>
    composites: {}
  }

  type whatsmeow_app_state_versionGetPayload<S extends boolean | null | undefined | whatsmeow_app_state_versionDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload, S>

  type whatsmeow_app_state_versionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_app_state_versionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_app_state_versionCountAggregateInputType | true
    }

  export interface whatsmeow_app_state_versionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_app_state_version'], meta: { name: 'whatsmeow_app_state_version' } }
    /**
     * Find zero or one Whatsmeow_app_state_version that matches the filter.
     * @param {whatsmeow_app_state_versionFindUniqueArgs} args - Arguments to find a Whatsmeow_app_state_version
     * @example
     * // Get one Whatsmeow_app_state_version
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_app_state_versionFindUniqueArgs>(args: SelectSubset<T, whatsmeow_app_state_versionFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_app_state_version that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_app_state_versionFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_app_state_version
     * @example
     * // Get one Whatsmeow_app_state_version
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_app_state_versionFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_app_state_versionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_app_state_version that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_versionFindFirstArgs} args - Arguments to find a Whatsmeow_app_state_version
     * @example
     * // Get one Whatsmeow_app_state_version
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_app_state_versionFindFirstArgs>(args?: SelectSubset<T, whatsmeow_app_state_versionFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_app_state_version that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_versionFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_app_state_version
     * @example
     * // Get one Whatsmeow_app_state_version
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_app_state_versionFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_app_state_versionFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_app_state_versions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_versionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_app_state_versions
     * const whatsmeow_app_state_versions = await prisma.whatsmeow_app_state_version.findMany()
     * 
     * // Get first 10 Whatsmeow_app_state_versions
     * const whatsmeow_app_state_versions = await prisma.whatsmeow_app_state_version.findMany({ take: 10 })
     * 
     * // Only select the `jid`
     * const whatsmeow_app_state_versionWithJidOnly = await prisma.whatsmeow_app_state_version.findMany({ select: { jid: true } })
     * 
     */
    findMany<T extends whatsmeow_app_state_versionFindManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_versionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_app_state_version.
     * @param {whatsmeow_app_state_versionCreateArgs} args - Arguments to create a Whatsmeow_app_state_version.
     * @example
     * // Create one Whatsmeow_app_state_version
     * const Whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.create({
     *   data: {
     *     // ... data to create a Whatsmeow_app_state_version
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_app_state_versionCreateArgs>(args: SelectSubset<T, whatsmeow_app_state_versionCreateArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_app_state_versions.
     * @param {whatsmeow_app_state_versionCreateManyArgs} args - Arguments to create many Whatsmeow_app_state_versions.
     * @example
     * // Create many Whatsmeow_app_state_versions
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_app_state_versionCreateManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_versionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_app_state_versions and returns the data saved in the database.
     * @param {whatsmeow_app_state_versionCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_app_state_versions.
     * @example
     * // Create many Whatsmeow_app_state_versions
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_app_state_versions and only return the `jid`
     * const whatsmeow_app_state_versionWithJidOnly = await prisma.whatsmeow_app_state_version.createManyAndReturn({
     *   select: { jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_app_state_versionCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_app_state_versionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_app_state_version.
     * @param {whatsmeow_app_state_versionDeleteArgs} args - Arguments to delete one Whatsmeow_app_state_version.
     * @example
     * // Delete one Whatsmeow_app_state_version
     * const Whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_app_state_version
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_app_state_versionDeleteArgs>(args: SelectSubset<T, whatsmeow_app_state_versionDeleteArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_app_state_version.
     * @param {whatsmeow_app_state_versionUpdateArgs} args - Arguments to update one Whatsmeow_app_state_version.
     * @example
     * // Update one Whatsmeow_app_state_version
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_app_state_versionUpdateArgs>(args: SelectSubset<T, whatsmeow_app_state_versionUpdateArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_app_state_versions.
     * @param {whatsmeow_app_state_versionDeleteManyArgs} args - Arguments to filter Whatsmeow_app_state_versions to delete.
     * @example
     * // Delete a few Whatsmeow_app_state_versions
     * const { count } = await prisma.whatsmeow_app_state_version.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_app_state_versionDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_app_state_versionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_app_state_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_versionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_app_state_versions
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_app_state_versionUpdateManyArgs>(args: SelectSubset<T, whatsmeow_app_state_versionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_app_state_versions and returns the data updated in the database.
     * @param {whatsmeow_app_state_versionUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_app_state_versions.
     * @example
     * // Update many Whatsmeow_app_state_versions
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_app_state_versions and only return the `jid`
     * const whatsmeow_app_state_versionWithJidOnly = await prisma.whatsmeow_app_state_version.updateManyAndReturn({
     *   select: { jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_app_state_versionUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_app_state_versionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_app_state_version.
     * @param {whatsmeow_app_state_versionUpsertArgs} args - Arguments to update or create a Whatsmeow_app_state_version.
     * @example
     * // Update or create a Whatsmeow_app_state_version
     * const whatsmeow_app_state_version = await prisma.whatsmeow_app_state_version.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_app_state_version
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_app_state_version we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_app_state_versionUpsertArgs>(args: SelectSubset<T, whatsmeow_app_state_versionUpsertArgs<ExtArgs>>): Prisma__whatsmeow_app_state_versionClient<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_app_state_versions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_versionCountArgs} args - Arguments to filter Whatsmeow_app_state_versions to count.
     * @example
     * // Count the number of Whatsmeow_app_state_versions
     * const count = await prisma.whatsmeow_app_state_version.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_app_state_versions we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_app_state_versionCountArgs>(
      args?: Subset<T, whatsmeow_app_state_versionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_app_state_versionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_app_state_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_app_state_versionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_app_state_versionAggregateArgs>(args: Subset<T, Whatsmeow_app_state_versionAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_app_state_versionAggregateType<T>>

    /**
     * Group by Whatsmeow_app_state_version.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_app_state_versionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_app_state_versionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_app_state_versionGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_app_state_versionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_app_state_versionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_app_state_versionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_app_state_version model
   */
  readonly fields: whatsmeow_app_state_versionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_app_state_version.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_app_state_versionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_app_state_mutation_macs<T extends whatsmeow_app_state_version$whatsmeow_app_state_mutation_macsArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_app_state_version$whatsmeow_app_state_mutation_macsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_mutation_macsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_app_state_version model
   */ 
  interface whatsmeow_app_state_versionFieldRefs {
    readonly jid: FieldRef<"whatsmeow_app_state_version", 'String'>
    readonly name: FieldRef<"whatsmeow_app_state_version", 'String'>
    readonly version: FieldRef<"whatsmeow_app_state_version", 'BigInt'>
    readonly hash: FieldRef<"whatsmeow_app_state_version", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_app_state_version findUnique
   */
  export type whatsmeow_app_state_versionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_version to fetch.
     */
    where: whatsmeow_app_state_versionWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_version findUniqueOrThrow
   */
  export type whatsmeow_app_state_versionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_version to fetch.
     */
    where: whatsmeow_app_state_versionWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_version findFirst
   */
  export type whatsmeow_app_state_versionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_version to fetch.
     */
    where?: whatsmeow_app_state_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_versions to fetch.
     */
    orderBy?: whatsmeow_app_state_versionOrderByWithRelationInput | whatsmeow_app_state_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_app_state_versions.
     */
    cursor?: whatsmeow_app_state_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_app_state_versions.
     */
    distinct?: Whatsmeow_app_state_versionScalarFieldEnum | Whatsmeow_app_state_versionScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_version findFirstOrThrow
   */
  export type whatsmeow_app_state_versionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_version to fetch.
     */
    where?: whatsmeow_app_state_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_versions to fetch.
     */
    orderBy?: whatsmeow_app_state_versionOrderByWithRelationInput | whatsmeow_app_state_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_app_state_versions.
     */
    cursor?: whatsmeow_app_state_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_versions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_app_state_versions.
     */
    distinct?: Whatsmeow_app_state_versionScalarFieldEnum | Whatsmeow_app_state_versionScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_version findMany
   */
  export type whatsmeow_app_state_versionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_app_state_versions to fetch.
     */
    where?: whatsmeow_app_state_versionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_app_state_versions to fetch.
     */
    orderBy?: whatsmeow_app_state_versionOrderByWithRelationInput | whatsmeow_app_state_versionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_app_state_versions.
     */
    cursor?: whatsmeow_app_state_versionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_app_state_versions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_app_state_versions.
     */
    skip?: number
    distinct?: Whatsmeow_app_state_versionScalarFieldEnum | Whatsmeow_app_state_versionScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_version create
   */
  export type whatsmeow_app_state_versionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_app_state_version.
     */
    data: XOR<whatsmeow_app_state_versionCreateInput, whatsmeow_app_state_versionUncheckedCreateInput>
  }

  /**
   * whatsmeow_app_state_version createMany
   */
  export type whatsmeow_app_state_versionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_app_state_versions.
     */
    data: whatsmeow_app_state_versionCreateManyInput | whatsmeow_app_state_versionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_app_state_version createManyAndReturn
   */
  export type whatsmeow_app_state_versionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_app_state_versions.
     */
    data: whatsmeow_app_state_versionCreateManyInput | whatsmeow_app_state_versionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_app_state_version update
   */
  export type whatsmeow_app_state_versionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_app_state_version.
     */
    data: XOR<whatsmeow_app_state_versionUpdateInput, whatsmeow_app_state_versionUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_app_state_version to update.
     */
    where: whatsmeow_app_state_versionWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_version updateMany
   */
  export type whatsmeow_app_state_versionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_app_state_versions.
     */
    data: XOR<whatsmeow_app_state_versionUpdateManyMutationInput, whatsmeow_app_state_versionUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_app_state_versions to update
     */
    where?: whatsmeow_app_state_versionWhereInput
  }

  /**
   * whatsmeow_app_state_version updateManyAndReturn
   */
  export type whatsmeow_app_state_versionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_app_state_versions.
     */
    data: XOR<whatsmeow_app_state_versionUpdateManyMutationInput, whatsmeow_app_state_versionUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_app_state_versions to update
     */
    where?: whatsmeow_app_state_versionWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_app_state_version upsert
   */
  export type whatsmeow_app_state_versionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_app_state_version to update in case it exists.
     */
    where: whatsmeow_app_state_versionWhereUniqueInput
    /**
     * In case the whatsmeow_app_state_version found by the `where` argument doesn't exist, create a new whatsmeow_app_state_version with this data.
     */
    create: XOR<whatsmeow_app_state_versionCreateInput, whatsmeow_app_state_versionUncheckedCreateInput>
    /**
     * In case the whatsmeow_app_state_version was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_app_state_versionUpdateInput, whatsmeow_app_state_versionUncheckedUpdateInput>
  }

  /**
   * whatsmeow_app_state_version delete
   */
  export type whatsmeow_app_state_versionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_app_state_version to delete.
     */
    where: whatsmeow_app_state_versionWhereUniqueInput
  }

  /**
   * whatsmeow_app_state_version deleteMany
   */
  export type whatsmeow_app_state_versionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_app_state_versions to delete
     */
    where?: whatsmeow_app_state_versionWhereInput
  }

  /**
   * whatsmeow_app_state_version.whatsmeow_app_state_mutation_macs
   */
  export type whatsmeow_app_state_version$whatsmeow_app_state_mutation_macsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_mutation_macs
     */
    select?: whatsmeow_app_state_mutation_macsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_mutation_macs
     */
    omit?: whatsmeow_app_state_mutation_macsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_mutation_macsInclude<ExtArgs> | null
    where?: whatsmeow_app_state_mutation_macsWhereInput
    orderBy?: whatsmeow_app_state_mutation_macsOrderByWithRelationInput | whatsmeow_app_state_mutation_macsOrderByWithRelationInput[]
    cursor?: whatsmeow_app_state_mutation_macsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_app_state_mutation_macsScalarFieldEnum | Whatsmeow_app_state_mutation_macsScalarFieldEnum[]
  }

  /**
   * whatsmeow_app_state_version without action
   */
  export type whatsmeow_app_state_versionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_chat_settings
   */

  export type AggregateWhatsmeow_chat_settings = {
    _count: Whatsmeow_chat_settingsCountAggregateOutputType | null
    _avg: Whatsmeow_chat_settingsAvgAggregateOutputType | null
    _sum: Whatsmeow_chat_settingsSumAggregateOutputType | null
    _min: Whatsmeow_chat_settingsMinAggregateOutputType | null
    _max: Whatsmeow_chat_settingsMaxAggregateOutputType | null
  }

  export type Whatsmeow_chat_settingsAvgAggregateOutputType = {
    muted_until: number | null
  }

  export type Whatsmeow_chat_settingsSumAggregateOutputType = {
    muted_until: bigint | null
  }

  export type Whatsmeow_chat_settingsMinAggregateOutputType = {
    our_jid: string | null
    chat_jid: string | null
    muted_until: bigint | null
    pinned: boolean | null
    archived: boolean | null
  }

  export type Whatsmeow_chat_settingsMaxAggregateOutputType = {
    our_jid: string | null
    chat_jid: string | null
    muted_until: bigint | null
    pinned: boolean | null
    archived: boolean | null
  }

  export type Whatsmeow_chat_settingsCountAggregateOutputType = {
    our_jid: number
    chat_jid: number
    muted_until: number
    pinned: number
    archived: number
    _all: number
  }


  export type Whatsmeow_chat_settingsAvgAggregateInputType = {
    muted_until?: true
  }

  export type Whatsmeow_chat_settingsSumAggregateInputType = {
    muted_until?: true
  }

  export type Whatsmeow_chat_settingsMinAggregateInputType = {
    our_jid?: true
    chat_jid?: true
    muted_until?: true
    pinned?: true
    archived?: true
  }

  export type Whatsmeow_chat_settingsMaxAggregateInputType = {
    our_jid?: true
    chat_jid?: true
    muted_until?: true
    pinned?: true
    archived?: true
  }

  export type Whatsmeow_chat_settingsCountAggregateInputType = {
    our_jid?: true
    chat_jid?: true
    muted_until?: true
    pinned?: true
    archived?: true
    _all?: true
  }

  export type Whatsmeow_chat_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_chat_settings to aggregate.
     */
    where?: whatsmeow_chat_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_chat_settings to fetch.
     */
    orderBy?: whatsmeow_chat_settingsOrderByWithRelationInput | whatsmeow_chat_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_chat_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_chat_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_chat_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_chat_settings
    **/
    _count?: true | Whatsmeow_chat_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_chat_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_chat_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_chat_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_chat_settingsMaxAggregateInputType
  }

  export type GetWhatsmeow_chat_settingsAggregateType<T extends Whatsmeow_chat_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_chat_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_chat_settings[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_chat_settings[P]>
  }




  export type whatsmeow_chat_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_chat_settingsWhereInput
    orderBy?: whatsmeow_chat_settingsOrderByWithAggregationInput | whatsmeow_chat_settingsOrderByWithAggregationInput[]
    by: Whatsmeow_chat_settingsScalarFieldEnum[] | Whatsmeow_chat_settingsScalarFieldEnum
    having?: whatsmeow_chat_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_chat_settingsCountAggregateInputType | true
    _avg?: Whatsmeow_chat_settingsAvgAggregateInputType
    _sum?: Whatsmeow_chat_settingsSumAggregateInputType
    _min?: Whatsmeow_chat_settingsMinAggregateInputType
    _max?: Whatsmeow_chat_settingsMaxAggregateInputType
  }

  export type Whatsmeow_chat_settingsGroupByOutputType = {
    our_jid: string
    chat_jid: string
    muted_until: bigint
    pinned: boolean
    archived: boolean
    _count: Whatsmeow_chat_settingsCountAggregateOutputType | null
    _avg: Whatsmeow_chat_settingsAvgAggregateOutputType | null
    _sum: Whatsmeow_chat_settingsSumAggregateOutputType | null
    _min: Whatsmeow_chat_settingsMinAggregateOutputType | null
    _max: Whatsmeow_chat_settingsMaxAggregateOutputType | null
  }

  type GetWhatsmeow_chat_settingsGroupByPayload<T extends whatsmeow_chat_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_chat_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_chat_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_chat_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_chat_settingsGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_chat_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_jid?: boolean
    muted_until?: boolean
    pinned?: boolean
    archived?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_chat_settings"]>

  export type whatsmeow_chat_settingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_jid?: boolean
    muted_until?: boolean
    pinned?: boolean
    archived?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_chat_settings"]>

  export type whatsmeow_chat_settingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_jid?: boolean
    muted_until?: boolean
    pinned?: boolean
    archived?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_chat_settings"]>

  export type whatsmeow_chat_settingsSelectScalar = {
    our_jid?: boolean
    chat_jid?: boolean
    muted_until?: boolean
    pinned?: boolean
    archived?: boolean
  }

  export type whatsmeow_chat_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "chat_jid" | "muted_until" | "pinned" | "archived", ExtArgs["result"]["whatsmeow_chat_settings"]>
  export type whatsmeow_chat_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_chat_settingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_chat_settingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_chat_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_chat_settings"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      chat_jid: string
      muted_until: bigint
      pinned: boolean
      archived: boolean
    }, ExtArgs["result"]["whatsmeow_chat_settings"]>
    composites: {}
  }

  type whatsmeow_chat_settingsGetPayload<S extends boolean | null | undefined | whatsmeow_chat_settingsDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload, S>

  type whatsmeow_chat_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_chat_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_chat_settingsCountAggregateInputType | true
    }

  export interface whatsmeow_chat_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_chat_settings'], meta: { name: 'whatsmeow_chat_settings' } }
    /**
     * Find zero or one Whatsmeow_chat_settings that matches the filter.
     * @param {whatsmeow_chat_settingsFindUniqueArgs} args - Arguments to find a Whatsmeow_chat_settings
     * @example
     * // Get one Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_chat_settingsFindUniqueArgs>(args: SelectSubset<T, whatsmeow_chat_settingsFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_chat_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_chat_settingsFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_chat_settings
     * @example
     * // Get one Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_chat_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_chat_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_chat_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_chat_settingsFindFirstArgs} args - Arguments to find a Whatsmeow_chat_settings
     * @example
     * // Get one Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_chat_settingsFindFirstArgs>(args?: SelectSubset<T, whatsmeow_chat_settingsFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_chat_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_chat_settingsFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_chat_settings
     * @example
     * // Get one Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_chat_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_chat_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_chat_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_chat_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findMany()
     * 
     * // Get first 10 Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_chat_settingsWithOur_jidOnly = await prisma.whatsmeow_chat_settings.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_chat_settingsFindManyArgs>(args?: SelectSubset<T, whatsmeow_chat_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_chat_settings.
     * @param {whatsmeow_chat_settingsCreateArgs} args - Arguments to create a Whatsmeow_chat_settings.
     * @example
     * // Create one Whatsmeow_chat_settings
     * const Whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.create({
     *   data: {
     *     // ... data to create a Whatsmeow_chat_settings
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_chat_settingsCreateArgs>(args: SelectSubset<T, whatsmeow_chat_settingsCreateArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_chat_settings.
     * @param {whatsmeow_chat_settingsCreateManyArgs} args - Arguments to create many Whatsmeow_chat_settings.
     * @example
     * // Create many Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_chat_settingsCreateManyArgs>(args?: SelectSubset<T, whatsmeow_chat_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_chat_settings and returns the data saved in the database.
     * @param {whatsmeow_chat_settingsCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_chat_settings.
     * @example
     * // Create many Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_chat_settings and only return the `our_jid`
     * const whatsmeow_chat_settingsWithOur_jidOnly = await prisma.whatsmeow_chat_settings.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_chat_settingsCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_chat_settingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_chat_settings.
     * @param {whatsmeow_chat_settingsDeleteArgs} args - Arguments to delete one Whatsmeow_chat_settings.
     * @example
     * // Delete one Whatsmeow_chat_settings
     * const Whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_chat_settings
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_chat_settingsDeleteArgs>(args: SelectSubset<T, whatsmeow_chat_settingsDeleteArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_chat_settings.
     * @param {whatsmeow_chat_settingsUpdateArgs} args - Arguments to update one Whatsmeow_chat_settings.
     * @example
     * // Update one Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_chat_settingsUpdateArgs>(args: SelectSubset<T, whatsmeow_chat_settingsUpdateArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_chat_settings.
     * @param {whatsmeow_chat_settingsDeleteManyArgs} args - Arguments to filter Whatsmeow_chat_settings to delete.
     * @example
     * // Delete a few Whatsmeow_chat_settings
     * const { count } = await prisma.whatsmeow_chat_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_chat_settingsDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_chat_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_chat_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_chat_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_chat_settingsUpdateManyArgs>(args: SelectSubset<T, whatsmeow_chat_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_chat_settings and returns the data updated in the database.
     * @param {whatsmeow_chat_settingsUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_chat_settings.
     * @example
     * // Update many Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_chat_settings and only return the `our_jid`
     * const whatsmeow_chat_settingsWithOur_jidOnly = await prisma.whatsmeow_chat_settings.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_chat_settingsUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_chat_settingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_chat_settings.
     * @param {whatsmeow_chat_settingsUpsertArgs} args - Arguments to update or create a Whatsmeow_chat_settings.
     * @example
     * // Update or create a Whatsmeow_chat_settings
     * const whatsmeow_chat_settings = await prisma.whatsmeow_chat_settings.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_chat_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_chat_settings we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_chat_settingsUpsertArgs>(args: SelectSubset<T, whatsmeow_chat_settingsUpsertArgs<ExtArgs>>): Prisma__whatsmeow_chat_settingsClient<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_chat_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_chat_settingsCountArgs} args - Arguments to filter Whatsmeow_chat_settings to count.
     * @example
     * // Count the number of Whatsmeow_chat_settings
     * const count = await prisma.whatsmeow_chat_settings.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_chat_settings we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_chat_settingsCountArgs>(
      args?: Subset<T, whatsmeow_chat_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_chat_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_chat_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_chat_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_chat_settingsAggregateArgs>(args: Subset<T, Whatsmeow_chat_settingsAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_chat_settingsAggregateType<T>>

    /**
     * Group by Whatsmeow_chat_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_chat_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_chat_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_chat_settingsGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_chat_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_chat_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_chat_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_chat_settings model
   */
  readonly fields: whatsmeow_chat_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_chat_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_chat_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_chat_settings model
   */ 
  interface whatsmeow_chat_settingsFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_chat_settings", 'String'>
    readonly chat_jid: FieldRef<"whatsmeow_chat_settings", 'String'>
    readonly muted_until: FieldRef<"whatsmeow_chat_settings", 'BigInt'>
    readonly pinned: FieldRef<"whatsmeow_chat_settings", 'Boolean'>
    readonly archived: FieldRef<"whatsmeow_chat_settings", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_chat_settings findUnique
   */
  export type whatsmeow_chat_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_chat_settings to fetch.
     */
    where: whatsmeow_chat_settingsWhereUniqueInput
  }

  /**
   * whatsmeow_chat_settings findUniqueOrThrow
   */
  export type whatsmeow_chat_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_chat_settings to fetch.
     */
    where: whatsmeow_chat_settingsWhereUniqueInput
  }

  /**
   * whatsmeow_chat_settings findFirst
   */
  export type whatsmeow_chat_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_chat_settings to fetch.
     */
    where?: whatsmeow_chat_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_chat_settings to fetch.
     */
    orderBy?: whatsmeow_chat_settingsOrderByWithRelationInput | whatsmeow_chat_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_chat_settings.
     */
    cursor?: whatsmeow_chat_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_chat_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_chat_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_chat_settings.
     */
    distinct?: Whatsmeow_chat_settingsScalarFieldEnum | Whatsmeow_chat_settingsScalarFieldEnum[]
  }

  /**
   * whatsmeow_chat_settings findFirstOrThrow
   */
  export type whatsmeow_chat_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_chat_settings to fetch.
     */
    where?: whatsmeow_chat_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_chat_settings to fetch.
     */
    orderBy?: whatsmeow_chat_settingsOrderByWithRelationInput | whatsmeow_chat_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_chat_settings.
     */
    cursor?: whatsmeow_chat_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_chat_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_chat_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_chat_settings.
     */
    distinct?: Whatsmeow_chat_settingsScalarFieldEnum | Whatsmeow_chat_settingsScalarFieldEnum[]
  }

  /**
   * whatsmeow_chat_settings findMany
   */
  export type whatsmeow_chat_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_chat_settings to fetch.
     */
    where?: whatsmeow_chat_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_chat_settings to fetch.
     */
    orderBy?: whatsmeow_chat_settingsOrderByWithRelationInput | whatsmeow_chat_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_chat_settings.
     */
    cursor?: whatsmeow_chat_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_chat_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_chat_settings.
     */
    skip?: number
    distinct?: Whatsmeow_chat_settingsScalarFieldEnum | Whatsmeow_chat_settingsScalarFieldEnum[]
  }

  /**
   * whatsmeow_chat_settings create
   */
  export type whatsmeow_chat_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_chat_settings.
     */
    data: XOR<whatsmeow_chat_settingsCreateInput, whatsmeow_chat_settingsUncheckedCreateInput>
  }

  /**
   * whatsmeow_chat_settings createMany
   */
  export type whatsmeow_chat_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_chat_settings.
     */
    data: whatsmeow_chat_settingsCreateManyInput | whatsmeow_chat_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_chat_settings createManyAndReturn
   */
  export type whatsmeow_chat_settingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_chat_settings.
     */
    data: whatsmeow_chat_settingsCreateManyInput | whatsmeow_chat_settingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_chat_settings update
   */
  export type whatsmeow_chat_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_chat_settings.
     */
    data: XOR<whatsmeow_chat_settingsUpdateInput, whatsmeow_chat_settingsUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_chat_settings to update.
     */
    where: whatsmeow_chat_settingsWhereUniqueInput
  }

  /**
   * whatsmeow_chat_settings updateMany
   */
  export type whatsmeow_chat_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_chat_settings.
     */
    data: XOR<whatsmeow_chat_settingsUpdateManyMutationInput, whatsmeow_chat_settingsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_chat_settings to update
     */
    where?: whatsmeow_chat_settingsWhereInput
  }

  /**
   * whatsmeow_chat_settings updateManyAndReturn
   */
  export type whatsmeow_chat_settingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_chat_settings.
     */
    data: XOR<whatsmeow_chat_settingsUpdateManyMutationInput, whatsmeow_chat_settingsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_chat_settings to update
     */
    where?: whatsmeow_chat_settingsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_chat_settings upsert
   */
  export type whatsmeow_chat_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_chat_settings to update in case it exists.
     */
    where: whatsmeow_chat_settingsWhereUniqueInput
    /**
     * In case the whatsmeow_chat_settings found by the `where` argument doesn't exist, create a new whatsmeow_chat_settings with this data.
     */
    create: XOR<whatsmeow_chat_settingsCreateInput, whatsmeow_chat_settingsUncheckedCreateInput>
    /**
     * In case the whatsmeow_chat_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_chat_settingsUpdateInput, whatsmeow_chat_settingsUncheckedUpdateInput>
  }

  /**
   * whatsmeow_chat_settings delete
   */
  export type whatsmeow_chat_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_chat_settings to delete.
     */
    where: whatsmeow_chat_settingsWhereUniqueInput
  }

  /**
   * whatsmeow_chat_settings deleteMany
   */
  export type whatsmeow_chat_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_chat_settings to delete
     */
    where?: whatsmeow_chat_settingsWhereInput
  }

  /**
   * whatsmeow_chat_settings without action
   */
  export type whatsmeow_chat_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_contacts
   */

  export type AggregateWhatsmeow_contacts = {
    _count: Whatsmeow_contactsCountAggregateOutputType | null
    _min: Whatsmeow_contactsMinAggregateOutputType | null
    _max: Whatsmeow_contactsMaxAggregateOutputType | null
  }

  export type Whatsmeow_contactsMinAggregateOutputType = {
    our_jid: string | null
    their_jid: string | null
    first_name: string | null
    full_name: string | null
    push_name: string | null
    business_name: string | null
    redacted_phone: string | null
  }

  export type Whatsmeow_contactsMaxAggregateOutputType = {
    our_jid: string | null
    their_jid: string | null
    first_name: string | null
    full_name: string | null
    push_name: string | null
    business_name: string | null
    redacted_phone: string | null
  }

  export type Whatsmeow_contactsCountAggregateOutputType = {
    our_jid: number
    their_jid: number
    first_name: number
    full_name: number
    push_name: number
    business_name: number
    redacted_phone: number
    _all: number
  }


  export type Whatsmeow_contactsMinAggregateInputType = {
    our_jid?: true
    their_jid?: true
    first_name?: true
    full_name?: true
    push_name?: true
    business_name?: true
    redacted_phone?: true
  }

  export type Whatsmeow_contactsMaxAggregateInputType = {
    our_jid?: true
    their_jid?: true
    first_name?: true
    full_name?: true
    push_name?: true
    business_name?: true
    redacted_phone?: true
  }

  export type Whatsmeow_contactsCountAggregateInputType = {
    our_jid?: true
    their_jid?: true
    first_name?: true
    full_name?: true
    push_name?: true
    business_name?: true
    redacted_phone?: true
    _all?: true
  }

  export type Whatsmeow_contactsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_contacts to aggregate.
     */
    where?: whatsmeow_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_contacts to fetch.
     */
    orderBy?: whatsmeow_contactsOrderByWithRelationInput | whatsmeow_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_contacts
    **/
    _count?: true | Whatsmeow_contactsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_contactsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_contactsMaxAggregateInputType
  }

  export type GetWhatsmeow_contactsAggregateType<T extends Whatsmeow_contactsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_contacts]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_contacts[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_contacts[P]>
  }




  export type whatsmeow_contactsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_contactsWhereInput
    orderBy?: whatsmeow_contactsOrderByWithAggregationInput | whatsmeow_contactsOrderByWithAggregationInput[]
    by: Whatsmeow_contactsScalarFieldEnum[] | Whatsmeow_contactsScalarFieldEnum
    having?: whatsmeow_contactsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_contactsCountAggregateInputType | true
    _min?: Whatsmeow_contactsMinAggregateInputType
    _max?: Whatsmeow_contactsMaxAggregateInputType
  }

  export type Whatsmeow_contactsGroupByOutputType = {
    our_jid: string
    their_jid: string
    first_name: string | null
    full_name: string | null
    push_name: string | null
    business_name: string | null
    redacted_phone: string | null
    _count: Whatsmeow_contactsCountAggregateOutputType | null
    _min: Whatsmeow_contactsMinAggregateOutputType | null
    _max: Whatsmeow_contactsMaxAggregateOutputType | null
  }

  type GetWhatsmeow_contactsGroupByPayload<T extends whatsmeow_contactsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_contactsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_contactsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_contactsGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_contactsGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_contactsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_jid?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
    redacted_phone?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_contacts"]>

  export type whatsmeow_contactsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_jid?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
    redacted_phone?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_contacts"]>

  export type whatsmeow_contactsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_jid?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
    redacted_phone?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_contacts"]>

  export type whatsmeow_contactsSelectScalar = {
    our_jid?: boolean
    their_jid?: boolean
    first_name?: boolean
    full_name?: boolean
    push_name?: boolean
    business_name?: boolean
    redacted_phone?: boolean
  }

  export type whatsmeow_contactsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "their_jid" | "first_name" | "full_name" | "push_name" | "business_name" | "redacted_phone", ExtArgs["result"]["whatsmeow_contacts"]>
  export type whatsmeow_contactsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_contactsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_contactsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_contactsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_contacts"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      their_jid: string
      first_name: string | null
      full_name: string | null
      push_name: string | null
      business_name: string | null
      redacted_phone: string | null
    }, ExtArgs["result"]["whatsmeow_contacts"]>
    composites: {}
  }

  type whatsmeow_contactsGetPayload<S extends boolean | null | undefined | whatsmeow_contactsDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_contactsPayload, S>

  type whatsmeow_contactsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_contactsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_contactsCountAggregateInputType | true
    }

  export interface whatsmeow_contactsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_contacts'], meta: { name: 'whatsmeow_contacts' } }
    /**
     * Find zero or one Whatsmeow_contacts that matches the filter.
     * @param {whatsmeow_contactsFindUniqueArgs} args - Arguments to find a Whatsmeow_contacts
     * @example
     * // Get one Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_contactsFindUniqueArgs>(args: SelectSubset<T, whatsmeow_contactsFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_contacts that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_contactsFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_contacts
     * @example
     * // Get one Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_contactsFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_contactsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_contactsFindFirstArgs} args - Arguments to find a Whatsmeow_contacts
     * @example
     * // Get one Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_contactsFindFirstArgs>(args?: SelectSubset<T, whatsmeow_contactsFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_contacts that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_contactsFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_contacts
     * @example
     * // Get one Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_contactsFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_contactsFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_contactsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findMany()
     * 
     * // Get first 10 Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_contactsWithOur_jidOnly = await prisma.whatsmeow_contacts.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_contactsFindManyArgs>(args?: SelectSubset<T, whatsmeow_contactsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_contacts.
     * @param {whatsmeow_contactsCreateArgs} args - Arguments to create a Whatsmeow_contacts.
     * @example
     * // Create one Whatsmeow_contacts
     * const Whatsmeow_contacts = await prisma.whatsmeow_contacts.create({
     *   data: {
     *     // ... data to create a Whatsmeow_contacts
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_contactsCreateArgs>(args: SelectSubset<T, whatsmeow_contactsCreateArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_contacts.
     * @param {whatsmeow_contactsCreateManyArgs} args - Arguments to create many Whatsmeow_contacts.
     * @example
     * // Create many Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_contactsCreateManyArgs>(args?: SelectSubset<T, whatsmeow_contactsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_contacts and returns the data saved in the database.
     * @param {whatsmeow_contactsCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_contacts.
     * @example
     * // Create many Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_contacts and only return the `our_jid`
     * const whatsmeow_contactsWithOur_jidOnly = await prisma.whatsmeow_contacts.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_contactsCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_contactsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_contacts.
     * @param {whatsmeow_contactsDeleteArgs} args - Arguments to delete one Whatsmeow_contacts.
     * @example
     * // Delete one Whatsmeow_contacts
     * const Whatsmeow_contacts = await prisma.whatsmeow_contacts.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_contacts
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_contactsDeleteArgs>(args: SelectSubset<T, whatsmeow_contactsDeleteArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_contacts.
     * @param {whatsmeow_contactsUpdateArgs} args - Arguments to update one Whatsmeow_contacts.
     * @example
     * // Update one Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_contactsUpdateArgs>(args: SelectSubset<T, whatsmeow_contactsUpdateArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_contacts.
     * @param {whatsmeow_contactsDeleteManyArgs} args - Arguments to filter Whatsmeow_contacts to delete.
     * @example
     * // Delete a few Whatsmeow_contacts
     * const { count } = await prisma.whatsmeow_contacts.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_contactsDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_contactsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_contactsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_contactsUpdateManyArgs>(args: SelectSubset<T, whatsmeow_contactsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_contacts and returns the data updated in the database.
     * @param {whatsmeow_contactsUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_contacts.
     * @example
     * // Update many Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_contacts and only return the `our_jid`
     * const whatsmeow_contactsWithOur_jidOnly = await prisma.whatsmeow_contacts.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_contactsUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_contactsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_contacts.
     * @param {whatsmeow_contactsUpsertArgs} args - Arguments to update or create a Whatsmeow_contacts.
     * @example
     * // Update or create a Whatsmeow_contacts
     * const whatsmeow_contacts = await prisma.whatsmeow_contacts.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_contacts
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_contacts we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_contactsUpsertArgs>(args: SelectSubset<T, whatsmeow_contactsUpsertArgs<ExtArgs>>): Prisma__whatsmeow_contactsClient<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_contactsCountArgs} args - Arguments to filter Whatsmeow_contacts to count.
     * @example
     * // Count the number of Whatsmeow_contacts
     * const count = await prisma.whatsmeow_contacts.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_contacts we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_contactsCountArgs>(
      args?: Subset<T, whatsmeow_contactsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_contactsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_contactsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_contactsAggregateArgs>(args: Subset<T, Whatsmeow_contactsAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_contactsAggregateType<T>>

    /**
     * Group by Whatsmeow_contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_contactsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_contactsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_contactsGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_contactsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_contactsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_contactsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_contacts model
   */
  readonly fields: whatsmeow_contactsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_contacts.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_contactsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_contacts model
   */ 
  interface whatsmeow_contactsFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_contacts", 'String'>
    readonly their_jid: FieldRef<"whatsmeow_contacts", 'String'>
    readonly first_name: FieldRef<"whatsmeow_contacts", 'String'>
    readonly full_name: FieldRef<"whatsmeow_contacts", 'String'>
    readonly push_name: FieldRef<"whatsmeow_contacts", 'String'>
    readonly business_name: FieldRef<"whatsmeow_contacts", 'String'>
    readonly redacted_phone: FieldRef<"whatsmeow_contacts", 'String'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_contacts findUnique
   */
  export type whatsmeow_contactsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_contacts to fetch.
     */
    where: whatsmeow_contactsWhereUniqueInput
  }

  /**
   * whatsmeow_contacts findUniqueOrThrow
   */
  export type whatsmeow_contactsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_contacts to fetch.
     */
    where: whatsmeow_contactsWhereUniqueInput
  }

  /**
   * whatsmeow_contacts findFirst
   */
  export type whatsmeow_contactsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_contacts to fetch.
     */
    where?: whatsmeow_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_contacts to fetch.
     */
    orderBy?: whatsmeow_contactsOrderByWithRelationInput | whatsmeow_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_contacts.
     */
    cursor?: whatsmeow_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_contacts.
     */
    distinct?: Whatsmeow_contactsScalarFieldEnum | Whatsmeow_contactsScalarFieldEnum[]
  }

  /**
   * whatsmeow_contacts findFirstOrThrow
   */
  export type whatsmeow_contactsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_contacts to fetch.
     */
    where?: whatsmeow_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_contacts to fetch.
     */
    orderBy?: whatsmeow_contactsOrderByWithRelationInput | whatsmeow_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_contacts.
     */
    cursor?: whatsmeow_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_contacts.
     */
    distinct?: Whatsmeow_contactsScalarFieldEnum | Whatsmeow_contactsScalarFieldEnum[]
  }

  /**
   * whatsmeow_contacts findMany
   */
  export type whatsmeow_contactsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_contacts to fetch.
     */
    where?: whatsmeow_contactsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_contacts to fetch.
     */
    orderBy?: whatsmeow_contactsOrderByWithRelationInput | whatsmeow_contactsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_contacts.
     */
    cursor?: whatsmeow_contactsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_contacts.
     */
    skip?: number
    distinct?: Whatsmeow_contactsScalarFieldEnum | Whatsmeow_contactsScalarFieldEnum[]
  }

  /**
   * whatsmeow_contacts create
   */
  export type whatsmeow_contactsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_contacts.
     */
    data: XOR<whatsmeow_contactsCreateInput, whatsmeow_contactsUncheckedCreateInput>
  }

  /**
   * whatsmeow_contacts createMany
   */
  export type whatsmeow_contactsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_contacts.
     */
    data: whatsmeow_contactsCreateManyInput | whatsmeow_contactsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_contacts createManyAndReturn
   */
  export type whatsmeow_contactsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_contacts.
     */
    data: whatsmeow_contactsCreateManyInput | whatsmeow_contactsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_contacts update
   */
  export type whatsmeow_contactsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_contacts.
     */
    data: XOR<whatsmeow_contactsUpdateInput, whatsmeow_contactsUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_contacts to update.
     */
    where: whatsmeow_contactsWhereUniqueInput
  }

  /**
   * whatsmeow_contacts updateMany
   */
  export type whatsmeow_contactsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_contacts.
     */
    data: XOR<whatsmeow_contactsUpdateManyMutationInput, whatsmeow_contactsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_contacts to update
     */
    where?: whatsmeow_contactsWhereInput
  }

  /**
   * whatsmeow_contacts updateManyAndReturn
   */
  export type whatsmeow_contactsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_contacts.
     */
    data: XOR<whatsmeow_contactsUpdateManyMutationInput, whatsmeow_contactsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_contacts to update
     */
    where?: whatsmeow_contactsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_contacts upsert
   */
  export type whatsmeow_contactsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_contacts to update in case it exists.
     */
    where: whatsmeow_contactsWhereUniqueInput
    /**
     * In case the whatsmeow_contacts found by the `where` argument doesn't exist, create a new whatsmeow_contacts with this data.
     */
    create: XOR<whatsmeow_contactsCreateInput, whatsmeow_contactsUncheckedCreateInput>
    /**
     * In case the whatsmeow_contacts was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_contactsUpdateInput, whatsmeow_contactsUncheckedUpdateInput>
  }

  /**
   * whatsmeow_contacts delete
   */
  export type whatsmeow_contactsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_contacts to delete.
     */
    where: whatsmeow_contactsWhereUniqueInput
  }

  /**
   * whatsmeow_contacts deleteMany
   */
  export type whatsmeow_contactsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_contacts to delete
     */
    where?: whatsmeow_contactsWhereInput
  }

  /**
   * whatsmeow_contacts without action
   */
  export type whatsmeow_contactsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_device
   */

  export type AggregateWhatsmeow_device = {
    _count: Whatsmeow_deviceCountAggregateOutputType | null
    _avg: Whatsmeow_deviceAvgAggregateOutputType | null
    _sum: Whatsmeow_deviceSumAggregateOutputType | null
    _min: Whatsmeow_deviceMinAggregateOutputType | null
    _max: Whatsmeow_deviceMaxAggregateOutputType | null
  }

  export type Whatsmeow_deviceAvgAggregateOutputType = {
    registration_id: number | null
    signed_pre_key_id: number | null
    lid_migration_ts: number | null
  }

  export type Whatsmeow_deviceSumAggregateOutputType = {
    registration_id: bigint | null
    signed_pre_key_id: number | null
    lid_migration_ts: bigint | null
  }

  export type Whatsmeow_deviceMinAggregateOutputType = {
    jid: string | null
    lid: string | null
    facebook_uuid: string | null
    registration_id: bigint | null
    noise_key: Uint8Array | null
    identity_key: Uint8Array | null
    signed_pre_key: Uint8Array | null
    signed_pre_key_id: number | null
    signed_pre_key_sig: Uint8Array | null
    adv_key: Uint8Array | null
    adv_details: Uint8Array | null
    adv_account_sig: Uint8Array | null
    adv_account_sig_key: Uint8Array | null
    adv_device_sig: Uint8Array | null
    platform: string | null
    business_name: string | null
    push_name: string | null
    lid_migration_ts: bigint | null
  }

  export type Whatsmeow_deviceMaxAggregateOutputType = {
    jid: string | null
    lid: string | null
    facebook_uuid: string | null
    registration_id: bigint | null
    noise_key: Uint8Array | null
    identity_key: Uint8Array | null
    signed_pre_key: Uint8Array | null
    signed_pre_key_id: number | null
    signed_pre_key_sig: Uint8Array | null
    adv_key: Uint8Array | null
    adv_details: Uint8Array | null
    adv_account_sig: Uint8Array | null
    adv_account_sig_key: Uint8Array | null
    adv_device_sig: Uint8Array | null
    platform: string | null
    business_name: string | null
    push_name: string | null
    lid_migration_ts: bigint | null
  }

  export type Whatsmeow_deviceCountAggregateOutputType = {
    jid: number
    lid: number
    facebook_uuid: number
    registration_id: number
    noise_key: number
    identity_key: number
    signed_pre_key: number
    signed_pre_key_id: number
    signed_pre_key_sig: number
    adv_key: number
    adv_details: number
    adv_account_sig: number
    adv_account_sig_key: number
    adv_device_sig: number
    platform: number
    business_name: number
    push_name: number
    lid_migration_ts: number
    _all: number
  }


  export type Whatsmeow_deviceAvgAggregateInputType = {
    registration_id?: true
    signed_pre_key_id?: true
    lid_migration_ts?: true
  }

  export type Whatsmeow_deviceSumAggregateInputType = {
    registration_id?: true
    signed_pre_key_id?: true
    lid_migration_ts?: true
  }

  export type Whatsmeow_deviceMinAggregateInputType = {
    jid?: true
    lid?: true
    facebook_uuid?: true
    registration_id?: true
    noise_key?: true
    identity_key?: true
    signed_pre_key?: true
    signed_pre_key_id?: true
    signed_pre_key_sig?: true
    adv_key?: true
    adv_details?: true
    adv_account_sig?: true
    adv_account_sig_key?: true
    adv_device_sig?: true
    platform?: true
    business_name?: true
    push_name?: true
    lid_migration_ts?: true
  }

  export type Whatsmeow_deviceMaxAggregateInputType = {
    jid?: true
    lid?: true
    facebook_uuid?: true
    registration_id?: true
    noise_key?: true
    identity_key?: true
    signed_pre_key?: true
    signed_pre_key_id?: true
    signed_pre_key_sig?: true
    adv_key?: true
    adv_details?: true
    adv_account_sig?: true
    adv_account_sig_key?: true
    adv_device_sig?: true
    platform?: true
    business_name?: true
    push_name?: true
    lid_migration_ts?: true
  }

  export type Whatsmeow_deviceCountAggregateInputType = {
    jid?: true
    lid?: true
    facebook_uuid?: true
    registration_id?: true
    noise_key?: true
    identity_key?: true
    signed_pre_key?: true
    signed_pre_key_id?: true
    signed_pre_key_sig?: true
    adv_key?: true
    adv_details?: true
    adv_account_sig?: true
    adv_account_sig_key?: true
    adv_device_sig?: true
    platform?: true
    business_name?: true
    push_name?: true
    lid_migration_ts?: true
    _all?: true
  }

  export type Whatsmeow_deviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_device to aggregate.
     */
    where?: whatsmeow_deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_devices to fetch.
     */
    orderBy?: whatsmeow_deviceOrderByWithRelationInput | whatsmeow_deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_devices
    **/
    _count?: true | Whatsmeow_deviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_deviceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_deviceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_deviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_deviceMaxAggregateInputType
  }

  export type GetWhatsmeow_deviceAggregateType<T extends Whatsmeow_deviceAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_device]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_device[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_device[P]>
  }




  export type whatsmeow_deviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_deviceWhereInput
    orderBy?: whatsmeow_deviceOrderByWithAggregationInput | whatsmeow_deviceOrderByWithAggregationInput[]
    by: Whatsmeow_deviceScalarFieldEnum[] | Whatsmeow_deviceScalarFieldEnum
    having?: whatsmeow_deviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_deviceCountAggregateInputType | true
    _avg?: Whatsmeow_deviceAvgAggregateInputType
    _sum?: Whatsmeow_deviceSumAggregateInputType
    _min?: Whatsmeow_deviceMinAggregateInputType
    _max?: Whatsmeow_deviceMaxAggregateInputType
  }

  export type Whatsmeow_deviceGroupByOutputType = {
    jid: string
    lid: string | null
    facebook_uuid: string | null
    registration_id: bigint
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform: string
    business_name: string
    push_name: string
    lid_migration_ts: bigint
    _count: Whatsmeow_deviceCountAggregateOutputType | null
    _avg: Whatsmeow_deviceAvgAggregateOutputType | null
    _sum: Whatsmeow_deviceSumAggregateOutputType | null
    _min: Whatsmeow_deviceMinAggregateOutputType | null
    _max: Whatsmeow_deviceMaxAggregateOutputType | null
  }

  type GetWhatsmeow_deviceGroupByPayload<T extends whatsmeow_deviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_deviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_deviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_deviceGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_deviceGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_deviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    lid?: boolean
    facebook_uuid?: boolean
    registration_id?: boolean
    noise_key?: boolean
    identity_key?: boolean
    signed_pre_key?: boolean
    signed_pre_key_id?: boolean
    signed_pre_key_sig?: boolean
    adv_key?: boolean
    adv_details?: boolean
    adv_account_sig?: boolean
    adv_account_sig_key?: boolean
    adv_device_sig?: boolean
    platform?: boolean
    business_name?: boolean
    push_name?: boolean
    lid_migration_ts?: boolean
    whatsmeow_app_state_sync_keys?: boolean | whatsmeow_device$whatsmeow_app_state_sync_keysArgs<ExtArgs>
    whatsmeow_app_state_version?: boolean | whatsmeow_device$whatsmeow_app_state_versionArgs<ExtArgs>
    whatsmeow_chat_settings?: boolean | whatsmeow_device$whatsmeow_chat_settingsArgs<ExtArgs>
    whatsmeow_contacts?: boolean | whatsmeow_device$whatsmeow_contactsArgs<ExtArgs>
    whatsmeow_event_buffer?: boolean | whatsmeow_device$whatsmeow_event_bufferArgs<ExtArgs>
    whatsmeow_identity_keys?: boolean | whatsmeow_device$whatsmeow_identity_keysArgs<ExtArgs>
    whatsmeow_message_secrets?: boolean | whatsmeow_device$whatsmeow_message_secretsArgs<ExtArgs>
    whatsmeow_pre_keys?: boolean | whatsmeow_device$whatsmeow_pre_keysArgs<ExtArgs>
    whatsmeow_sender_keys?: boolean | whatsmeow_device$whatsmeow_sender_keysArgs<ExtArgs>
    whatsmeow_sessions?: boolean | whatsmeow_device$whatsmeow_sessionsArgs<ExtArgs>
    _count?: boolean | Whatsmeow_deviceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_device"]>

  export type whatsmeow_deviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    lid?: boolean
    facebook_uuid?: boolean
    registration_id?: boolean
    noise_key?: boolean
    identity_key?: boolean
    signed_pre_key?: boolean
    signed_pre_key_id?: boolean
    signed_pre_key_sig?: boolean
    adv_key?: boolean
    adv_details?: boolean
    adv_account_sig?: boolean
    adv_account_sig_key?: boolean
    adv_device_sig?: boolean
    platform?: boolean
    business_name?: boolean
    push_name?: boolean
    lid_migration_ts?: boolean
  }, ExtArgs["result"]["whatsmeow_device"]>

  export type whatsmeow_deviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    lid?: boolean
    facebook_uuid?: boolean
    registration_id?: boolean
    noise_key?: boolean
    identity_key?: boolean
    signed_pre_key?: boolean
    signed_pre_key_id?: boolean
    signed_pre_key_sig?: boolean
    adv_key?: boolean
    adv_details?: boolean
    adv_account_sig?: boolean
    adv_account_sig_key?: boolean
    adv_device_sig?: boolean
    platform?: boolean
    business_name?: boolean
    push_name?: boolean
    lid_migration_ts?: boolean
  }, ExtArgs["result"]["whatsmeow_device"]>

  export type whatsmeow_deviceSelectScalar = {
    jid?: boolean
    lid?: boolean
    facebook_uuid?: boolean
    registration_id?: boolean
    noise_key?: boolean
    identity_key?: boolean
    signed_pre_key?: boolean
    signed_pre_key_id?: boolean
    signed_pre_key_sig?: boolean
    adv_key?: boolean
    adv_details?: boolean
    adv_account_sig?: boolean
    adv_account_sig_key?: boolean
    adv_device_sig?: boolean
    platform?: boolean
    business_name?: boolean
    push_name?: boolean
    lid_migration_ts?: boolean
  }

  export type whatsmeow_deviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jid" | "lid" | "facebook_uuid" | "registration_id" | "noise_key" | "identity_key" | "signed_pre_key" | "signed_pre_key_id" | "signed_pre_key_sig" | "adv_key" | "adv_details" | "adv_account_sig" | "adv_account_sig_key" | "adv_device_sig" | "platform" | "business_name" | "push_name" | "lid_migration_ts", ExtArgs["result"]["whatsmeow_device"]>
  export type whatsmeow_deviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_app_state_sync_keys?: boolean | whatsmeow_device$whatsmeow_app_state_sync_keysArgs<ExtArgs>
    whatsmeow_app_state_version?: boolean | whatsmeow_device$whatsmeow_app_state_versionArgs<ExtArgs>
    whatsmeow_chat_settings?: boolean | whatsmeow_device$whatsmeow_chat_settingsArgs<ExtArgs>
    whatsmeow_contacts?: boolean | whatsmeow_device$whatsmeow_contactsArgs<ExtArgs>
    whatsmeow_event_buffer?: boolean | whatsmeow_device$whatsmeow_event_bufferArgs<ExtArgs>
    whatsmeow_identity_keys?: boolean | whatsmeow_device$whatsmeow_identity_keysArgs<ExtArgs>
    whatsmeow_message_secrets?: boolean | whatsmeow_device$whatsmeow_message_secretsArgs<ExtArgs>
    whatsmeow_pre_keys?: boolean | whatsmeow_device$whatsmeow_pre_keysArgs<ExtArgs>
    whatsmeow_sender_keys?: boolean | whatsmeow_device$whatsmeow_sender_keysArgs<ExtArgs>
    whatsmeow_sessions?: boolean | whatsmeow_device$whatsmeow_sessionsArgs<ExtArgs>
    _count?: boolean | Whatsmeow_deviceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type whatsmeow_deviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type whatsmeow_deviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $whatsmeow_devicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_device"
    objects: {
      whatsmeow_app_state_sync_keys: Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>[]
      whatsmeow_app_state_version: Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>[]
      whatsmeow_chat_settings: Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>[]
      whatsmeow_contacts: Prisma.$whatsmeow_contactsPayload<ExtArgs>[]
      whatsmeow_event_buffer: Prisma.$whatsmeow_event_bufferPayload<ExtArgs>[]
      whatsmeow_identity_keys: Prisma.$whatsmeow_identity_keysPayload<ExtArgs>[]
      whatsmeow_message_secrets: Prisma.$whatsmeow_message_secretsPayload<ExtArgs>[]
      whatsmeow_pre_keys: Prisma.$whatsmeow_pre_keysPayload<ExtArgs>[]
      whatsmeow_sender_keys: Prisma.$whatsmeow_sender_keysPayload<ExtArgs>[]
      whatsmeow_sessions: Prisma.$whatsmeow_sessionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      jid: string
      lid: string | null
      facebook_uuid: string | null
      registration_id: bigint
      noise_key: Uint8Array
      identity_key: Uint8Array
      signed_pre_key: Uint8Array
      signed_pre_key_id: number
      signed_pre_key_sig: Uint8Array
      adv_key: Uint8Array
      adv_details: Uint8Array
      adv_account_sig: Uint8Array
      adv_account_sig_key: Uint8Array
      adv_device_sig: Uint8Array
      platform: string
      business_name: string
      push_name: string
      lid_migration_ts: bigint
    }, ExtArgs["result"]["whatsmeow_device"]>
    composites: {}
  }

  type whatsmeow_deviceGetPayload<S extends boolean | null | undefined | whatsmeow_deviceDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_devicePayload, S>

  type whatsmeow_deviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_deviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_deviceCountAggregateInputType | true
    }

  export interface whatsmeow_deviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_device'], meta: { name: 'whatsmeow_device' } }
    /**
     * Find zero or one Whatsmeow_device that matches the filter.
     * @param {whatsmeow_deviceFindUniqueArgs} args - Arguments to find a Whatsmeow_device
     * @example
     * // Get one Whatsmeow_device
     * const whatsmeow_device = await prisma.whatsmeow_device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_deviceFindUniqueArgs>(args: SelectSubset<T, whatsmeow_deviceFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_deviceFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_device
     * @example
     * // Get one Whatsmeow_device
     * const whatsmeow_device = await prisma.whatsmeow_device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_deviceFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_deviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_deviceFindFirstArgs} args - Arguments to find a Whatsmeow_device
     * @example
     * // Get one Whatsmeow_device
     * const whatsmeow_device = await prisma.whatsmeow_device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_deviceFindFirstArgs>(args?: SelectSubset<T, whatsmeow_deviceFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_deviceFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_device
     * @example
     * // Get one Whatsmeow_device
     * const whatsmeow_device = await prisma.whatsmeow_device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_deviceFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_deviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_deviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_devices
     * const whatsmeow_devices = await prisma.whatsmeow_device.findMany()
     * 
     * // Get first 10 Whatsmeow_devices
     * const whatsmeow_devices = await prisma.whatsmeow_device.findMany({ take: 10 })
     * 
     * // Only select the `jid`
     * const whatsmeow_deviceWithJidOnly = await prisma.whatsmeow_device.findMany({ select: { jid: true } })
     * 
     */
    findMany<T extends whatsmeow_deviceFindManyArgs>(args?: SelectSubset<T, whatsmeow_deviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_device.
     * @param {whatsmeow_deviceCreateArgs} args - Arguments to create a Whatsmeow_device.
     * @example
     * // Create one Whatsmeow_device
     * const Whatsmeow_device = await prisma.whatsmeow_device.create({
     *   data: {
     *     // ... data to create a Whatsmeow_device
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_deviceCreateArgs>(args: SelectSubset<T, whatsmeow_deviceCreateArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_devices.
     * @param {whatsmeow_deviceCreateManyArgs} args - Arguments to create many Whatsmeow_devices.
     * @example
     * // Create many Whatsmeow_devices
     * const whatsmeow_device = await prisma.whatsmeow_device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_deviceCreateManyArgs>(args?: SelectSubset<T, whatsmeow_deviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_devices and returns the data saved in the database.
     * @param {whatsmeow_deviceCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_devices.
     * @example
     * // Create many Whatsmeow_devices
     * const whatsmeow_device = await prisma.whatsmeow_device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_devices and only return the `jid`
     * const whatsmeow_deviceWithJidOnly = await prisma.whatsmeow_device.createManyAndReturn({
     *   select: { jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_deviceCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_deviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_device.
     * @param {whatsmeow_deviceDeleteArgs} args - Arguments to delete one Whatsmeow_device.
     * @example
     * // Delete one Whatsmeow_device
     * const Whatsmeow_device = await prisma.whatsmeow_device.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_device
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_deviceDeleteArgs>(args: SelectSubset<T, whatsmeow_deviceDeleteArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_device.
     * @param {whatsmeow_deviceUpdateArgs} args - Arguments to update one Whatsmeow_device.
     * @example
     * // Update one Whatsmeow_device
     * const whatsmeow_device = await prisma.whatsmeow_device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_deviceUpdateArgs>(args: SelectSubset<T, whatsmeow_deviceUpdateArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_devices.
     * @param {whatsmeow_deviceDeleteManyArgs} args - Arguments to filter Whatsmeow_devices to delete.
     * @example
     * // Delete a few Whatsmeow_devices
     * const { count } = await prisma.whatsmeow_device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_deviceDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_deviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_deviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_devices
     * const whatsmeow_device = await prisma.whatsmeow_device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_deviceUpdateManyArgs>(args: SelectSubset<T, whatsmeow_deviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_devices and returns the data updated in the database.
     * @param {whatsmeow_deviceUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_devices.
     * @example
     * // Update many Whatsmeow_devices
     * const whatsmeow_device = await prisma.whatsmeow_device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_devices and only return the `jid`
     * const whatsmeow_deviceWithJidOnly = await prisma.whatsmeow_device.updateManyAndReturn({
     *   select: { jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_deviceUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_deviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_device.
     * @param {whatsmeow_deviceUpsertArgs} args - Arguments to update or create a Whatsmeow_device.
     * @example
     * // Update or create a Whatsmeow_device
     * const whatsmeow_device = await prisma.whatsmeow_device.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_device we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_deviceUpsertArgs>(args: SelectSubset<T, whatsmeow_deviceUpsertArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_deviceCountArgs} args - Arguments to filter Whatsmeow_devices to count.
     * @example
     * // Count the number of Whatsmeow_devices
     * const count = await prisma.whatsmeow_device.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_devices we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_deviceCountArgs>(
      args?: Subset<T, whatsmeow_deviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_deviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_deviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_deviceAggregateArgs>(args: Subset<T, Whatsmeow_deviceAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_deviceAggregateType<T>>

    /**
     * Group by Whatsmeow_device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_deviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_deviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_deviceGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_deviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_deviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_deviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_device model
   */
  readonly fields: whatsmeow_deviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_deviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_app_state_sync_keys<T extends whatsmeow_device$whatsmeow_app_state_sync_keysArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_app_state_sync_keysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_sync_keysPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_app_state_version<T extends whatsmeow_device$whatsmeow_app_state_versionArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_app_state_versionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_app_state_versionPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_chat_settings<T extends whatsmeow_device$whatsmeow_chat_settingsArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_chat_settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_chat_settingsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_contacts<T extends whatsmeow_device$whatsmeow_contactsArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_contactsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_event_buffer<T extends whatsmeow_device$whatsmeow_event_bufferArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_event_bufferArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_identity_keys<T extends whatsmeow_device$whatsmeow_identity_keysArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_identity_keysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_message_secrets<T extends whatsmeow_device$whatsmeow_message_secretsArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_message_secretsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_pre_keys<T extends whatsmeow_device$whatsmeow_pre_keysArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_pre_keysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_sender_keys<T extends whatsmeow_device$whatsmeow_sender_keysArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_sender_keysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    whatsmeow_sessions<T extends whatsmeow_device$whatsmeow_sessionsArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_device$whatsmeow_sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "findMany", ClientOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_device model
   */ 
  interface whatsmeow_deviceFieldRefs {
    readonly jid: FieldRef<"whatsmeow_device", 'String'>
    readonly lid: FieldRef<"whatsmeow_device", 'String'>
    readonly facebook_uuid: FieldRef<"whatsmeow_device", 'String'>
    readonly registration_id: FieldRef<"whatsmeow_device", 'BigInt'>
    readonly noise_key: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly identity_key: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly signed_pre_key: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly signed_pre_key_id: FieldRef<"whatsmeow_device", 'Int'>
    readonly signed_pre_key_sig: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly adv_key: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly adv_details: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly adv_account_sig: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly adv_account_sig_key: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly adv_device_sig: FieldRef<"whatsmeow_device", 'Bytes'>
    readonly platform: FieldRef<"whatsmeow_device", 'String'>
    readonly business_name: FieldRef<"whatsmeow_device", 'String'>
    readonly push_name: FieldRef<"whatsmeow_device", 'String'>
    readonly lid_migration_ts: FieldRef<"whatsmeow_device", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_device findUnique
   */
  export type whatsmeow_deviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_device to fetch.
     */
    where: whatsmeow_deviceWhereUniqueInput
  }

  /**
   * whatsmeow_device findUniqueOrThrow
   */
  export type whatsmeow_deviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_device to fetch.
     */
    where: whatsmeow_deviceWhereUniqueInput
  }

  /**
   * whatsmeow_device findFirst
   */
  export type whatsmeow_deviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_device to fetch.
     */
    where?: whatsmeow_deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_devices to fetch.
     */
    orderBy?: whatsmeow_deviceOrderByWithRelationInput | whatsmeow_deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_devices.
     */
    cursor?: whatsmeow_deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_devices.
     */
    distinct?: Whatsmeow_deviceScalarFieldEnum | Whatsmeow_deviceScalarFieldEnum[]
  }

  /**
   * whatsmeow_device findFirstOrThrow
   */
  export type whatsmeow_deviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_device to fetch.
     */
    where?: whatsmeow_deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_devices to fetch.
     */
    orderBy?: whatsmeow_deviceOrderByWithRelationInput | whatsmeow_deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_devices.
     */
    cursor?: whatsmeow_deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_devices.
     */
    distinct?: Whatsmeow_deviceScalarFieldEnum | Whatsmeow_deviceScalarFieldEnum[]
  }

  /**
   * whatsmeow_device findMany
   */
  export type whatsmeow_deviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_devices to fetch.
     */
    where?: whatsmeow_deviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_devices to fetch.
     */
    orderBy?: whatsmeow_deviceOrderByWithRelationInput | whatsmeow_deviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_devices.
     */
    cursor?: whatsmeow_deviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_devices.
     */
    skip?: number
    distinct?: Whatsmeow_deviceScalarFieldEnum | Whatsmeow_deviceScalarFieldEnum[]
  }

  /**
   * whatsmeow_device create
   */
  export type whatsmeow_deviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_device.
     */
    data: XOR<whatsmeow_deviceCreateInput, whatsmeow_deviceUncheckedCreateInput>
  }

  /**
   * whatsmeow_device createMany
   */
  export type whatsmeow_deviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_devices.
     */
    data: whatsmeow_deviceCreateManyInput | whatsmeow_deviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_device createManyAndReturn
   */
  export type whatsmeow_deviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_devices.
     */
    data: whatsmeow_deviceCreateManyInput | whatsmeow_deviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_device update
   */
  export type whatsmeow_deviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_device.
     */
    data: XOR<whatsmeow_deviceUpdateInput, whatsmeow_deviceUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_device to update.
     */
    where: whatsmeow_deviceWhereUniqueInput
  }

  /**
   * whatsmeow_device updateMany
   */
  export type whatsmeow_deviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_devices.
     */
    data: XOR<whatsmeow_deviceUpdateManyMutationInput, whatsmeow_deviceUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_devices to update
     */
    where?: whatsmeow_deviceWhereInput
  }

  /**
   * whatsmeow_device updateManyAndReturn
   */
  export type whatsmeow_deviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_devices.
     */
    data: XOR<whatsmeow_deviceUpdateManyMutationInput, whatsmeow_deviceUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_devices to update
     */
    where?: whatsmeow_deviceWhereInput
  }

  /**
   * whatsmeow_device upsert
   */
  export type whatsmeow_deviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_device to update in case it exists.
     */
    where: whatsmeow_deviceWhereUniqueInput
    /**
     * In case the whatsmeow_device found by the `where` argument doesn't exist, create a new whatsmeow_device with this data.
     */
    create: XOR<whatsmeow_deviceCreateInput, whatsmeow_deviceUncheckedCreateInput>
    /**
     * In case the whatsmeow_device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_deviceUpdateInput, whatsmeow_deviceUncheckedUpdateInput>
  }

  /**
   * whatsmeow_device delete
   */
  export type whatsmeow_deviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_device to delete.
     */
    where: whatsmeow_deviceWhereUniqueInput
  }

  /**
   * whatsmeow_device deleteMany
   */
  export type whatsmeow_deviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_devices to delete
     */
    where?: whatsmeow_deviceWhereInput
  }

  /**
   * whatsmeow_device.whatsmeow_app_state_sync_keys
   */
  export type whatsmeow_device$whatsmeow_app_state_sync_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_sync_keys
     */
    select?: whatsmeow_app_state_sync_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_sync_keys
     */
    omit?: whatsmeow_app_state_sync_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_sync_keysInclude<ExtArgs> | null
    where?: whatsmeow_app_state_sync_keysWhereInput
    orderBy?: whatsmeow_app_state_sync_keysOrderByWithRelationInput | whatsmeow_app_state_sync_keysOrderByWithRelationInput[]
    cursor?: whatsmeow_app_state_sync_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_app_state_sync_keysScalarFieldEnum | Whatsmeow_app_state_sync_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_app_state_version
   */
  export type whatsmeow_device$whatsmeow_app_state_versionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_app_state_version
     */
    select?: whatsmeow_app_state_versionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_app_state_version
     */
    omit?: whatsmeow_app_state_versionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_app_state_versionInclude<ExtArgs> | null
    where?: whatsmeow_app_state_versionWhereInput
    orderBy?: whatsmeow_app_state_versionOrderByWithRelationInput | whatsmeow_app_state_versionOrderByWithRelationInput[]
    cursor?: whatsmeow_app_state_versionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_app_state_versionScalarFieldEnum | Whatsmeow_app_state_versionScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_chat_settings
   */
  export type whatsmeow_device$whatsmeow_chat_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_chat_settings
     */
    select?: whatsmeow_chat_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_chat_settings
     */
    omit?: whatsmeow_chat_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_chat_settingsInclude<ExtArgs> | null
    where?: whatsmeow_chat_settingsWhereInput
    orderBy?: whatsmeow_chat_settingsOrderByWithRelationInput | whatsmeow_chat_settingsOrderByWithRelationInput[]
    cursor?: whatsmeow_chat_settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_chat_settingsScalarFieldEnum | Whatsmeow_chat_settingsScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_contacts
   */
  export type whatsmeow_device$whatsmeow_contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_contacts
     */
    select?: whatsmeow_contactsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_contacts
     */
    omit?: whatsmeow_contactsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_contactsInclude<ExtArgs> | null
    where?: whatsmeow_contactsWhereInput
    orderBy?: whatsmeow_contactsOrderByWithRelationInput | whatsmeow_contactsOrderByWithRelationInput[]
    cursor?: whatsmeow_contactsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_contactsScalarFieldEnum | Whatsmeow_contactsScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_event_buffer
   */
  export type whatsmeow_device$whatsmeow_event_bufferArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    where?: whatsmeow_event_bufferWhereInput
    orderBy?: whatsmeow_event_bufferOrderByWithRelationInput | whatsmeow_event_bufferOrderByWithRelationInput[]
    cursor?: whatsmeow_event_bufferWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_event_bufferScalarFieldEnum | Whatsmeow_event_bufferScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_identity_keys
   */
  export type whatsmeow_device$whatsmeow_identity_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    where?: whatsmeow_identity_keysWhereInput
    orderBy?: whatsmeow_identity_keysOrderByWithRelationInput | whatsmeow_identity_keysOrderByWithRelationInput[]
    cursor?: whatsmeow_identity_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_identity_keysScalarFieldEnum | Whatsmeow_identity_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_message_secrets
   */
  export type whatsmeow_device$whatsmeow_message_secretsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    where?: whatsmeow_message_secretsWhereInput
    orderBy?: whatsmeow_message_secretsOrderByWithRelationInput | whatsmeow_message_secretsOrderByWithRelationInput[]
    cursor?: whatsmeow_message_secretsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_message_secretsScalarFieldEnum | Whatsmeow_message_secretsScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_pre_keys
   */
  export type whatsmeow_device$whatsmeow_pre_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    where?: whatsmeow_pre_keysWhereInput
    orderBy?: whatsmeow_pre_keysOrderByWithRelationInput | whatsmeow_pre_keysOrderByWithRelationInput[]
    cursor?: whatsmeow_pre_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_pre_keysScalarFieldEnum | Whatsmeow_pre_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_sender_keys
   */
  export type whatsmeow_device$whatsmeow_sender_keysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    where?: whatsmeow_sender_keysWhereInput
    orderBy?: whatsmeow_sender_keysOrderByWithRelationInput | whatsmeow_sender_keysOrderByWithRelationInput[]
    cursor?: whatsmeow_sender_keysWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_sender_keysScalarFieldEnum | Whatsmeow_sender_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_device.whatsmeow_sessions
   */
  export type whatsmeow_device$whatsmeow_sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    where?: whatsmeow_sessionsWhereInput
    orderBy?: whatsmeow_sessionsOrderByWithRelationInput | whatsmeow_sessionsOrderByWithRelationInput[]
    cursor?: whatsmeow_sessionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Whatsmeow_sessionsScalarFieldEnum | Whatsmeow_sessionsScalarFieldEnum[]
  }

  /**
   * whatsmeow_device without action
   */
  export type whatsmeow_deviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_device
     */
    select?: whatsmeow_deviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_device
     */
    omit?: whatsmeow_deviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_deviceInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_event_buffer
   */

  export type AggregateWhatsmeow_event_buffer = {
    _count: Whatsmeow_event_bufferCountAggregateOutputType | null
    _avg: Whatsmeow_event_bufferAvgAggregateOutputType | null
    _sum: Whatsmeow_event_bufferSumAggregateOutputType | null
    _min: Whatsmeow_event_bufferMinAggregateOutputType | null
    _max: Whatsmeow_event_bufferMaxAggregateOutputType | null
  }

  export type Whatsmeow_event_bufferAvgAggregateOutputType = {
    server_timestamp: number | null
    insert_timestamp: number | null
  }

  export type Whatsmeow_event_bufferSumAggregateOutputType = {
    server_timestamp: bigint | null
    insert_timestamp: bigint | null
  }

  export type Whatsmeow_event_bufferMinAggregateOutputType = {
    our_jid: string | null
    ciphertext_hash: Uint8Array | null
    plaintext: Uint8Array | null
    server_timestamp: bigint | null
    insert_timestamp: bigint | null
  }

  export type Whatsmeow_event_bufferMaxAggregateOutputType = {
    our_jid: string | null
    ciphertext_hash: Uint8Array | null
    plaintext: Uint8Array | null
    server_timestamp: bigint | null
    insert_timestamp: bigint | null
  }

  export type Whatsmeow_event_bufferCountAggregateOutputType = {
    our_jid: number
    ciphertext_hash: number
    plaintext: number
    server_timestamp: number
    insert_timestamp: number
    _all: number
  }


  export type Whatsmeow_event_bufferAvgAggregateInputType = {
    server_timestamp?: true
    insert_timestamp?: true
  }

  export type Whatsmeow_event_bufferSumAggregateInputType = {
    server_timestamp?: true
    insert_timestamp?: true
  }

  export type Whatsmeow_event_bufferMinAggregateInputType = {
    our_jid?: true
    ciphertext_hash?: true
    plaintext?: true
    server_timestamp?: true
    insert_timestamp?: true
  }

  export type Whatsmeow_event_bufferMaxAggregateInputType = {
    our_jid?: true
    ciphertext_hash?: true
    plaintext?: true
    server_timestamp?: true
    insert_timestamp?: true
  }

  export type Whatsmeow_event_bufferCountAggregateInputType = {
    our_jid?: true
    ciphertext_hash?: true
    plaintext?: true
    server_timestamp?: true
    insert_timestamp?: true
    _all?: true
  }

  export type Whatsmeow_event_bufferAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_event_buffer to aggregate.
     */
    where?: whatsmeow_event_bufferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_event_buffers to fetch.
     */
    orderBy?: whatsmeow_event_bufferOrderByWithRelationInput | whatsmeow_event_bufferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_event_bufferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_event_buffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_event_buffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_event_buffers
    **/
    _count?: true | Whatsmeow_event_bufferCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_event_bufferAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_event_bufferSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_event_bufferMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_event_bufferMaxAggregateInputType
  }

  export type GetWhatsmeow_event_bufferAggregateType<T extends Whatsmeow_event_bufferAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_event_buffer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_event_buffer[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_event_buffer[P]>
  }




  export type whatsmeow_event_bufferGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_event_bufferWhereInput
    orderBy?: whatsmeow_event_bufferOrderByWithAggregationInput | whatsmeow_event_bufferOrderByWithAggregationInput[]
    by: Whatsmeow_event_bufferScalarFieldEnum[] | Whatsmeow_event_bufferScalarFieldEnum
    having?: whatsmeow_event_bufferScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_event_bufferCountAggregateInputType | true
    _avg?: Whatsmeow_event_bufferAvgAggregateInputType
    _sum?: Whatsmeow_event_bufferSumAggregateInputType
    _min?: Whatsmeow_event_bufferMinAggregateInputType
    _max?: Whatsmeow_event_bufferMaxAggregateInputType
  }

  export type Whatsmeow_event_bufferGroupByOutputType = {
    our_jid: string
    ciphertext_hash: Uint8Array
    plaintext: Uint8Array | null
    server_timestamp: bigint
    insert_timestamp: bigint
    _count: Whatsmeow_event_bufferCountAggregateOutputType | null
    _avg: Whatsmeow_event_bufferAvgAggregateOutputType | null
    _sum: Whatsmeow_event_bufferSumAggregateOutputType | null
    _min: Whatsmeow_event_bufferMinAggregateOutputType | null
    _max: Whatsmeow_event_bufferMaxAggregateOutputType | null
  }

  type GetWhatsmeow_event_bufferGroupByPayload<T extends whatsmeow_event_bufferGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_event_bufferGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_event_bufferGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_event_bufferGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_event_bufferGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_event_bufferSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    ciphertext_hash?: boolean
    plaintext?: boolean
    server_timestamp?: boolean
    insert_timestamp?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_event_buffer"]>

  export type whatsmeow_event_bufferSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    ciphertext_hash?: boolean
    plaintext?: boolean
    server_timestamp?: boolean
    insert_timestamp?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_event_buffer"]>

  export type whatsmeow_event_bufferSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    ciphertext_hash?: boolean
    plaintext?: boolean
    server_timestamp?: boolean
    insert_timestamp?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_event_buffer"]>

  export type whatsmeow_event_bufferSelectScalar = {
    our_jid?: boolean
    ciphertext_hash?: boolean
    plaintext?: boolean
    server_timestamp?: boolean
    insert_timestamp?: boolean
  }

  export type whatsmeow_event_bufferOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "ciphertext_hash" | "plaintext" | "server_timestamp" | "insert_timestamp", ExtArgs["result"]["whatsmeow_event_buffer"]>
  export type whatsmeow_event_bufferInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_event_bufferIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_event_bufferIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_event_bufferPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_event_buffer"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      ciphertext_hash: Uint8Array
      plaintext: Uint8Array | null
      server_timestamp: bigint
      insert_timestamp: bigint
    }, ExtArgs["result"]["whatsmeow_event_buffer"]>
    composites: {}
  }

  type whatsmeow_event_bufferGetPayload<S extends boolean | null | undefined | whatsmeow_event_bufferDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_event_bufferPayload, S>

  type whatsmeow_event_bufferCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_event_bufferFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_event_bufferCountAggregateInputType | true
    }

  export interface whatsmeow_event_bufferDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_event_buffer'], meta: { name: 'whatsmeow_event_buffer' } }
    /**
     * Find zero or one Whatsmeow_event_buffer that matches the filter.
     * @param {whatsmeow_event_bufferFindUniqueArgs} args - Arguments to find a Whatsmeow_event_buffer
     * @example
     * // Get one Whatsmeow_event_buffer
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_event_bufferFindUniqueArgs>(args: SelectSubset<T, whatsmeow_event_bufferFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_event_buffer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_event_bufferFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_event_buffer
     * @example
     * // Get one Whatsmeow_event_buffer
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_event_bufferFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_event_bufferFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_event_buffer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_event_bufferFindFirstArgs} args - Arguments to find a Whatsmeow_event_buffer
     * @example
     * // Get one Whatsmeow_event_buffer
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_event_bufferFindFirstArgs>(args?: SelectSubset<T, whatsmeow_event_bufferFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_event_buffer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_event_bufferFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_event_buffer
     * @example
     * // Get one Whatsmeow_event_buffer
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_event_bufferFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_event_bufferFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_event_buffers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_event_bufferFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_event_buffers
     * const whatsmeow_event_buffers = await prisma.whatsmeow_event_buffer.findMany()
     * 
     * // Get first 10 Whatsmeow_event_buffers
     * const whatsmeow_event_buffers = await prisma.whatsmeow_event_buffer.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_event_bufferWithOur_jidOnly = await prisma.whatsmeow_event_buffer.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_event_bufferFindManyArgs>(args?: SelectSubset<T, whatsmeow_event_bufferFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_event_buffer.
     * @param {whatsmeow_event_bufferCreateArgs} args - Arguments to create a Whatsmeow_event_buffer.
     * @example
     * // Create one Whatsmeow_event_buffer
     * const Whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.create({
     *   data: {
     *     // ... data to create a Whatsmeow_event_buffer
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_event_bufferCreateArgs>(args: SelectSubset<T, whatsmeow_event_bufferCreateArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_event_buffers.
     * @param {whatsmeow_event_bufferCreateManyArgs} args - Arguments to create many Whatsmeow_event_buffers.
     * @example
     * // Create many Whatsmeow_event_buffers
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_event_bufferCreateManyArgs>(args?: SelectSubset<T, whatsmeow_event_bufferCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_event_buffers and returns the data saved in the database.
     * @param {whatsmeow_event_bufferCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_event_buffers.
     * @example
     * // Create many Whatsmeow_event_buffers
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_event_buffers and only return the `our_jid`
     * const whatsmeow_event_bufferWithOur_jidOnly = await prisma.whatsmeow_event_buffer.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_event_bufferCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_event_bufferCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_event_buffer.
     * @param {whatsmeow_event_bufferDeleteArgs} args - Arguments to delete one Whatsmeow_event_buffer.
     * @example
     * // Delete one Whatsmeow_event_buffer
     * const Whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_event_buffer
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_event_bufferDeleteArgs>(args: SelectSubset<T, whatsmeow_event_bufferDeleteArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_event_buffer.
     * @param {whatsmeow_event_bufferUpdateArgs} args - Arguments to update one Whatsmeow_event_buffer.
     * @example
     * // Update one Whatsmeow_event_buffer
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_event_bufferUpdateArgs>(args: SelectSubset<T, whatsmeow_event_bufferUpdateArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_event_buffers.
     * @param {whatsmeow_event_bufferDeleteManyArgs} args - Arguments to filter Whatsmeow_event_buffers to delete.
     * @example
     * // Delete a few Whatsmeow_event_buffers
     * const { count } = await prisma.whatsmeow_event_buffer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_event_bufferDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_event_bufferDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_event_buffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_event_bufferUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_event_buffers
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_event_bufferUpdateManyArgs>(args: SelectSubset<T, whatsmeow_event_bufferUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_event_buffers and returns the data updated in the database.
     * @param {whatsmeow_event_bufferUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_event_buffers.
     * @example
     * // Update many Whatsmeow_event_buffers
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_event_buffers and only return the `our_jid`
     * const whatsmeow_event_bufferWithOur_jidOnly = await prisma.whatsmeow_event_buffer.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_event_bufferUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_event_bufferUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_event_buffer.
     * @param {whatsmeow_event_bufferUpsertArgs} args - Arguments to update or create a Whatsmeow_event_buffer.
     * @example
     * // Update or create a Whatsmeow_event_buffer
     * const whatsmeow_event_buffer = await prisma.whatsmeow_event_buffer.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_event_buffer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_event_buffer we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_event_bufferUpsertArgs>(args: SelectSubset<T, whatsmeow_event_bufferUpsertArgs<ExtArgs>>): Prisma__whatsmeow_event_bufferClient<$Result.GetResult<Prisma.$whatsmeow_event_bufferPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_event_buffers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_event_bufferCountArgs} args - Arguments to filter Whatsmeow_event_buffers to count.
     * @example
     * // Count the number of Whatsmeow_event_buffers
     * const count = await prisma.whatsmeow_event_buffer.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_event_buffers we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_event_bufferCountArgs>(
      args?: Subset<T, whatsmeow_event_bufferCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_event_bufferCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_event_buffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_event_bufferAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_event_bufferAggregateArgs>(args: Subset<T, Whatsmeow_event_bufferAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_event_bufferAggregateType<T>>

    /**
     * Group by Whatsmeow_event_buffer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_event_bufferGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_event_bufferGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_event_bufferGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_event_bufferGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_event_bufferGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_event_bufferGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_event_buffer model
   */
  readonly fields: whatsmeow_event_bufferFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_event_buffer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_event_bufferClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_event_buffer model
   */ 
  interface whatsmeow_event_bufferFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_event_buffer", 'String'>
    readonly ciphertext_hash: FieldRef<"whatsmeow_event_buffer", 'Bytes'>
    readonly plaintext: FieldRef<"whatsmeow_event_buffer", 'Bytes'>
    readonly server_timestamp: FieldRef<"whatsmeow_event_buffer", 'BigInt'>
    readonly insert_timestamp: FieldRef<"whatsmeow_event_buffer", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_event_buffer findUnique
   */
  export type whatsmeow_event_bufferFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_event_buffer to fetch.
     */
    where: whatsmeow_event_bufferWhereUniqueInput
  }

  /**
   * whatsmeow_event_buffer findUniqueOrThrow
   */
  export type whatsmeow_event_bufferFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_event_buffer to fetch.
     */
    where: whatsmeow_event_bufferWhereUniqueInput
  }

  /**
   * whatsmeow_event_buffer findFirst
   */
  export type whatsmeow_event_bufferFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_event_buffer to fetch.
     */
    where?: whatsmeow_event_bufferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_event_buffers to fetch.
     */
    orderBy?: whatsmeow_event_bufferOrderByWithRelationInput | whatsmeow_event_bufferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_event_buffers.
     */
    cursor?: whatsmeow_event_bufferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_event_buffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_event_buffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_event_buffers.
     */
    distinct?: Whatsmeow_event_bufferScalarFieldEnum | Whatsmeow_event_bufferScalarFieldEnum[]
  }

  /**
   * whatsmeow_event_buffer findFirstOrThrow
   */
  export type whatsmeow_event_bufferFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_event_buffer to fetch.
     */
    where?: whatsmeow_event_bufferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_event_buffers to fetch.
     */
    orderBy?: whatsmeow_event_bufferOrderByWithRelationInput | whatsmeow_event_bufferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_event_buffers.
     */
    cursor?: whatsmeow_event_bufferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_event_buffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_event_buffers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_event_buffers.
     */
    distinct?: Whatsmeow_event_bufferScalarFieldEnum | Whatsmeow_event_bufferScalarFieldEnum[]
  }

  /**
   * whatsmeow_event_buffer findMany
   */
  export type whatsmeow_event_bufferFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_event_buffers to fetch.
     */
    where?: whatsmeow_event_bufferWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_event_buffers to fetch.
     */
    orderBy?: whatsmeow_event_bufferOrderByWithRelationInput | whatsmeow_event_bufferOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_event_buffers.
     */
    cursor?: whatsmeow_event_bufferWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_event_buffers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_event_buffers.
     */
    skip?: number
    distinct?: Whatsmeow_event_bufferScalarFieldEnum | Whatsmeow_event_bufferScalarFieldEnum[]
  }

  /**
   * whatsmeow_event_buffer create
   */
  export type whatsmeow_event_bufferCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_event_buffer.
     */
    data: XOR<whatsmeow_event_bufferCreateInput, whatsmeow_event_bufferUncheckedCreateInput>
  }

  /**
   * whatsmeow_event_buffer createMany
   */
  export type whatsmeow_event_bufferCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_event_buffers.
     */
    data: whatsmeow_event_bufferCreateManyInput | whatsmeow_event_bufferCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_event_buffer createManyAndReturn
   */
  export type whatsmeow_event_bufferCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_event_buffers.
     */
    data: whatsmeow_event_bufferCreateManyInput | whatsmeow_event_bufferCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_event_buffer update
   */
  export type whatsmeow_event_bufferUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_event_buffer.
     */
    data: XOR<whatsmeow_event_bufferUpdateInput, whatsmeow_event_bufferUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_event_buffer to update.
     */
    where: whatsmeow_event_bufferWhereUniqueInput
  }

  /**
   * whatsmeow_event_buffer updateMany
   */
  export type whatsmeow_event_bufferUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_event_buffers.
     */
    data: XOR<whatsmeow_event_bufferUpdateManyMutationInput, whatsmeow_event_bufferUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_event_buffers to update
     */
    where?: whatsmeow_event_bufferWhereInput
  }

  /**
   * whatsmeow_event_buffer updateManyAndReturn
   */
  export type whatsmeow_event_bufferUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_event_buffers.
     */
    data: XOR<whatsmeow_event_bufferUpdateManyMutationInput, whatsmeow_event_bufferUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_event_buffers to update
     */
    where?: whatsmeow_event_bufferWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_event_buffer upsert
   */
  export type whatsmeow_event_bufferUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_event_buffer to update in case it exists.
     */
    where: whatsmeow_event_bufferWhereUniqueInput
    /**
     * In case the whatsmeow_event_buffer found by the `where` argument doesn't exist, create a new whatsmeow_event_buffer with this data.
     */
    create: XOR<whatsmeow_event_bufferCreateInput, whatsmeow_event_bufferUncheckedCreateInput>
    /**
     * In case the whatsmeow_event_buffer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_event_bufferUpdateInput, whatsmeow_event_bufferUncheckedUpdateInput>
  }

  /**
   * whatsmeow_event_buffer delete
   */
  export type whatsmeow_event_bufferDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_event_buffer to delete.
     */
    where: whatsmeow_event_bufferWhereUniqueInput
  }

  /**
   * whatsmeow_event_buffer deleteMany
   */
  export type whatsmeow_event_bufferDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_event_buffers to delete
     */
    where?: whatsmeow_event_bufferWhereInput
  }

  /**
   * whatsmeow_event_buffer without action
   */
  export type whatsmeow_event_bufferDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_event_buffer
     */
    select?: whatsmeow_event_bufferSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_event_buffer
     */
    omit?: whatsmeow_event_bufferOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_event_bufferInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_identity_keys
   */

  export type AggregateWhatsmeow_identity_keys = {
    _count: Whatsmeow_identity_keysCountAggregateOutputType | null
    _min: Whatsmeow_identity_keysMinAggregateOutputType | null
    _max: Whatsmeow_identity_keysMaxAggregateOutputType | null
  }

  export type Whatsmeow_identity_keysMinAggregateOutputType = {
    our_jid: string | null
    their_id: string | null
    identity: Uint8Array | null
  }

  export type Whatsmeow_identity_keysMaxAggregateOutputType = {
    our_jid: string | null
    their_id: string | null
    identity: Uint8Array | null
  }

  export type Whatsmeow_identity_keysCountAggregateOutputType = {
    our_jid: number
    their_id: number
    identity: number
    _all: number
  }


  export type Whatsmeow_identity_keysMinAggregateInputType = {
    our_jid?: true
    their_id?: true
    identity?: true
  }

  export type Whatsmeow_identity_keysMaxAggregateInputType = {
    our_jid?: true
    their_id?: true
    identity?: true
  }

  export type Whatsmeow_identity_keysCountAggregateInputType = {
    our_jid?: true
    their_id?: true
    identity?: true
    _all?: true
  }

  export type Whatsmeow_identity_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_identity_keys to aggregate.
     */
    where?: whatsmeow_identity_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_identity_keys to fetch.
     */
    orderBy?: whatsmeow_identity_keysOrderByWithRelationInput | whatsmeow_identity_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_identity_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_identity_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_identity_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_identity_keys
    **/
    _count?: true | Whatsmeow_identity_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_identity_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_identity_keysMaxAggregateInputType
  }

  export type GetWhatsmeow_identity_keysAggregateType<T extends Whatsmeow_identity_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_identity_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_identity_keys[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_identity_keys[P]>
  }




  export type whatsmeow_identity_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_identity_keysWhereInput
    orderBy?: whatsmeow_identity_keysOrderByWithAggregationInput | whatsmeow_identity_keysOrderByWithAggregationInput[]
    by: Whatsmeow_identity_keysScalarFieldEnum[] | Whatsmeow_identity_keysScalarFieldEnum
    having?: whatsmeow_identity_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_identity_keysCountAggregateInputType | true
    _min?: Whatsmeow_identity_keysMinAggregateInputType
    _max?: Whatsmeow_identity_keysMaxAggregateInputType
  }

  export type Whatsmeow_identity_keysGroupByOutputType = {
    our_jid: string
    their_id: string
    identity: Uint8Array
    _count: Whatsmeow_identity_keysCountAggregateOutputType | null
    _min: Whatsmeow_identity_keysMinAggregateOutputType | null
    _max: Whatsmeow_identity_keysMaxAggregateOutputType | null
  }

  type GetWhatsmeow_identity_keysGroupByPayload<T extends whatsmeow_identity_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_identity_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_identity_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_identity_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_identity_keysGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_identity_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_id?: boolean
    identity?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_identity_keys"]>

  export type whatsmeow_identity_keysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_id?: boolean
    identity?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_identity_keys"]>

  export type whatsmeow_identity_keysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_id?: boolean
    identity?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_identity_keys"]>

  export type whatsmeow_identity_keysSelectScalar = {
    our_jid?: boolean
    their_id?: boolean
    identity?: boolean
  }

  export type whatsmeow_identity_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "their_id" | "identity", ExtArgs["result"]["whatsmeow_identity_keys"]>
  export type whatsmeow_identity_keysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_identity_keysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_identity_keysIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_identity_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_identity_keys"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      their_id: string
      identity: Uint8Array
    }, ExtArgs["result"]["whatsmeow_identity_keys"]>
    composites: {}
  }

  type whatsmeow_identity_keysGetPayload<S extends boolean | null | undefined | whatsmeow_identity_keysDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_identity_keysPayload, S>

  type whatsmeow_identity_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_identity_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_identity_keysCountAggregateInputType | true
    }

  export interface whatsmeow_identity_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_identity_keys'], meta: { name: 'whatsmeow_identity_keys' } }
    /**
     * Find zero or one Whatsmeow_identity_keys that matches the filter.
     * @param {whatsmeow_identity_keysFindUniqueArgs} args - Arguments to find a Whatsmeow_identity_keys
     * @example
     * // Get one Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_identity_keysFindUniqueArgs>(args: SelectSubset<T, whatsmeow_identity_keysFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_identity_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_identity_keysFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_identity_keys
     * @example
     * // Get one Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_identity_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_identity_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_identity_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_identity_keysFindFirstArgs} args - Arguments to find a Whatsmeow_identity_keys
     * @example
     * // Get one Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_identity_keysFindFirstArgs>(args?: SelectSubset<T, whatsmeow_identity_keysFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_identity_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_identity_keysFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_identity_keys
     * @example
     * // Get one Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_identity_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_identity_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_identity_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_identity_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findMany()
     * 
     * // Get first 10 Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_identity_keysWithOur_jidOnly = await prisma.whatsmeow_identity_keys.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_identity_keysFindManyArgs>(args?: SelectSubset<T, whatsmeow_identity_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_identity_keys.
     * @param {whatsmeow_identity_keysCreateArgs} args - Arguments to create a Whatsmeow_identity_keys.
     * @example
     * // Create one Whatsmeow_identity_keys
     * const Whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.create({
     *   data: {
     *     // ... data to create a Whatsmeow_identity_keys
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_identity_keysCreateArgs>(args: SelectSubset<T, whatsmeow_identity_keysCreateArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_identity_keys.
     * @param {whatsmeow_identity_keysCreateManyArgs} args - Arguments to create many Whatsmeow_identity_keys.
     * @example
     * // Create many Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_identity_keysCreateManyArgs>(args?: SelectSubset<T, whatsmeow_identity_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_identity_keys and returns the data saved in the database.
     * @param {whatsmeow_identity_keysCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_identity_keys.
     * @example
     * // Create many Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_identity_keys and only return the `our_jid`
     * const whatsmeow_identity_keysWithOur_jidOnly = await prisma.whatsmeow_identity_keys.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_identity_keysCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_identity_keysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_identity_keys.
     * @param {whatsmeow_identity_keysDeleteArgs} args - Arguments to delete one Whatsmeow_identity_keys.
     * @example
     * // Delete one Whatsmeow_identity_keys
     * const Whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_identity_keys
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_identity_keysDeleteArgs>(args: SelectSubset<T, whatsmeow_identity_keysDeleteArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_identity_keys.
     * @param {whatsmeow_identity_keysUpdateArgs} args - Arguments to update one Whatsmeow_identity_keys.
     * @example
     * // Update one Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_identity_keysUpdateArgs>(args: SelectSubset<T, whatsmeow_identity_keysUpdateArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_identity_keys.
     * @param {whatsmeow_identity_keysDeleteManyArgs} args - Arguments to filter Whatsmeow_identity_keys to delete.
     * @example
     * // Delete a few Whatsmeow_identity_keys
     * const { count } = await prisma.whatsmeow_identity_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_identity_keysDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_identity_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_identity_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_identity_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_identity_keysUpdateManyArgs>(args: SelectSubset<T, whatsmeow_identity_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_identity_keys and returns the data updated in the database.
     * @param {whatsmeow_identity_keysUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_identity_keys.
     * @example
     * // Update many Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_identity_keys and only return the `our_jid`
     * const whatsmeow_identity_keysWithOur_jidOnly = await prisma.whatsmeow_identity_keys.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_identity_keysUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_identity_keysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_identity_keys.
     * @param {whatsmeow_identity_keysUpsertArgs} args - Arguments to update or create a Whatsmeow_identity_keys.
     * @example
     * // Update or create a Whatsmeow_identity_keys
     * const whatsmeow_identity_keys = await prisma.whatsmeow_identity_keys.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_identity_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_identity_keys we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_identity_keysUpsertArgs>(args: SelectSubset<T, whatsmeow_identity_keysUpsertArgs<ExtArgs>>): Prisma__whatsmeow_identity_keysClient<$Result.GetResult<Prisma.$whatsmeow_identity_keysPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_identity_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_identity_keysCountArgs} args - Arguments to filter Whatsmeow_identity_keys to count.
     * @example
     * // Count the number of Whatsmeow_identity_keys
     * const count = await prisma.whatsmeow_identity_keys.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_identity_keys we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_identity_keysCountArgs>(
      args?: Subset<T, whatsmeow_identity_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_identity_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_identity_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_identity_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_identity_keysAggregateArgs>(args: Subset<T, Whatsmeow_identity_keysAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_identity_keysAggregateType<T>>

    /**
     * Group by Whatsmeow_identity_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_identity_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_identity_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_identity_keysGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_identity_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_identity_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_identity_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_identity_keys model
   */
  readonly fields: whatsmeow_identity_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_identity_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_identity_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_identity_keys model
   */ 
  interface whatsmeow_identity_keysFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_identity_keys", 'String'>
    readonly their_id: FieldRef<"whatsmeow_identity_keys", 'String'>
    readonly identity: FieldRef<"whatsmeow_identity_keys", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_identity_keys findUnique
   */
  export type whatsmeow_identity_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_identity_keys to fetch.
     */
    where: whatsmeow_identity_keysWhereUniqueInput
  }

  /**
   * whatsmeow_identity_keys findUniqueOrThrow
   */
  export type whatsmeow_identity_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_identity_keys to fetch.
     */
    where: whatsmeow_identity_keysWhereUniqueInput
  }

  /**
   * whatsmeow_identity_keys findFirst
   */
  export type whatsmeow_identity_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_identity_keys to fetch.
     */
    where?: whatsmeow_identity_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_identity_keys to fetch.
     */
    orderBy?: whatsmeow_identity_keysOrderByWithRelationInput | whatsmeow_identity_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_identity_keys.
     */
    cursor?: whatsmeow_identity_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_identity_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_identity_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_identity_keys.
     */
    distinct?: Whatsmeow_identity_keysScalarFieldEnum | Whatsmeow_identity_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_identity_keys findFirstOrThrow
   */
  export type whatsmeow_identity_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_identity_keys to fetch.
     */
    where?: whatsmeow_identity_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_identity_keys to fetch.
     */
    orderBy?: whatsmeow_identity_keysOrderByWithRelationInput | whatsmeow_identity_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_identity_keys.
     */
    cursor?: whatsmeow_identity_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_identity_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_identity_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_identity_keys.
     */
    distinct?: Whatsmeow_identity_keysScalarFieldEnum | Whatsmeow_identity_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_identity_keys findMany
   */
  export type whatsmeow_identity_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_identity_keys to fetch.
     */
    where?: whatsmeow_identity_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_identity_keys to fetch.
     */
    orderBy?: whatsmeow_identity_keysOrderByWithRelationInput | whatsmeow_identity_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_identity_keys.
     */
    cursor?: whatsmeow_identity_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_identity_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_identity_keys.
     */
    skip?: number
    distinct?: Whatsmeow_identity_keysScalarFieldEnum | Whatsmeow_identity_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_identity_keys create
   */
  export type whatsmeow_identity_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_identity_keys.
     */
    data: XOR<whatsmeow_identity_keysCreateInput, whatsmeow_identity_keysUncheckedCreateInput>
  }

  /**
   * whatsmeow_identity_keys createMany
   */
  export type whatsmeow_identity_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_identity_keys.
     */
    data: whatsmeow_identity_keysCreateManyInput | whatsmeow_identity_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_identity_keys createManyAndReturn
   */
  export type whatsmeow_identity_keysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_identity_keys.
     */
    data: whatsmeow_identity_keysCreateManyInput | whatsmeow_identity_keysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_identity_keys update
   */
  export type whatsmeow_identity_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_identity_keys.
     */
    data: XOR<whatsmeow_identity_keysUpdateInput, whatsmeow_identity_keysUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_identity_keys to update.
     */
    where: whatsmeow_identity_keysWhereUniqueInput
  }

  /**
   * whatsmeow_identity_keys updateMany
   */
  export type whatsmeow_identity_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_identity_keys.
     */
    data: XOR<whatsmeow_identity_keysUpdateManyMutationInput, whatsmeow_identity_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_identity_keys to update
     */
    where?: whatsmeow_identity_keysWhereInput
  }

  /**
   * whatsmeow_identity_keys updateManyAndReturn
   */
  export type whatsmeow_identity_keysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_identity_keys.
     */
    data: XOR<whatsmeow_identity_keysUpdateManyMutationInput, whatsmeow_identity_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_identity_keys to update
     */
    where?: whatsmeow_identity_keysWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_identity_keys upsert
   */
  export type whatsmeow_identity_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_identity_keys to update in case it exists.
     */
    where: whatsmeow_identity_keysWhereUniqueInput
    /**
     * In case the whatsmeow_identity_keys found by the `where` argument doesn't exist, create a new whatsmeow_identity_keys with this data.
     */
    create: XOR<whatsmeow_identity_keysCreateInput, whatsmeow_identity_keysUncheckedCreateInput>
    /**
     * In case the whatsmeow_identity_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_identity_keysUpdateInput, whatsmeow_identity_keysUncheckedUpdateInput>
  }

  /**
   * whatsmeow_identity_keys delete
   */
  export type whatsmeow_identity_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_identity_keys to delete.
     */
    where: whatsmeow_identity_keysWhereUniqueInput
  }

  /**
   * whatsmeow_identity_keys deleteMany
   */
  export type whatsmeow_identity_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_identity_keys to delete
     */
    where?: whatsmeow_identity_keysWhereInput
  }

  /**
   * whatsmeow_identity_keys without action
   */
  export type whatsmeow_identity_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_identity_keys
     */
    select?: whatsmeow_identity_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_identity_keys
     */
    omit?: whatsmeow_identity_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_identity_keysInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_lid_map
   */

  export type AggregateWhatsmeow_lid_map = {
    _count: Whatsmeow_lid_mapCountAggregateOutputType | null
    _min: Whatsmeow_lid_mapMinAggregateOutputType | null
    _max: Whatsmeow_lid_mapMaxAggregateOutputType | null
  }

  export type Whatsmeow_lid_mapMinAggregateOutputType = {
    lid: string | null
    pn: string | null
  }

  export type Whatsmeow_lid_mapMaxAggregateOutputType = {
    lid: string | null
    pn: string | null
  }

  export type Whatsmeow_lid_mapCountAggregateOutputType = {
    lid: number
    pn: number
    _all: number
  }


  export type Whatsmeow_lid_mapMinAggregateInputType = {
    lid?: true
    pn?: true
  }

  export type Whatsmeow_lid_mapMaxAggregateInputType = {
    lid?: true
    pn?: true
  }

  export type Whatsmeow_lid_mapCountAggregateInputType = {
    lid?: true
    pn?: true
    _all?: true
  }

  export type Whatsmeow_lid_mapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_lid_map to aggregate.
     */
    where?: whatsmeow_lid_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_lid_maps to fetch.
     */
    orderBy?: whatsmeow_lid_mapOrderByWithRelationInput | whatsmeow_lid_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_lid_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_lid_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_lid_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_lid_maps
    **/
    _count?: true | Whatsmeow_lid_mapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_lid_mapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_lid_mapMaxAggregateInputType
  }

  export type GetWhatsmeow_lid_mapAggregateType<T extends Whatsmeow_lid_mapAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_lid_map]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_lid_map[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_lid_map[P]>
  }




  export type whatsmeow_lid_mapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_lid_mapWhereInput
    orderBy?: whatsmeow_lid_mapOrderByWithAggregationInput | whatsmeow_lid_mapOrderByWithAggregationInput[]
    by: Whatsmeow_lid_mapScalarFieldEnum[] | Whatsmeow_lid_mapScalarFieldEnum
    having?: whatsmeow_lid_mapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_lid_mapCountAggregateInputType | true
    _min?: Whatsmeow_lid_mapMinAggregateInputType
    _max?: Whatsmeow_lid_mapMaxAggregateInputType
  }

  export type Whatsmeow_lid_mapGroupByOutputType = {
    lid: string
    pn: string
    _count: Whatsmeow_lid_mapCountAggregateOutputType | null
    _min: Whatsmeow_lid_mapMinAggregateOutputType | null
    _max: Whatsmeow_lid_mapMaxAggregateOutputType | null
  }

  type GetWhatsmeow_lid_mapGroupByPayload<T extends whatsmeow_lid_mapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_lid_mapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_lid_mapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_lid_mapGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_lid_mapGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_lid_mapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lid?: boolean
    pn?: boolean
  }, ExtArgs["result"]["whatsmeow_lid_map"]>

  export type whatsmeow_lid_mapSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lid?: boolean
    pn?: boolean
  }, ExtArgs["result"]["whatsmeow_lid_map"]>

  export type whatsmeow_lid_mapSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    lid?: boolean
    pn?: boolean
  }, ExtArgs["result"]["whatsmeow_lid_map"]>

  export type whatsmeow_lid_mapSelectScalar = {
    lid?: boolean
    pn?: boolean
  }

  export type whatsmeow_lid_mapOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"lid" | "pn", ExtArgs["result"]["whatsmeow_lid_map"]>

  export type $whatsmeow_lid_mapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_lid_map"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      lid: string
      pn: string
    }, ExtArgs["result"]["whatsmeow_lid_map"]>
    composites: {}
  }

  type whatsmeow_lid_mapGetPayload<S extends boolean | null | undefined | whatsmeow_lid_mapDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_lid_mapPayload, S>

  type whatsmeow_lid_mapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_lid_mapFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_lid_mapCountAggregateInputType | true
    }

  export interface whatsmeow_lid_mapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_lid_map'], meta: { name: 'whatsmeow_lid_map' } }
    /**
     * Find zero or one Whatsmeow_lid_map that matches the filter.
     * @param {whatsmeow_lid_mapFindUniqueArgs} args - Arguments to find a Whatsmeow_lid_map
     * @example
     * // Get one Whatsmeow_lid_map
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_lid_mapFindUniqueArgs>(args: SelectSubset<T, whatsmeow_lid_mapFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_lid_map that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_lid_mapFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_lid_map
     * @example
     * // Get one Whatsmeow_lid_map
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_lid_mapFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_lid_mapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_lid_map that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_lid_mapFindFirstArgs} args - Arguments to find a Whatsmeow_lid_map
     * @example
     * // Get one Whatsmeow_lid_map
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_lid_mapFindFirstArgs>(args?: SelectSubset<T, whatsmeow_lid_mapFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_lid_map that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_lid_mapFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_lid_map
     * @example
     * // Get one Whatsmeow_lid_map
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_lid_mapFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_lid_mapFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_lid_maps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_lid_mapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_lid_maps
     * const whatsmeow_lid_maps = await prisma.whatsmeow_lid_map.findMany()
     * 
     * // Get first 10 Whatsmeow_lid_maps
     * const whatsmeow_lid_maps = await prisma.whatsmeow_lid_map.findMany({ take: 10 })
     * 
     * // Only select the `lid`
     * const whatsmeow_lid_mapWithLidOnly = await prisma.whatsmeow_lid_map.findMany({ select: { lid: true } })
     * 
     */
    findMany<T extends whatsmeow_lid_mapFindManyArgs>(args?: SelectSubset<T, whatsmeow_lid_mapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_lid_map.
     * @param {whatsmeow_lid_mapCreateArgs} args - Arguments to create a Whatsmeow_lid_map.
     * @example
     * // Create one Whatsmeow_lid_map
     * const Whatsmeow_lid_map = await prisma.whatsmeow_lid_map.create({
     *   data: {
     *     // ... data to create a Whatsmeow_lid_map
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_lid_mapCreateArgs>(args: SelectSubset<T, whatsmeow_lid_mapCreateArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_lid_maps.
     * @param {whatsmeow_lid_mapCreateManyArgs} args - Arguments to create many Whatsmeow_lid_maps.
     * @example
     * // Create many Whatsmeow_lid_maps
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_lid_mapCreateManyArgs>(args?: SelectSubset<T, whatsmeow_lid_mapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_lid_maps and returns the data saved in the database.
     * @param {whatsmeow_lid_mapCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_lid_maps.
     * @example
     * // Create many Whatsmeow_lid_maps
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_lid_maps and only return the `lid`
     * const whatsmeow_lid_mapWithLidOnly = await prisma.whatsmeow_lid_map.createManyAndReturn({
     *   select: { lid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_lid_mapCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_lid_mapCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_lid_map.
     * @param {whatsmeow_lid_mapDeleteArgs} args - Arguments to delete one Whatsmeow_lid_map.
     * @example
     * // Delete one Whatsmeow_lid_map
     * const Whatsmeow_lid_map = await prisma.whatsmeow_lid_map.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_lid_map
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_lid_mapDeleteArgs>(args: SelectSubset<T, whatsmeow_lid_mapDeleteArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_lid_map.
     * @param {whatsmeow_lid_mapUpdateArgs} args - Arguments to update one Whatsmeow_lid_map.
     * @example
     * // Update one Whatsmeow_lid_map
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_lid_mapUpdateArgs>(args: SelectSubset<T, whatsmeow_lid_mapUpdateArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_lid_maps.
     * @param {whatsmeow_lid_mapDeleteManyArgs} args - Arguments to filter Whatsmeow_lid_maps to delete.
     * @example
     * // Delete a few Whatsmeow_lid_maps
     * const { count } = await prisma.whatsmeow_lid_map.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_lid_mapDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_lid_mapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_lid_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_lid_mapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_lid_maps
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_lid_mapUpdateManyArgs>(args: SelectSubset<T, whatsmeow_lid_mapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_lid_maps and returns the data updated in the database.
     * @param {whatsmeow_lid_mapUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_lid_maps.
     * @example
     * // Update many Whatsmeow_lid_maps
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_lid_maps and only return the `lid`
     * const whatsmeow_lid_mapWithLidOnly = await prisma.whatsmeow_lid_map.updateManyAndReturn({
     *   select: { lid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_lid_mapUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_lid_mapUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_lid_map.
     * @param {whatsmeow_lid_mapUpsertArgs} args - Arguments to update or create a Whatsmeow_lid_map.
     * @example
     * // Update or create a Whatsmeow_lid_map
     * const whatsmeow_lid_map = await prisma.whatsmeow_lid_map.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_lid_map
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_lid_map we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_lid_mapUpsertArgs>(args: SelectSubset<T, whatsmeow_lid_mapUpsertArgs<ExtArgs>>): Prisma__whatsmeow_lid_mapClient<$Result.GetResult<Prisma.$whatsmeow_lid_mapPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_lid_maps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_lid_mapCountArgs} args - Arguments to filter Whatsmeow_lid_maps to count.
     * @example
     * // Count the number of Whatsmeow_lid_maps
     * const count = await prisma.whatsmeow_lid_map.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_lid_maps we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_lid_mapCountArgs>(
      args?: Subset<T, whatsmeow_lid_mapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_lid_mapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_lid_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_lid_mapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_lid_mapAggregateArgs>(args: Subset<T, Whatsmeow_lid_mapAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_lid_mapAggregateType<T>>

    /**
     * Group by Whatsmeow_lid_map.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_lid_mapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_lid_mapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_lid_mapGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_lid_mapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_lid_mapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_lid_mapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_lid_map model
   */
  readonly fields: whatsmeow_lid_mapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_lid_map.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_lid_mapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_lid_map model
   */ 
  interface whatsmeow_lid_mapFieldRefs {
    readonly lid: FieldRef<"whatsmeow_lid_map", 'String'>
    readonly pn: FieldRef<"whatsmeow_lid_map", 'String'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_lid_map findUnique
   */
  export type whatsmeow_lid_mapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_lid_map to fetch.
     */
    where: whatsmeow_lid_mapWhereUniqueInput
  }

  /**
   * whatsmeow_lid_map findUniqueOrThrow
   */
  export type whatsmeow_lid_mapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_lid_map to fetch.
     */
    where: whatsmeow_lid_mapWhereUniqueInput
  }

  /**
   * whatsmeow_lid_map findFirst
   */
  export type whatsmeow_lid_mapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_lid_map to fetch.
     */
    where?: whatsmeow_lid_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_lid_maps to fetch.
     */
    orderBy?: whatsmeow_lid_mapOrderByWithRelationInput | whatsmeow_lid_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_lid_maps.
     */
    cursor?: whatsmeow_lid_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_lid_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_lid_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_lid_maps.
     */
    distinct?: Whatsmeow_lid_mapScalarFieldEnum | Whatsmeow_lid_mapScalarFieldEnum[]
  }

  /**
   * whatsmeow_lid_map findFirstOrThrow
   */
  export type whatsmeow_lid_mapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_lid_map to fetch.
     */
    where?: whatsmeow_lid_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_lid_maps to fetch.
     */
    orderBy?: whatsmeow_lid_mapOrderByWithRelationInput | whatsmeow_lid_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_lid_maps.
     */
    cursor?: whatsmeow_lid_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_lid_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_lid_maps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_lid_maps.
     */
    distinct?: Whatsmeow_lid_mapScalarFieldEnum | Whatsmeow_lid_mapScalarFieldEnum[]
  }

  /**
   * whatsmeow_lid_map findMany
   */
  export type whatsmeow_lid_mapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_lid_maps to fetch.
     */
    where?: whatsmeow_lid_mapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_lid_maps to fetch.
     */
    orderBy?: whatsmeow_lid_mapOrderByWithRelationInput | whatsmeow_lid_mapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_lid_maps.
     */
    cursor?: whatsmeow_lid_mapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_lid_maps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_lid_maps.
     */
    skip?: number
    distinct?: Whatsmeow_lid_mapScalarFieldEnum | Whatsmeow_lid_mapScalarFieldEnum[]
  }

  /**
   * whatsmeow_lid_map create
   */
  export type whatsmeow_lid_mapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_lid_map.
     */
    data: XOR<whatsmeow_lid_mapCreateInput, whatsmeow_lid_mapUncheckedCreateInput>
  }

  /**
   * whatsmeow_lid_map createMany
   */
  export type whatsmeow_lid_mapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_lid_maps.
     */
    data: whatsmeow_lid_mapCreateManyInput | whatsmeow_lid_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_lid_map createManyAndReturn
   */
  export type whatsmeow_lid_mapCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_lid_maps.
     */
    data: whatsmeow_lid_mapCreateManyInput | whatsmeow_lid_mapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_lid_map update
   */
  export type whatsmeow_lid_mapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_lid_map.
     */
    data: XOR<whatsmeow_lid_mapUpdateInput, whatsmeow_lid_mapUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_lid_map to update.
     */
    where: whatsmeow_lid_mapWhereUniqueInput
  }

  /**
   * whatsmeow_lid_map updateMany
   */
  export type whatsmeow_lid_mapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_lid_maps.
     */
    data: XOR<whatsmeow_lid_mapUpdateManyMutationInput, whatsmeow_lid_mapUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_lid_maps to update
     */
    where?: whatsmeow_lid_mapWhereInput
  }

  /**
   * whatsmeow_lid_map updateManyAndReturn
   */
  export type whatsmeow_lid_mapUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_lid_maps.
     */
    data: XOR<whatsmeow_lid_mapUpdateManyMutationInput, whatsmeow_lid_mapUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_lid_maps to update
     */
    where?: whatsmeow_lid_mapWhereInput
  }

  /**
   * whatsmeow_lid_map upsert
   */
  export type whatsmeow_lid_mapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_lid_map to update in case it exists.
     */
    where: whatsmeow_lid_mapWhereUniqueInput
    /**
     * In case the whatsmeow_lid_map found by the `where` argument doesn't exist, create a new whatsmeow_lid_map with this data.
     */
    create: XOR<whatsmeow_lid_mapCreateInput, whatsmeow_lid_mapUncheckedCreateInput>
    /**
     * In case the whatsmeow_lid_map was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_lid_mapUpdateInput, whatsmeow_lid_mapUncheckedUpdateInput>
  }

  /**
   * whatsmeow_lid_map delete
   */
  export type whatsmeow_lid_mapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
    /**
     * Filter which whatsmeow_lid_map to delete.
     */
    where: whatsmeow_lid_mapWhereUniqueInput
  }

  /**
   * whatsmeow_lid_map deleteMany
   */
  export type whatsmeow_lid_mapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_lid_maps to delete
     */
    where?: whatsmeow_lid_mapWhereInput
  }

  /**
   * whatsmeow_lid_map without action
   */
  export type whatsmeow_lid_mapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_lid_map
     */
    select?: whatsmeow_lid_mapSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_lid_map
     */
    omit?: whatsmeow_lid_mapOmit<ExtArgs> | null
  }


  /**
   * Model whatsmeow_message_secrets
   */

  export type AggregateWhatsmeow_message_secrets = {
    _count: Whatsmeow_message_secretsCountAggregateOutputType | null
    _min: Whatsmeow_message_secretsMinAggregateOutputType | null
    _max: Whatsmeow_message_secretsMaxAggregateOutputType | null
  }

  export type Whatsmeow_message_secretsMinAggregateOutputType = {
    our_jid: string | null
    chat_jid: string | null
    sender_jid: string | null
    message_id: string | null
    key: Uint8Array | null
  }

  export type Whatsmeow_message_secretsMaxAggregateOutputType = {
    our_jid: string | null
    chat_jid: string | null
    sender_jid: string | null
    message_id: string | null
    key: Uint8Array | null
  }

  export type Whatsmeow_message_secretsCountAggregateOutputType = {
    our_jid: number
    chat_jid: number
    sender_jid: number
    message_id: number
    key: number
    _all: number
  }


  export type Whatsmeow_message_secretsMinAggregateInputType = {
    our_jid?: true
    chat_jid?: true
    sender_jid?: true
    message_id?: true
    key?: true
  }

  export type Whatsmeow_message_secretsMaxAggregateInputType = {
    our_jid?: true
    chat_jid?: true
    sender_jid?: true
    message_id?: true
    key?: true
  }

  export type Whatsmeow_message_secretsCountAggregateInputType = {
    our_jid?: true
    chat_jid?: true
    sender_jid?: true
    message_id?: true
    key?: true
    _all?: true
  }

  export type Whatsmeow_message_secretsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_message_secrets to aggregate.
     */
    where?: whatsmeow_message_secretsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_message_secrets to fetch.
     */
    orderBy?: whatsmeow_message_secretsOrderByWithRelationInput | whatsmeow_message_secretsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_message_secretsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_message_secrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_message_secrets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_message_secrets
    **/
    _count?: true | Whatsmeow_message_secretsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_message_secretsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_message_secretsMaxAggregateInputType
  }

  export type GetWhatsmeow_message_secretsAggregateType<T extends Whatsmeow_message_secretsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_message_secrets]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_message_secrets[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_message_secrets[P]>
  }




  export type whatsmeow_message_secretsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_message_secretsWhereInput
    orderBy?: whatsmeow_message_secretsOrderByWithAggregationInput | whatsmeow_message_secretsOrderByWithAggregationInput[]
    by: Whatsmeow_message_secretsScalarFieldEnum[] | Whatsmeow_message_secretsScalarFieldEnum
    having?: whatsmeow_message_secretsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_message_secretsCountAggregateInputType | true
    _min?: Whatsmeow_message_secretsMinAggregateInputType
    _max?: Whatsmeow_message_secretsMaxAggregateInputType
  }

  export type Whatsmeow_message_secretsGroupByOutputType = {
    our_jid: string
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
    _count: Whatsmeow_message_secretsCountAggregateOutputType | null
    _min: Whatsmeow_message_secretsMinAggregateOutputType | null
    _max: Whatsmeow_message_secretsMaxAggregateOutputType | null
  }

  type GetWhatsmeow_message_secretsGroupByPayload<T extends whatsmeow_message_secretsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_message_secretsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_message_secretsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_message_secretsGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_message_secretsGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_message_secretsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    key?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_message_secrets"]>

  export type whatsmeow_message_secretsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    key?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_message_secrets"]>

  export type whatsmeow_message_secretsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    key?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_message_secrets"]>

  export type whatsmeow_message_secretsSelectScalar = {
    our_jid?: boolean
    chat_jid?: boolean
    sender_jid?: boolean
    message_id?: boolean
    key?: boolean
  }

  export type whatsmeow_message_secretsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "chat_jid" | "sender_jid" | "message_id" | "key", ExtArgs["result"]["whatsmeow_message_secrets"]>
  export type whatsmeow_message_secretsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_message_secretsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_message_secretsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_message_secretsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_message_secrets"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      chat_jid: string
      sender_jid: string
      message_id: string
      key: Uint8Array
    }, ExtArgs["result"]["whatsmeow_message_secrets"]>
    composites: {}
  }

  type whatsmeow_message_secretsGetPayload<S extends boolean | null | undefined | whatsmeow_message_secretsDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_message_secretsPayload, S>

  type whatsmeow_message_secretsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_message_secretsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_message_secretsCountAggregateInputType | true
    }

  export interface whatsmeow_message_secretsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_message_secrets'], meta: { name: 'whatsmeow_message_secrets' } }
    /**
     * Find zero or one Whatsmeow_message_secrets that matches the filter.
     * @param {whatsmeow_message_secretsFindUniqueArgs} args - Arguments to find a Whatsmeow_message_secrets
     * @example
     * // Get one Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_message_secretsFindUniqueArgs>(args: SelectSubset<T, whatsmeow_message_secretsFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_message_secrets that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_message_secretsFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_message_secrets
     * @example
     * // Get one Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_message_secretsFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_message_secretsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_message_secrets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_message_secretsFindFirstArgs} args - Arguments to find a Whatsmeow_message_secrets
     * @example
     * // Get one Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_message_secretsFindFirstArgs>(args?: SelectSubset<T, whatsmeow_message_secretsFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_message_secrets that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_message_secretsFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_message_secrets
     * @example
     * // Get one Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_message_secretsFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_message_secretsFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_message_secrets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_message_secretsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findMany()
     * 
     * // Get first 10 Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_message_secretsWithOur_jidOnly = await prisma.whatsmeow_message_secrets.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_message_secretsFindManyArgs>(args?: SelectSubset<T, whatsmeow_message_secretsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_message_secrets.
     * @param {whatsmeow_message_secretsCreateArgs} args - Arguments to create a Whatsmeow_message_secrets.
     * @example
     * // Create one Whatsmeow_message_secrets
     * const Whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.create({
     *   data: {
     *     // ... data to create a Whatsmeow_message_secrets
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_message_secretsCreateArgs>(args: SelectSubset<T, whatsmeow_message_secretsCreateArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_message_secrets.
     * @param {whatsmeow_message_secretsCreateManyArgs} args - Arguments to create many Whatsmeow_message_secrets.
     * @example
     * // Create many Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_message_secretsCreateManyArgs>(args?: SelectSubset<T, whatsmeow_message_secretsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_message_secrets and returns the data saved in the database.
     * @param {whatsmeow_message_secretsCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_message_secrets.
     * @example
     * // Create many Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_message_secrets and only return the `our_jid`
     * const whatsmeow_message_secretsWithOur_jidOnly = await prisma.whatsmeow_message_secrets.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_message_secretsCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_message_secretsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_message_secrets.
     * @param {whatsmeow_message_secretsDeleteArgs} args - Arguments to delete one Whatsmeow_message_secrets.
     * @example
     * // Delete one Whatsmeow_message_secrets
     * const Whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_message_secrets
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_message_secretsDeleteArgs>(args: SelectSubset<T, whatsmeow_message_secretsDeleteArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_message_secrets.
     * @param {whatsmeow_message_secretsUpdateArgs} args - Arguments to update one Whatsmeow_message_secrets.
     * @example
     * // Update one Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_message_secretsUpdateArgs>(args: SelectSubset<T, whatsmeow_message_secretsUpdateArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_message_secrets.
     * @param {whatsmeow_message_secretsDeleteManyArgs} args - Arguments to filter Whatsmeow_message_secrets to delete.
     * @example
     * // Delete a few Whatsmeow_message_secrets
     * const { count } = await prisma.whatsmeow_message_secrets.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_message_secretsDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_message_secretsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_message_secrets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_message_secretsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_message_secretsUpdateManyArgs>(args: SelectSubset<T, whatsmeow_message_secretsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_message_secrets and returns the data updated in the database.
     * @param {whatsmeow_message_secretsUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_message_secrets.
     * @example
     * // Update many Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_message_secrets and only return the `our_jid`
     * const whatsmeow_message_secretsWithOur_jidOnly = await prisma.whatsmeow_message_secrets.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_message_secretsUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_message_secretsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_message_secrets.
     * @param {whatsmeow_message_secretsUpsertArgs} args - Arguments to update or create a Whatsmeow_message_secrets.
     * @example
     * // Update or create a Whatsmeow_message_secrets
     * const whatsmeow_message_secrets = await prisma.whatsmeow_message_secrets.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_message_secrets
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_message_secrets we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_message_secretsUpsertArgs>(args: SelectSubset<T, whatsmeow_message_secretsUpsertArgs<ExtArgs>>): Prisma__whatsmeow_message_secretsClient<$Result.GetResult<Prisma.$whatsmeow_message_secretsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_message_secrets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_message_secretsCountArgs} args - Arguments to filter Whatsmeow_message_secrets to count.
     * @example
     * // Count the number of Whatsmeow_message_secrets
     * const count = await prisma.whatsmeow_message_secrets.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_message_secrets we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_message_secretsCountArgs>(
      args?: Subset<T, whatsmeow_message_secretsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_message_secretsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_message_secrets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_message_secretsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_message_secretsAggregateArgs>(args: Subset<T, Whatsmeow_message_secretsAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_message_secretsAggregateType<T>>

    /**
     * Group by Whatsmeow_message_secrets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_message_secretsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_message_secretsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_message_secretsGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_message_secretsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_message_secretsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_message_secretsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_message_secrets model
   */
  readonly fields: whatsmeow_message_secretsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_message_secrets.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_message_secretsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_message_secrets model
   */ 
  interface whatsmeow_message_secretsFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_message_secrets", 'String'>
    readonly chat_jid: FieldRef<"whatsmeow_message_secrets", 'String'>
    readonly sender_jid: FieldRef<"whatsmeow_message_secrets", 'String'>
    readonly message_id: FieldRef<"whatsmeow_message_secrets", 'String'>
    readonly key: FieldRef<"whatsmeow_message_secrets", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_message_secrets findUnique
   */
  export type whatsmeow_message_secretsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_message_secrets to fetch.
     */
    where: whatsmeow_message_secretsWhereUniqueInput
  }

  /**
   * whatsmeow_message_secrets findUniqueOrThrow
   */
  export type whatsmeow_message_secretsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_message_secrets to fetch.
     */
    where: whatsmeow_message_secretsWhereUniqueInput
  }

  /**
   * whatsmeow_message_secrets findFirst
   */
  export type whatsmeow_message_secretsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_message_secrets to fetch.
     */
    where?: whatsmeow_message_secretsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_message_secrets to fetch.
     */
    orderBy?: whatsmeow_message_secretsOrderByWithRelationInput | whatsmeow_message_secretsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_message_secrets.
     */
    cursor?: whatsmeow_message_secretsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_message_secrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_message_secrets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_message_secrets.
     */
    distinct?: Whatsmeow_message_secretsScalarFieldEnum | Whatsmeow_message_secretsScalarFieldEnum[]
  }

  /**
   * whatsmeow_message_secrets findFirstOrThrow
   */
  export type whatsmeow_message_secretsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_message_secrets to fetch.
     */
    where?: whatsmeow_message_secretsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_message_secrets to fetch.
     */
    orderBy?: whatsmeow_message_secretsOrderByWithRelationInput | whatsmeow_message_secretsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_message_secrets.
     */
    cursor?: whatsmeow_message_secretsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_message_secrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_message_secrets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_message_secrets.
     */
    distinct?: Whatsmeow_message_secretsScalarFieldEnum | Whatsmeow_message_secretsScalarFieldEnum[]
  }

  /**
   * whatsmeow_message_secrets findMany
   */
  export type whatsmeow_message_secretsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_message_secrets to fetch.
     */
    where?: whatsmeow_message_secretsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_message_secrets to fetch.
     */
    orderBy?: whatsmeow_message_secretsOrderByWithRelationInput | whatsmeow_message_secretsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_message_secrets.
     */
    cursor?: whatsmeow_message_secretsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_message_secrets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_message_secrets.
     */
    skip?: number
    distinct?: Whatsmeow_message_secretsScalarFieldEnum | Whatsmeow_message_secretsScalarFieldEnum[]
  }

  /**
   * whatsmeow_message_secrets create
   */
  export type whatsmeow_message_secretsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_message_secrets.
     */
    data: XOR<whatsmeow_message_secretsCreateInput, whatsmeow_message_secretsUncheckedCreateInput>
  }

  /**
   * whatsmeow_message_secrets createMany
   */
  export type whatsmeow_message_secretsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_message_secrets.
     */
    data: whatsmeow_message_secretsCreateManyInput | whatsmeow_message_secretsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_message_secrets createManyAndReturn
   */
  export type whatsmeow_message_secretsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_message_secrets.
     */
    data: whatsmeow_message_secretsCreateManyInput | whatsmeow_message_secretsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_message_secrets update
   */
  export type whatsmeow_message_secretsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_message_secrets.
     */
    data: XOR<whatsmeow_message_secretsUpdateInput, whatsmeow_message_secretsUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_message_secrets to update.
     */
    where: whatsmeow_message_secretsWhereUniqueInput
  }

  /**
   * whatsmeow_message_secrets updateMany
   */
  export type whatsmeow_message_secretsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_message_secrets.
     */
    data: XOR<whatsmeow_message_secretsUpdateManyMutationInput, whatsmeow_message_secretsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_message_secrets to update
     */
    where?: whatsmeow_message_secretsWhereInput
  }

  /**
   * whatsmeow_message_secrets updateManyAndReturn
   */
  export type whatsmeow_message_secretsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_message_secrets.
     */
    data: XOR<whatsmeow_message_secretsUpdateManyMutationInput, whatsmeow_message_secretsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_message_secrets to update
     */
    where?: whatsmeow_message_secretsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_message_secrets upsert
   */
  export type whatsmeow_message_secretsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_message_secrets to update in case it exists.
     */
    where: whatsmeow_message_secretsWhereUniqueInput
    /**
     * In case the whatsmeow_message_secrets found by the `where` argument doesn't exist, create a new whatsmeow_message_secrets with this data.
     */
    create: XOR<whatsmeow_message_secretsCreateInput, whatsmeow_message_secretsUncheckedCreateInput>
    /**
     * In case the whatsmeow_message_secrets was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_message_secretsUpdateInput, whatsmeow_message_secretsUncheckedUpdateInput>
  }

  /**
   * whatsmeow_message_secrets delete
   */
  export type whatsmeow_message_secretsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_message_secrets to delete.
     */
    where: whatsmeow_message_secretsWhereUniqueInput
  }

  /**
   * whatsmeow_message_secrets deleteMany
   */
  export type whatsmeow_message_secretsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_message_secrets to delete
     */
    where?: whatsmeow_message_secretsWhereInput
  }

  /**
   * whatsmeow_message_secrets without action
   */
  export type whatsmeow_message_secretsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_message_secrets
     */
    select?: whatsmeow_message_secretsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_message_secrets
     */
    omit?: whatsmeow_message_secretsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_message_secretsInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_pre_keys
   */

  export type AggregateWhatsmeow_pre_keys = {
    _count: Whatsmeow_pre_keysCountAggregateOutputType | null
    _avg: Whatsmeow_pre_keysAvgAggregateOutputType | null
    _sum: Whatsmeow_pre_keysSumAggregateOutputType | null
    _min: Whatsmeow_pre_keysMinAggregateOutputType | null
    _max: Whatsmeow_pre_keysMaxAggregateOutputType | null
  }

  export type Whatsmeow_pre_keysAvgAggregateOutputType = {
    key_id: number | null
  }

  export type Whatsmeow_pre_keysSumAggregateOutputType = {
    key_id: number | null
  }

  export type Whatsmeow_pre_keysMinAggregateOutputType = {
    jid: string | null
    key_id: number | null
    key: Uint8Array | null
    uploaded: boolean | null
  }

  export type Whatsmeow_pre_keysMaxAggregateOutputType = {
    jid: string | null
    key_id: number | null
    key: Uint8Array | null
    uploaded: boolean | null
  }

  export type Whatsmeow_pre_keysCountAggregateOutputType = {
    jid: number
    key_id: number
    key: number
    uploaded: number
    _all: number
  }


  export type Whatsmeow_pre_keysAvgAggregateInputType = {
    key_id?: true
  }

  export type Whatsmeow_pre_keysSumAggregateInputType = {
    key_id?: true
  }

  export type Whatsmeow_pre_keysMinAggregateInputType = {
    jid?: true
    key_id?: true
    key?: true
    uploaded?: true
  }

  export type Whatsmeow_pre_keysMaxAggregateInputType = {
    jid?: true
    key_id?: true
    key?: true
    uploaded?: true
  }

  export type Whatsmeow_pre_keysCountAggregateInputType = {
    jid?: true
    key_id?: true
    key?: true
    uploaded?: true
    _all?: true
  }

  export type Whatsmeow_pre_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_pre_keys to aggregate.
     */
    where?: whatsmeow_pre_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_pre_keys to fetch.
     */
    orderBy?: whatsmeow_pre_keysOrderByWithRelationInput | whatsmeow_pre_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_pre_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_pre_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_pre_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_pre_keys
    **/
    _count?: true | Whatsmeow_pre_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_pre_keysAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_pre_keysSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_pre_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_pre_keysMaxAggregateInputType
  }

  export type GetWhatsmeow_pre_keysAggregateType<T extends Whatsmeow_pre_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_pre_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_pre_keys[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_pre_keys[P]>
  }




  export type whatsmeow_pre_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_pre_keysWhereInput
    orderBy?: whatsmeow_pre_keysOrderByWithAggregationInput | whatsmeow_pre_keysOrderByWithAggregationInput[]
    by: Whatsmeow_pre_keysScalarFieldEnum[] | Whatsmeow_pre_keysScalarFieldEnum
    having?: whatsmeow_pre_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_pre_keysCountAggregateInputType | true
    _avg?: Whatsmeow_pre_keysAvgAggregateInputType
    _sum?: Whatsmeow_pre_keysSumAggregateInputType
    _min?: Whatsmeow_pre_keysMinAggregateInputType
    _max?: Whatsmeow_pre_keysMaxAggregateInputType
  }

  export type Whatsmeow_pre_keysGroupByOutputType = {
    jid: string
    key_id: number
    key: Uint8Array
    uploaded: boolean
    _count: Whatsmeow_pre_keysCountAggregateOutputType | null
    _avg: Whatsmeow_pre_keysAvgAggregateOutputType | null
    _sum: Whatsmeow_pre_keysSumAggregateOutputType | null
    _min: Whatsmeow_pre_keysMinAggregateOutputType | null
    _max: Whatsmeow_pre_keysMaxAggregateOutputType | null
  }

  type GetWhatsmeow_pre_keysGroupByPayload<T extends whatsmeow_pre_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_pre_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_pre_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_pre_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_pre_keysGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_pre_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    key_id?: boolean
    key?: boolean
    uploaded?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_pre_keys"]>

  export type whatsmeow_pre_keysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    key_id?: boolean
    key?: boolean
    uploaded?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_pre_keys"]>

  export type whatsmeow_pre_keysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    jid?: boolean
    key_id?: boolean
    key?: boolean
    uploaded?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_pre_keys"]>

  export type whatsmeow_pre_keysSelectScalar = {
    jid?: boolean
    key_id?: boolean
    key?: boolean
    uploaded?: boolean
  }

  export type whatsmeow_pre_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"jid" | "key_id" | "key" | "uploaded", ExtArgs["result"]["whatsmeow_pre_keys"]>
  export type whatsmeow_pre_keysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_pre_keysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_pre_keysIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_pre_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_pre_keys"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      jid: string
      key_id: number
      key: Uint8Array
      uploaded: boolean
    }, ExtArgs["result"]["whatsmeow_pre_keys"]>
    composites: {}
  }

  type whatsmeow_pre_keysGetPayload<S extends boolean | null | undefined | whatsmeow_pre_keysDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_pre_keysPayload, S>

  type whatsmeow_pre_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_pre_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_pre_keysCountAggregateInputType | true
    }

  export interface whatsmeow_pre_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_pre_keys'], meta: { name: 'whatsmeow_pre_keys' } }
    /**
     * Find zero or one Whatsmeow_pre_keys that matches the filter.
     * @param {whatsmeow_pre_keysFindUniqueArgs} args - Arguments to find a Whatsmeow_pre_keys
     * @example
     * // Get one Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_pre_keysFindUniqueArgs>(args: SelectSubset<T, whatsmeow_pre_keysFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_pre_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_pre_keysFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_pre_keys
     * @example
     * // Get one Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_pre_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_pre_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_pre_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_pre_keysFindFirstArgs} args - Arguments to find a Whatsmeow_pre_keys
     * @example
     * // Get one Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_pre_keysFindFirstArgs>(args?: SelectSubset<T, whatsmeow_pre_keysFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_pre_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_pre_keysFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_pre_keys
     * @example
     * // Get one Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_pre_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_pre_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_pre_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_pre_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findMany()
     * 
     * // Get first 10 Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.findMany({ take: 10 })
     * 
     * // Only select the `jid`
     * const whatsmeow_pre_keysWithJidOnly = await prisma.whatsmeow_pre_keys.findMany({ select: { jid: true } })
     * 
     */
    findMany<T extends whatsmeow_pre_keysFindManyArgs>(args?: SelectSubset<T, whatsmeow_pre_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_pre_keys.
     * @param {whatsmeow_pre_keysCreateArgs} args - Arguments to create a Whatsmeow_pre_keys.
     * @example
     * // Create one Whatsmeow_pre_keys
     * const Whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.create({
     *   data: {
     *     // ... data to create a Whatsmeow_pre_keys
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_pre_keysCreateArgs>(args: SelectSubset<T, whatsmeow_pre_keysCreateArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_pre_keys.
     * @param {whatsmeow_pre_keysCreateManyArgs} args - Arguments to create many Whatsmeow_pre_keys.
     * @example
     * // Create many Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_pre_keysCreateManyArgs>(args?: SelectSubset<T, whatsmeow_pre_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_pre_keys and returns the data saved in the database.
     * @param {whatsmeow_pre_keysCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_pre_keys.
     * @example
     * // Create many Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_pre_keys and only return the `jid`
     * const whatsmeow_pre_keysWithJidOnly = await prisma.whatsmeow_pre_keys.createManyAndReturn({
     *   select: { jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_pre_keysCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_pre_keysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_pre_keys.
     * @param {whatsmeow_pre_keysDeleteArgs} args - Arguments to delete one Whatsmeow_pre_keys.
     * @example
     * // Delete one Whatsmeow_pre_keys
     * const Whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_pre_keys
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_pre_keysDeleteArgs>(args: SelectSubset<T, whatsmeow_pre_keysDeleteArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_pre_keys.
     * @param {whatsmeow_pre_keysUpdateArgs} args - Arguments to update one Whatsmeow_pre_keys.
     * @example
     * // Update one Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_pre_keysUpdateArgs>(args: SelectSubset<T, whatsmeow_pre_keysUpdateArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_pre_keys.
     * @param {whatsmeow_pre_keysDeleteManyArgs} args - Arguments to filter Whatsmeow_pre_keys to delete.
     * @example
     * // Delete a few Whatsmeow_pre_keys
     * const { count } = await prisma.whatsmeow_pre_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_pre_keysDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_pre_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_pre_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_pre_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_pre_keysUpdateManyArgs>(args: SelectSubset<T, whatsmeow_pre_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_pre_keys and returns the data updated in the database.
     * @param {whatsmeow_pre_keysUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_pre_keys.
     * @example
     * // Update many Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_pre_keys and only return the `jid`
     * const whatsmeow_pre_keysWithJidOnly = await prisma.whatsmeow_pre_keys.updateManyAndReturn({
     *   select: { jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_pre_keysUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_pre_keysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_pre_keys.
     * @param {whatsmeow_pre_keysUpsertArgs} args - Arguments to update or create a Whatsmeow_pre_keys.
     * @example
     * // Update or create a Whatsmeow_pre_keys
     * const whatsmeow_pre_keys = await prisma.whatsmeow_pre_keys.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_pre_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_pre_keys we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_pre_keysUpsertArgs>(args: SelectSubset<T, whatsmeow_pre_keysUpsertArgs<ExtArgs>>): Prisma__whatsmeow_pre_keysClient<$Result.GetResult<Prisma.$whatsmeow_pre_keysPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_pre_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_pre_keysCountArgs} args - Arguments to filter Whatsmeow_pre_keys to count.
     * @example
     * // Count the number of Whatsmeow_pre_keys
     * const count = await prisma.whatsmeow_pre_keys.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_pre_keys we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_pre_keysCountArgs>(
      args?: Subset<T, whatsmeow_pre_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_pre_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_pre_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_pre_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_pre_keysAggregateArgs>(args: Subset<T, Whatsmeow_pre_keysAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_pre_keysAggregateType<T>>

    /**
     * Group by Whatsmeow_pre_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_pre_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_pre_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_pre_keysGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_pre_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_pre_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_pre_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_pre_keys model
   */
  readonly fields: whatsmeow_pre_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_pre_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_pre_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_pre_keys model
   */ 
  interface whatsmeow_pre_keysFieldRefs {
    readonly jid: FieldRef<"whatsmeow_pre_keys", 'String'>
    readonly key_id: FieldRef<"whatsmeow_pre_keys", 'Int'>
    readonly key: FieldRef<"whatsmeow_pre_keys", 'Bytes'>
    readonly uploaded: FieldRef<"whatsmeow_pre_keys", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_pre_keys findUnique
   */
  export type whatsmeow_pre_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_pre_keys to fetch.
     */
    where: whatsmeow_pre_keysWhereUniqueInput
  }

  /**
   * whatsmeow_pre_keys findUniqueOrThrow
   */
  export type whatsmeow_pre_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_pre_keys to fetch.
     */
    where: whatsmeow_pre_keysWhereUniqueInput
  }

  /**
   * whatsmeow_pre_keys findFirst
   */
  export type whatsmeow_pre_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_pre_keys to fetch.
     */
    where?: whatsmeow_pre_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_pre_keys to fetch.
     */
    orderBy?: whatsmeow_pre_keysOrderByWithRelationInput | whatsmeow_pre_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_pre_keys.
     */
    cursor?: whatsmeow_pre_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_pre_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_pre_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_pre_keys.
     */
    distinct?: Whatsmeow_pre_keysScalarFieldEnum | Whatsmeow_pre_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_pre_keys findFirstOrThrow
   */
  export type whatsmeow_pre_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_pre_keys to fetch.
     */
    where?: whatsmeow_pre_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_pre_keys to fetch.
     */
    orderBy?: whatsmeow_pre_keysOrderByWithRelationInput | whatsmeow_pre_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_pre_keys.
     */
    cursor?: whatsmeow_pre_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_pre_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_pre_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_pre_keys.
     */
    distinct?: Whatsmeow_pre_keysScalarFieldEnum | Whatsmeow_pre_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_pre_keys findMany
   */
  export type whatsmeow_pre_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_pre_keys to fetch.
     */
    where?: whatsmeow_pre_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_pre_keys to fetch.
     */
    orderBy?: whatsmeow_pre_keysOrderByWithRelationInput | whatsmeow_pre_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_pre_keys.
     */
    cursor?: whatsmeow_pre_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_pre_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_pre_keys.
     */
    skip?: number
    distinct?: Whatsmeow_pre_keysScalarFieldEnum | Whatsmeow_pre_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_pre_keys create
   */
  export type whatsmeow_pre_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_pre_keys.
     */
    data: XOR<whatsmeow_pre_keysCreateInput, whatsmeow_pre_keysUncheckedCreateInput>
  }

  /**
   * whatsmeow_pre_keys createMany
   */
  export type whatsmeow_pre_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_pre_keys.
     */
    data: whatsmeow_pre_keysCreateManyInput | whatsmeow_pre_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_pre_keys createManyAndReturn
   */
  export type whatsmeow_pre_keysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_pre_keys.
     */
    data: whatsmeow_pre_keysCreateManyInput | whatsmeow_pre_keysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_pre_keys update
   */
  export type whatsmeow_pre_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_pre_keys.
     */
    data: XOR<whatsmeow_pre_keysUpdateInput, whatsmeow_pre_keysUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_pre_keys to update.
     */
    where: whatsmeow_pre_keysWhereUniqueInput
  }

  /**
   * whatsmeow_pre_keys updateMany
   */
  export type whatsmeow_pre_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_pre_keys.
     */
    data: XOR<whatsmeow_pre_keysUpdateManyMutationInput, whatsmeow_pre_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_pre_keys to update
     */
    where?: whatsmeow_pre_keysWhereInput
  }

  /**
   * whatsmeow_pre_keys updateManyAndReturn
   */
  export type whatsmeow_pre_keysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_pre_keys.
     */
    data: XOR<whatsmeow_pre_keysUpdateManyMutationInput, whatsmeow_pre_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_pre_keys to update
     */
    where?: whatsmeow_pre_keysWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_pre_keys upsert
   */
  export type whatsmeow_pre_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_pre_keys to update in case it exists.
     */
    where: whatsmeow_pre_keysWhereUniqueInput
    /**
     * In case the whatsmeow_pre_keys found by the `where` argument doesn't exist, create a new whatsmeow_pre_keys with this data.
     */
    create: XOR<whatsmeow_pre_keysCreateInput, whatsmeow_pre_keysUncheckedCreateInput>
    /**
     * In case the whatsmeow_pre_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_pre_keysUpdateInput, whatsmeow_pre_keysUncheckedUpdateInput>
  }

  /**
   * whatsmeow_pre_keys delete
   */
  export type whatsmeow_pre_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_pre_keys to delete.
     */
    where: whatsmeow_pre_keysWhereUniqueInput
  }

  /**
   * whatsmeow_pre_keys deleteMany
   */
  export type whatsmeow_pre_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_pre_keys to delete
     */
    where?: whatsmeow_pre_keysWhereInput
  }

  /**
   * whatsmeow_pre_keys without action
   */
  export type whatsmeow_pre_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_pre_keys
     */
    select?: whatsmeow_pre_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_pre_keys
     */
    omit?: whatsmeow_pre_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_pre_keysInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_privacy_tokens
   */

  export type AggregateWhatsmeow_privacy_tokens = {
    _count: Whatsmeow_privacy_tokensCountAggregateOutputType | null
    _avg: Whatsmeow_privacy_tokensAvgAggregateOutputType | null
    _sum: Whatsmeow_privacy_tokensSumAggregateOutputType | null
    _min: Whatsmeow_privacy_tokensMinAggregateOutputType | null
    _max: Whatsmeow_privacy_tokensMaxAggregateOutputType | null
  }

  export type Whatsmeow_privacy_tokensAvgAggregateOutputType = {
    timestamp: number | null
  }

  export type Whatsmeow_privacy_tokensSumAggregateOutputType = {
    timestamp: bigint | null
  }

  export type Whatsmeow_privacy_tokensMinAggregateOutputType = {
    our_jid: string | null
    their_jid: string | null
    token: Uint8Array | null
    timestamp: bigint | null
  }

  export type Whatsmeow_privacy_tokensMaxAggregateOutputType = {
    our_jid: string | null
    their_jid: string | null
    token: Uint8Array | null
    timestamp: bigint | null
  }

  export type Whatsmeow_privacy_tokensCountAggregateOutputType = {
    our_jid: number
    their_jid: number
    token: number
    timestamp: number
    _all: number
  }


  export type Whatsmeow_privacy_tokensAvgAggregateInputType = {
    timestamp?: true
  }

  export type Whatsmeow_privacy_tokensSumAggregateInputType = {
    timestamp?: true
  }

  export type Whatsmeow_privacy_tokensMinAggregateInputType = {
    our_jid?: true
    their_jid?: true
    token?: true
    timestamp?: true
  }

  export type Whatsmeow_privacy_tokensMaxAggregateInputType = {
    our_jid?: true
    their_jid?: true
    token?: true
    timestamp?: true
  }

  export type Whatsmeow_privacy_tokensCountAggregateInputType = {
    our_jid?: true
    their_jid?: true
    token?: true
    timestamp?: true
    _all?: true
  }

  export type Whatsmeow_privacy_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_privacy_tokens to aggregate.
     */
    where?: whatsmeow_privacy_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_privacy_tokens to fetch.
     */
    orderBy?: whatsmeow_privacy_tokensOrderByWithRelationInput | whatsmeow_privacy_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_privacy_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_privacy_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_privacy_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_privacy_tokens
    **/
    _count?: true | Whatsmeow_privacy_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Whatsmeow_privacy_tokensAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Whatsmeow_privacy_tokensSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_privacy_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_privacy_tokensMaxAggregateInputType
  }

  export type GetWhatsmeow_privacy_tokensAggregateType<T extends Whatsmeow_privacy_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_privacy_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_privacy_tokens[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_privacy_tokens[P]>
  }




  export type whatsmeow_privacy_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_privacy_tokensWhereInput
    orderBy?: whatsmeow_privacy_tokensOrderByWithAggregationInput | whatsmeow_privacy_tokensOrderByWithAggregationInput[]
    by: Whatsmeow_privacy_tokensScalarFieldEnum[] | Whatsmeow_privacy_tokensScalarFieldEnum
    having?: whatsmeow_privacy_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_privacy_tokensCountAggregateInputType | true
    _avg?: Whatsmeow_privacy_tokensAvgAggregateInputType
    _sum?: Whatsmeow_privacy_tokensSumAggregateInputType
    _min?: Whatsmeow_privacy_tokensMinAggregateInputType
    _max?: Whatsmeow_privacy_tokensMaxAggregateInputType
  }

  export type Whatsmeow_privacy_tokensGroupByOutputType = {
    our_jid: string
    their_jid: string
    token: Uint8Array
    timestamp: bigint
    _count: Whatsmeow_privacy_tokensCountAggregateOutputType | null
    _avg: Whatsmeow_privacy_tokensAvgAggregateOutputType | null
    _sum: Whatsmeow_privacy_tokensSumAggregateOutputType | null
    _min: Whatsmeow_privacy_tokensMinAggregateOutputType | null
    _max: Whatsmeow_privacy_tokensMaxAggregateOutputType | null
  }

  type GetWhatsmeow_privacy_tokensGroupByPayload<T extends whatsmeow_privacy_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_privacy_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_privacy_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_privacy_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_privacy_tokensGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_privacy_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_jid?: boolean
    token?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["whatsmeow_privacy_tokens"]>

  export type whatsmeow_privacy_tokensSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_jid?: boolean
    token?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["whatsmeow_privacy_tokens"]>

  export type whatsmeow_privacy_tokensSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_jid?: boolean
    token?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["whatsmeow_privacy_tokens"]>

  export type whatsmeow_privacy_tokensSelectScalar = {
    our_jid?: boolean
    their_jid?: boolean
    token?: boolean
    timestamp?: boolean
  }

  export type whatsmeow_privacy_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "their_jid" | "token" | "timestamp", ExtArgs["result"]["whatsmeow_privacy_tokens"]>

  export type $whatsmeow_privacy_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_privacy_tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      their_jid: string
      token: Uint8Array
      timestamp: bigint
    }, ExtArgs["result"]["whatsmeow_privacy_tokens"]>
    composites: {}
  }

  type whatsmeow_privacy_tokensGetPayload<S extends boolean | null | undefined | whatsmeow_privacy_tokensDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload, S>

  type whatsmeow_privacy_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_privacy_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_privacy_tokensCountAggregateInputType | true
    }

  export interface whatsmeow_privacy_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_privacy_tokens'], meta: { name: 'whatsmeow_privacy_tokens' } }
    /**
     * Find zero or one Whatsmeow_privacy_tokens that matches the filter.
     * @param {whatsmeow_privacy_tokensFindUniqueArgs} args - Arguments to find a Whatsmeow_privacy_tokens
     * @example
     * // Get one Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_privacy_tokensFindUniqueArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_privacy_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_privacy_tokensFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_privacy_tokens
     * @example
     * // Get one Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_privacy_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_privacy_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_privacy_tokensFindFirstArgs} args - Arguments to find a Whatsmeow_privacy_tokens
     * @example
     * // Get one Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_privacy_tokensFindFirstArgs>(args?: SelectSubset<T, whatsmeow_privacy_tokensFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_privacy_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_privacy_tokensFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_privacy_tokens
     * @example
     * // Get one Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_privacy_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_privacy_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_privacy_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_privacy_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findMany()
     * 
     * // Get first 10 Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_privacy_tokensWithOur_jidOnly = await prisma.whatsmeow_privacy_tokens.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_privacy_tokensFindManyArgs>(args?: SelectSubset<T, whatsmeow_privacy_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_privacy_tokens.
     * @param {whatsmeow_privacy_tokensCreateArgs} args - Arguments to create a Whatsmeow_privacy_tokens.
     * @example
     * // Create one Whatsmeow_privacy_tokens
     * const Whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.create({
     *   data: {
     *     // ... data to create a Whatsmeow_privacy_tokens
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_privacy_tokensCreateArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensCreateArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_privacy_tokens.
     * @param {whatsmeow_privacy_tokensCreateManyArgs} args - Arguments to create many Whatsmeow_privacy_tokens.
     * @example
     * // Create many Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_privacy_tokensCreateManyArgs>(args?: SelectSubset<T, whatsmeow_privacy_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_privacy_tokens and returns the data saved in the database.
     * @param {whatsmeow_privacy_tokensCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_privacy_tokens.
     * @example
     * // Create many Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_privacy_tokens and only return the `our_jid`
     * const whatsmeow_privacy_tokensWithOur_jidOnly = await prisma.whatsmeow_privacy_tokens.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_privacy_tokensCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_privacy_tokensCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_privacy_tokens.
     * @param {whatsmeow_privacy_tokensDeleteArgs} args - Arguments to delete one Whatsmeow_privacy_tokens.
     * @example
     * // Delete one Whatsmeow_privacy_tokens
     * const Whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_privacy_tokens
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_privacy_tokensDeleteArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensDeleteArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_privacy_tokens.
     * @param {whatsmeow_privacy_tokensUpdateArgs} args - Arguments to update one Whatsmeow_privacy_tokens.
     * @example
     * // Update one Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_privacy_tokensUpdateArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensUpdateArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_privacy_tokens.
     * @param {whatsmeow_privacy_tokensDeleteManyArgs} args - Arguments to filter Whatsmeow_privacy_tokens to delete.
     * @example
     * // Delete a few Whatsmeow_privacy_tokens
     * const { count } = await prisma.whatsmeow_privacy_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_privacy_tokensDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_privacy_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_privacy_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_privacy_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_privacy_tokensUpdateManyArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_privacy_tokens and returns the data updated in the database.
     * @param {whatsmeow_privacy_tokensUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_privacy_tokens.
     * @example
     * // Update many Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_privacy_tokens and only return the `our_jid`
     * const whatsmeow_privacy_tokensWithOur_jidOnly = await prisma.whatsmeow_privacy_tokens.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_privacy_tokensUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_privacy_tokens.
     * @param {whatsmeow_privacy_tokensUpsertArgs} args - Arguments to update or create a Whatsmeow_privacy_tokens.
     * @example
     * // Update or create a Whatsmeow_privacy_tokens
     * const whatsmeow_privacy_tokens = await prisma.whatsmeow_privacy_tokens.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_privacy_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_privacy_tokens we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_privacy_tokensUpsertArgs>(args: SelectSubset<T, whatsmeow_privacy_tokensUpsertArgs<ExtArgs>>): Prisma__whatsmeow_privacy_tokensClient<$Result.GetResult<Prisma.$whatsmeow_privacy_tokensPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_privacy_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_privacy_tokensCountArgs} args - Arguments to filter Whatsmeow_privacy_tokens to count.
     * @example
     * // Count the number of Whatsmeow_privacy_tokens
     * const count = await prisma.whatsmeow_privacy_tokens.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_privacy_tokens we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_privacy_tokensCountArgs>(
      args?: Subset<T, whatsmeow_privacy_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_privacy_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_privacy_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_privacy_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_privacy_tokensAggregateArgs>(args: Subset<T, Whatsmeow_privacy_tokensAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_privacy_tokensAggregateType<T>>

    /**
     * Group by Whatsmeow_privacy_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_privacy_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_privacy_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_privacy_tokensGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_privacy_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_privacy_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_privacy_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_privacy_tokens model
   */
  readonly fields: whatsmeow_privacy_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_privacy_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_privacy_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_privacy_tokens model
   */ 
  interface whatsmeow_privacy_tokensFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_privacy_tokens", 'String'>
    readonly their_jid: FieldRef<"whatsmeow_privacy_tokens", 'String'>
    readonly token: FieldRef<"whatsmeow_privacy_tokens", 'Bytes'>
    readonly timestamp: FieldRef<"whatsmeow_privacy_tokens", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_privacy_tokens findUnique
   */
  export type whatsmeow_privacy_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_privacy_tokens to fetch.
     */
    where: whatsmeow_privacy_tokensWhereUniqueInput
  }

  /**
   * whatsmeow_privacy_tokens findUniqueOrThrow
   */
  export type whatsmeow_privacy_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_privacy_tokens to fetch.
     */
    where: whatsmeow_privacy_tokensWhereUniqueInput
  }

  /**
   * whatsmeow_privacy_tokens findFirst
   */
  export type whatsmeow_privacy_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_privacy_tokens to fetch.
     */
    where?: whatsmeow_privacy_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_privacy_tokens to fetch.
     */
    orderBy?: whatsmeow_privacy_tokensOrderByWithRelationInput | whatsmeow_privacy_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_privacy_tokens.
     */
    cursor?: whatsmeow_privacy_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_privacy_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_privacy_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_privacy_tokens.
     */
    distinct?: Whatsmeow_privacy_tokensScalarFieldEnum | Whatsmeow_privacy_tokensScalarFieldEnum[]
  }

  /**
   * whatsmeow_privacy_tokens findFirstOrThrow
   */
  export type whatsmeow_privacy_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_privacy_tokens to fetch.
     */
    where?: whatsmeow_privacy_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_privacy_tokens to fetch.
     */
    orderBy?: whatsmeow_privacy_tokensOrderByWithRelationInput | whatsmeow_privacy_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_privacy_tokens.
     */
    cursor?: whatsmeow_privacy_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_privacy_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_privacy_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_privacy_tokens.
     */
    distinct?: Whatsmeow_privacy_tokensScalarFieldEnum | Whatsmeow_privacy_tokensScalarFieldEnum[]
  }

  /**
   * whatsmeow_privacy_tokens findMany
   */
  export type whatsmeow_privacy_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * Filter, which whatsmeow_privacy_tokens to fetch.
     */
    where?: whatsmeow_privacy_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_privacy_tokens to fetch.
     */
    orderBy?: whatsmeow_privacy_tokensOrderByWithRelationInput | whatsmeow_privacy_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_privacy_tokens.
     */
    cursor?: whatsmeow_privacy_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_privacy_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_privacy_tokens.
     */
    skip?: number
    distinct?: Whatsmeow_privacy_tokensScalarFieldEnum | Whatsmeow_privacy_tokensScalarFieldEnum[]
  }

  /**
   * whatsmeow_privacy_tokens create
   */
  export type whatsmeow_privacy_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_privacy_tokens.
     */
    data: XOR<whatsmeow_privacy_tokensCreateInput, whatsmeow_privacy_tokensUncheckedCreateInput>
  }

  /**
   * whatsmeow_privacy_tokens createMany
   */
  export type whatsmeow_privacy_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_privacy_tokens.
     */
    data: whatsmeow_privacy_tokensCreateManyInput | whatsmeow_privacy_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_privacy_tokens createManyAndReturn
   */
  export type whatsmeow_privacy_tokensCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_privacy_tokens.
     */
    data: whatsmeow_privacy_tokensCreateManyInput | whatsmeow_privacy_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_privacy_tokens update
   */
  export type whatsmeow_privacy_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_privacy_tokens.
     */
    data: XOR<whatsmeow_privacy_tokensUpdateInput, whatsmeow_privacy_tokensUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_privacy_tokens to update.
     */
    where: whatsmeow_privacy_tokensWhereUniqueInput
  }

  /**
   * whatsmeow_privacy_tokens updateMany
   */
  export type whatsmeow_privacy_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_privacy_tokens.
     */
    data: XOR<whatsmeow_privacy_tokensUpdateManyMutationInput, whatsmeow_privacy_tokensUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_privacy_tokens to update
     */
    where?: whatsmeow_privacy_tokensWhereInput
  }

  /**
   * whatsmeow_privacy_tokens updateManyAndReturn
   */
  export type whatsmeow_privacy_tokensUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_privacy_tokens.
     */
    data: XOR<whatsmeow_privacy_tokensUpdateManyMutationInput, whatsmeow_privacy_tokensUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_privacy_tokens to update
     */
    where?: whatsmeow_privacy_tokensWhereInput
  }

  /**
   * whatsmeow_privacy_tokens upsert
   */
  export type whatsmeow_privacy_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_privacy_tokens to update in case it exists.
     */
    where: whatsmeow_privacy_tokensWhereUniqueInput
    /**
     * In case the whatsmeow_privacy_tokens found by the `where` argument doesn't exist, create a new whatsmeow_privacy_tokens with this data.
     */
    create: XOR<whatsmeow_privacy_tokensCreateInput, whatsmeow_privacy_tokensUncheckedCreateInput>
    /**
     * In case the whatsmeow_privacy_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_privacy_tokensUpdateInput, whatsmeow_privacy_tokensUncheckedUpdateInput>
  }

  /**
   * whatsmeow_privacy_tokens delete
   */
  export type whatsmeow_privacy_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
    /**
     * Filter which whatsmeow_privacy_tokens to delete.
     */
    where: whatsmeow_privacy_tokensWhereUniqueInput
  }

  /**
   * whatsmeow_privacy_tokens deleteMany
   */
  export type whatsmeow_privacy_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_privacy_tokens to delete
     */
    where?: whatsmeow_privacy_tokensWhereInput
  }

  /**
   * whatsmeow_privacy_tokens without action
   */
  export type whatsmeow_privacy_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_privacy_tokens
     */
    select?: whatsmeow_privacy_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_privacy_tokens
     */
    omit?: whatsmeow_privacy_tokensOmit<ExtArgs> | null
  }


  /**
   * Model whatsmeow_sender_keys
   */

  export type AggregateWhatsmeow_sender_keys = {
    _count: Whatsmeow_sender_keysCountAggregateOutputType | null
    _min: Whatsmeow_sender_keysMinAggregateOutputType | null
    _max: Whatsmeow_sender_keysMaxAggregateOutputType | null
  }

  export type Whatsmeow_sender_keysMinAggregateOutputType = {
    our_jid: string | null
    chat_id: string | null
    sender_id: string | null
    sender_key: Uint8Array | null
  }

  export type Whatsmeow_sender_keysMaxAggregateOutputType = {
    our_jid: string | null
    chat_id: string | null
    sender_id: string | null
    sender_key: Uint8Array | null
  }

  export type Whatsmeow_sender_keysCountAggregateOutputType = {
    our_jid: number
    chat_id: number
    sender_id: number
    sender_key: number
    _all: number
  }


  export type Whatsmeow_sender_keysMinAggregateInputType = {
    our_jid?: true
    chat_id?: true
    sender_id?: true
    sender_key?: true
  }

  export type Whatsmeow_sender_keysMaxAggregateInputType = {
    our_jid?: true
    chat_id?: true
    sender_id?: true
    sender_key?: true
  }

  export type Whatsmeow_sender_keysCountAggregateInputType = {
    our_jid?: true
    chat_id?: true
    sender_id?: true
    sender_key?: true
    _all?: true
  }

  export type Whatsmeow_sender_keysAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_sender_keys to aggregate.
     */
    where?: whatsmeow_sender_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sender_keys to fetch.
     */
    orderBy?: whatsmeow_sender_keysOrderByWithRelationInput | whatsmeow_sender_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_sender_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sender_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sender_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_sender_keys
    **/
    _count?: true | Whatsmeow_sender_keysCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_sender_keysMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_sender_keysMaxAggregateInputType
  }

  export type GetWhatsmeow_sender_keysAggregateType<T extends Whatsmeow_sender_keysAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_sender_keys]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_sender_keys[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_sender_keys[P]>
  }




  export type whatsmeow_sender_keysGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_sender_keysWhereInput
    orderBy?: whatsmeow_sender_keysOrderByWithAggregationInput | whatsmeow_sender_keysOrderByWithAggregationInput[]
    by: Whatsmeow_sender_keysScalarFieldEnum[] | Whatsmeow_sender_keysScalarFieldEnum
    having?: whatsmeow_sender_keysScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_sender_keysCountAggregateInputType | true
    _min?: Whatsmeow_sender_keysMinAggregateInputType
    _max?: Whatsmeow_sender_keysMaxAggregateInputType
  }

  export type Whatsmeow_sender_keysGroupByOutputType = {
    our_jid: string
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
    _count: Whatsmeow_sender_keysCountAggregateOutputType | null
    _min: Whatsmeow_sender_keysMinAggregateOutputType | null
    _max: Whatsmeow_sender_keysMaxAggregateOutputType | null
  }

  type GetWhatsmeow_sender_keysGroupByPayload<T extends whatsmeow_sender_keysGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_sender_keysGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_sender_keysGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_sender_keysGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_sender_keysGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_sender_keysSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_id?: boolean
    sender_id?: boolean
    sender_key?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_sender_keys"]>

  export type whatsmeow_sender_keysSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_id?: boolean
    sender_id?: boolean
    sender_key?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_sender_keys"]>

  export type whatsmeow_sender_keysSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    chat_id?: boolean
    sender_id?: boolean
    sender_key?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_sender_keys"]>

  export type whatsmeow_sender_keysSelectScalar = {
    our_jid?: boolean
    chat_id?: boolean
    sender_id?: boolean
    sender_key?: boolean
  }

  export type whatsmeow_sender_keysOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "chat_id" | "sender_id" | "sender_key", ExtArgs["result"]["whatsmeow_sender_keys"]>
  export type whatsmeow_sender_keysInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_sender_keysIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_sender_keysIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_sender_keysPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_sender_keys"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      chat_id: string
      sender_id: string
      sender_key: Uint8Array
    }, ExtArgs["result"]["whatsmeow_sender_keys"]>
    composites: {}
  }

  type whatsmeow_sender_keysGetPayload<S extends boolean | null | undefined | whatsmeow_sender_keysDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_sender_keysPayload, S>

  type whatsmeow_sender_keysCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_sender_keysFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_sender_keysCountAggregateInputType | true
    }

  export interface whatsmeow_sender_keysDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_sender_keys'], meta: { name: 'whatsmeow_sender_keys' } }
    /**
     * Find zero or one Whatsmeow_sender_keys that matches the filter.
     * @param {whatsmeow_sender_keysFindUniqueArgs} args - Arguments to find a Whatsmeow_sender_keys
     * @example
     * // Get one Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_sender_keysFindUniqueArgs>(args: SelectSubset<T, whatsmeow_sender_keysFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_sender_keys that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_sender_keysFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_sender_keys
     * @example
     * // Get one Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_sender_keysFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_sender_keysFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_sender_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sender_keysFindFirstArgs} args - Arguments to find a Whatsmeow_sender_keys
     * @example
     * // Get one Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_sender_keysFindFirstArgs>(args?: SelectSubset<T, whatsmeow_sender_keysFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_sender_keys that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sender_keysFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_sender_keys
     * @example
     * // Get one Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_sender_keysFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_sender_keysFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_sender_keys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sender_keysFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findMany()
     * 
     * // Get first 10 Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_sender_keysWithOur_jidOnly = await prisma.whatsmeow_sender_keys.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_sender_keysFindManyArgs>(args?: SelectSubset<T, whatsmeow_sender_keysFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_sender_keys.
     * @param {whatsmeow_sender_keysCreateArgs} args - Arguments to create a Whatsmeow_sender_keys.
     * @example
     * // Create one Whatsmeow_sender_keys
     * const Whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.create({
     *   data: {
     *     // ... data to create a Whatsmeow_sender_keys
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_sender_keysCreateArgs>(args: SelectSubset<T, whatsmeow_sender_keysCreateArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_sender_keys.
     * @param {whatsmeow_sender_keysCreateManyArgs} args - Arguments to create many Whatsmeow_sender_keys.
     * @example
     * // Create many Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_sender_keysCreateManyArgs>(args?: SelectSubset<T, whatsmeow_sender_keysCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_sender_keys and returns the data saved in the database.
     * @param {whatsmeow_sender_keysCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_sender_keys.
     * @example
     * // Create many Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_sender_keys and only return the `our_jid`
     * const whatsmeow_sender_keysWithOur_jidOnly = await prisma.whatsmeow_sender_keys.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_sender_keysCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_sender_keysCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_sender_keys.
     * @param {whatsmeow_sender_keysDeleteArgs} args - Arguments to delete one Whatsmeow_sender_keys.
     * @example
     * // Delete one Whatsmeow_sender_keys
     * const Whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_sender_keys
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_sender_keysDeleteArgs>(args: SelectSubset<T, whatsmeow_sender_keysDeleteArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_sender_keys.
     * @param {whatsmeow_sender_keysUpdateArgs} args - Arguments to update one Whatsmeow_sender_keys.
     * @example
     * // Update one Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_sender_keysUpdateArgs>(args: SelectSubset<T, whatsmeow_sender_keysUpdateArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_sender_keys.
     * @param {whatsmeow_sender_keysDeleteManyArgs} args - Arguments to filter Whatsmeow_sender_keys to delete.
     * @example
     * // Delete a few Whatsmeow_sender_keys
     * const { count } = await prisma.whatsmeow_sender_keys.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_sender_keysDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_sender_keysDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_sender_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sender_keysUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_sender_keysUpdateManyArgs>(args: SelectSubset<T, whatsmeow_sender_keysUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_sender_keys and returns the data updated in the database.
     * @param {whatsmeow_sender_keysUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_sender_keys.
     * @example
     * // Update many Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_sender_keys and only return the `our_jid`
     * const whatsmeow_sender_keysWithOur_jidOnly = await prisma.whatsmeow_sender_keys.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_sender_keysUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_sender_keysUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_sender_keys.
     * @param {whatsmeow_sender_keysUpsertArgs} args - Arguments to update or create a Whatsmeow_sender_keys.
     * @example
     * // Update or create a Whatsmeow_sender_keys
     * const whatsmeow_sender_keys = await prisma.whatsmeow_sender_keys.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_sender_keys
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_sender_keys we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_sender_keysUpsertArgs>(args: SelectSubset<T, whatsmeow_sender_keysUpsertArgs<ExtArgs>>): Prisma__whatsmeow_sender_keysClient<$Result.GetResult<Prisma.$whatsmeow_sender_keysPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_sender_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sender_keysCountArgs} args - Arguments to filter Whatsmeow_sender_keys to count.
     * @example
     * // Count the number of Whatsmeow_sender_keys
     * const count = await prisma.whatsmeow_sender_keys.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_sender_keys we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_sender_keysCountArgs>(
      args?: Subset<T, whatsmeow_sender_keysCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_sender_keysCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_sender_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_sender_keysAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_sender_keysAggregateArgs>(args: Subset<T, Whatsmeow_sender_keysAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_sender_keysAggregateType<T>>

    /**
     * Group by Whatsmeow_sender_keys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sender_keysGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_sender_keysGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_sender_keysGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_sender_keysGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_sender_keysGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_sender_keysGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_sender_keys model
   */
  readonly fields: whatsmeow_sender_keysFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_sender_keys.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_sender_keysClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_sender_keys model
   */ 
  interface whatsmeow_sender_keysFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_sender_keys", 'String'>
    readonly chat_id: FieldRef<"whatsmeow_sender_keys", 'String'>
    readonly sender_id: FieldRef<"whatsmeow_sender_keys", 'String'>
    readonly sender_key: FieldRef<"whatsmeow_sender_keys", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_sender_keys findUnique
   */
  export type whatsmeow_sender_keysFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sender_keys to fetch.
     */
    where: whatsmeow_sender_keysWhereUniqueInput
  }

  /**
   * whatsmeow_sender_keys findUniqueOrThrow
   */
  export type whatsmeow_sender_keysFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sender_keys to fetch.
     */
    where: whatsmeow_sender_keysWhereUniqueInput
  }

  /**
   * whatsmeow_sender_keys findFirst
   */
  export type whatsmeow_sender_keysFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sender_keys to fetch.
     */
    where?: whatsmeow_sender_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sender_keys to fetch.
     */
    orderBy?: whatsmeow_sender_keysOrderByWithRelationInput | whatsmeow_sender_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_sender_keys.
     */
    cursor?: whatsmeow_sender_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sender_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sender_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_sender_keys.
     */
    distinct?: Whatsmeow_sender_keysScalarFieldEnum | Whatsmeow_sender_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_sender_keys findFirstOrThrow
   */
  export type whatsmeow_sender_keysFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sender_keys to fetch.
     */
    where?: whatsmeow_sender_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sender_keys to fetch.
     */
    orderBy?: whatsmeow_sender_keysOrderByWithRelationInput | whatsmeow_sender_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_sender_keys.
     */
    cursor?: whatsmeow_sender_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sender_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sender_keys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_sender_keys.
     */
    distinct?: Whatsmeow_sender_keysScalarFieldEnum | Whatsmeow_sender_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_sender_keys findMany
   */
  export type whatsmeow_sender_keysFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sender_keys to fetch.
     */
    where?: whatsmeow_sender_keysWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sender_keys to fetch.
     */
    orderBy?: whatsmeow_sender_keysOrderByWithRelationInput | whatsmeow_sender_keysOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_sender_keys.
     */
    cursor?: whatsmeow_sender_keysWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sender_keys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sender_keys.
     */
    skip?: number
    distinct?: Whatsmeow_sender_keysScalarFieldEnum | Whatsmeow_sender_keysScalarFieldEnum[]
  }

  /**
   * whatsmeow_sender_keys create
   */
  export type whatsmeow_sender_keysCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_sender_keys.
     */
    data: XOR<whatsmeow_sender_keysCreateInput, whatsmeow_sender_keysUncheckedCreateInput>
  }

  /**
   * whatsmeow_sender_keys createMany
   */
  export type whatsmeow_sender_keysCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_sender_keys.
     */
    data: whatsmeow_sender_keysCreateManyInput | whatsmeow_sender_keysCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_sender_keys createManyAndReturn
   */
  export type whatsmeow_sender_keysCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_sender_keys.
     */
    data: whatsmeow_sender_keysCreateManyInput | whatsmeow_sender_keysCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_sender_keys update
   */
  export type whatsmeow_sender_keysUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_sender_keys.
     */
    data: XOR<whatsmeow_sender_keysUpdateInput, whatsmeow_sender_keysUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_sender_keys to update.
     */
    where: whatsmeow_sender_keysWhereUniqueInput
  }

  /**
   * whatsmeow_sender_keys updateMany
   */
  export type whatsmeow_sender_keysUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_sender_keys.
     */
    data: XOR<whatsmeow_sender_keysUpdateManyMutationInput, whatsmeow_sender_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_sender_keys to update
     */
    where?: whatsmeow_sender_keysWhereInput
  }

  /**
   * whatsmeow_sender_keys updateManyAndReturn
   */
  export type whatsmeow_sender_keysUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_sender_keys.
     */
    data: XOR<whatsmeow_sender_keysUpdateManyMutationInput, whatsmeow_sender_keysUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_sender_keys to update
     */
    where?: whatsmeow_sender_keysWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_sender_keys upsert
   */
  export type whatsmeow_sender_keysUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_sender_keys to update in case it exists.
     */
    where: whatsmeow_sender_keysWhereUniqueInput
    /**
     * In case the whatsmeow_sender_keys found by the `where` argument doesn't exist, create a new whatsmeow_sender_keys with this data.
     */
    create: XOR<whatsmeow_sender_keysCreateInput, whatsmeow_sender_keysUncheckedCreateInput>
    /**
     * In case the whatsmeow_sender_keys was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_sender_keysUpdateInput, whatsmeow_sender_keysUncheckedUpdateInput>
  }

  /**
   * whatsmeow_sender_keys delete
   */
  export type whatsmeow_sender_keysDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_sender_keys to delete.
     */
    where: whatsmeow_sender_keysWhereUniqueInput
  }

  /**
   * whatsmeow_sender_keys deleteMany
   */
  export type whatsmeow_sender_keysDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_sender_keys to delete
     */
    where?: whatsmeow_sender_keysWhereInput
  }

  /**
   * whatsmeow_sender_keys without action
   */
  export type whatsmeow_sender_keysDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sender_keys
     */
    select?: whatsmeow_sender_keysSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sender_keys
     */
    omit?: whatsmeow_sender_keysOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sender_keysInclude<ExtArgs> | null
  }


  /**
   * Model whatsmeow_sessions
   */

  export type AggregateWhatsmeow_sessions = {
    _count: Whatsmeow_sessionsCountAggregateOutputType | null
    _min: Whatsmeow_sessionsMinAggregateOutputType | null
    _max: Whatsmeow_sessionsMaxAggregateOutputType | null
  }

  export type Whatsmeow_sessionsMinAggregateOutputType = {
    our_jid: string | null
    their_id: string | null
    session: Uint8Array | null
  }

  export type Whatsmeow_sessionsMaxAggregateOutputType = {
    our_jid: string | null
    their_id: string | null
    session: Uint8Array | null
  }

  export type Whatsmeow_sessionsCountAggregateOutputType = {
    our_jid: number
    their_id: number
    session: number
    _all: number
  }


  export type Whatsmeow_sessionsMinAggregateInputType = {
    our_jid?: true
    their_id?: true
    session?: true
  }

  export type Whatsmeow_sessionsMaxAggregateInputType = {
    our_jid?: true
    their_id?: true
    session?: true
  }

  export type Whatsmeow_sessionsCountAggregateInputType = {
    our_jid?: true
    their_id?: true
    session?: true
    _all?: true
  }

  export type Whatsmeow_sessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_sessions to aggregate.
     */
    where?: whatsmeow_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sessions to fetch.
     */
    orderBy?: whatsmeow_sessionsOrderByWithRelationInput | whatsmeow_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: whatsmeow_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned whatsmeow_sessions
    **/
    _count?: true | Whatsmeow_sessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Whatsmeow_sessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Whatsmeow_sessionsMaxAggregateInputType
  }

  export type GetWhatsmeow_sessionsAggregateType<T extends Whatsmeow_sessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateWhatsmeow_sessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhatsmeow_sessions[P]>
      : GetScalarType<T[P], AggregateWhatsmeow_sessions[P]>
  }




  export type whatsmeow_sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: whatsmeow_sessionsWhereInput
    orderBy?: whatsmeow_sessionsOrderByWithAggregationInput | whatsmeow_sessionsOrderByWithAggregationInput[]
    by: Whatsmeow_sessionsScalarFieldEnum[] | Whatsmeow_sessionsScalarFieldEnum
    having?: whatsmeow_sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Whatsmeow_sessionsCountAggregateInputType | true
    _min?: Whatsmeow_sessionsMinAggregateInputType
    _max?: Whatsmeow_sessionsMaxAggregateInputType
  }

  export type Whatsmeow_sessionsGroupByOutputType = {
    our_jid: string
    their_id: string
    session: Uint8Array | null
    _count: Whatsmeow_sessionsCountAggregateOutputType | null
    _min: Whatsmeow_sessionsMinAggregateOutputType | null
    _max: Whatsmeow_sessionsMaxAggregateOutputType | null
  }

  type GetWhatsmeow_sessionsGroupByPayload<T extends whatsmeow_sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Whatsmeow_sessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Whatsmeow_sessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Whatsmeow_sessionsGroupByOutputType[P]>
            : GetScalarType<T[P], Whatsmeow_sessionsGroupByOutputType[P]>
        }
      >
    >


  export type whatsmeow_sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_id?: boolean
    session?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_sessions"]>

  export type whatsmeow_sessionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_id?: boolean
    session?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_sessions"]>

  export type whatsmeow_sessionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    our_jid?: boolean
    their_id?: boolean
    session?: boolean
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whatsmeow_sessions"]>

  export type whatsmeow_sessionsSelectScalar = {
    our_jid?: boolean
    their_id?: boolean
    session?: boolean
  }

  export type whatsmeow_sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"our_jid" | "their_id" | "session", ExtArgs["result"]["whatsmeow_sessions"]>
  export type whatsmeow_sessionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_sessionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }
  export type whatsmeow_sessionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    whatsmeow_device?: boolean | whatsmeow_deviceDefaultArgs<ExtArgs>
  }

  export type $whatsmeow_sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "whatsmeow_sessions"
    objects: {
      whatsmeow_device: Prisma.$whatsmeow_devicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      our_jid: string
      their_id: string
      session: Uint8Array | null
    }, ExtArgs["result"]["whatsmeow_sessions"]>
    composites: {}
  }

  type whatsmeow_sessionsGetPayload<S extends boolean | null | undefined | whatsmeow_sessionsDefaultArgs> = $Result.GetResult<Prisma.$whatsmeow_sessionsPayload, S>

  type whatsmeow_sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<whatsmeow_sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Whatsmeow_sessionsCountAggregateInputType | true
    }

  export interface whatsmeow_sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['whatsmeow_sessions'], meta: { name: 'whatsmeow_sessions' } }
    /**
     * Find zero or one Whatsmeow_sessions that matches the filter.
     * @param {whatsmeow_sessionsFindUniqueArgs} args - Arguments to find a Whatsmeow_sessions
     * @example
     * // Get one Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends whatsmeow_sessionsFindUniqueArgs>(args: SelectSubset<T, whatsmeow_sessionsFindUniqueArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "findUnique", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find one Whatsmeow_sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {whatsmeow_sessionsFindUniqueOrThrowArgs} args - Arguments to find a Whatsmeow_sessions
     * @example
     * // Get one Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends whatsmeow_sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, whatsmeow_sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sessionsFindFirstArgs} args - Arguments to find a Whatsmeow_sessions
     * @example
     * // Get one Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends whatsmeow_sessionsFindFirstArgs>(args?: SelectSubset<T, whatsmeow_sessionsFindFirstArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "findFirst", ClientOptions> | null, null, ExtArgs, ClientOptions>

    /**
     * Find the first Whatsmeow_sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sessionsFindFirstOrThrowArgs} args - Arguments to find a Whatsmeow_sessions
     * @example
     * // Get one Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends whatsmeow_sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, whatsmeow_sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "findFirstOrThrow", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Find zero or more Whatsmeow_sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findMany()
     * 
     * // Get first 10 Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.findMany({ take: 10 })
     * 
     * // Only select the `our_jid`
     * const whatsmeow_sessionsWithOur_jidOnly = await prisma.whatsmeow_sessions.findMany({ select: { our_jid: true } })
     * 
     */
    findMany<T extends whatsmeow_sessionsFindManyArgs>(args?: SelectSubset<T, whatsmeow_sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "findMany", ClientOptions>>

    /**
     * Create a Whatsmeow_sessions.
     * @param {whatsmeow_sessionsCreateArgs} args - Arguments to create a Whatsmeow_sessions.
     * @example
     * // Create one Whatsmeow_sessions
     * const Whatsmeow_sessions = await prisma.whatsmeow_sessions.create({
     *   data: {
     *     // ... data to create a Whatsmeow_sessions
     *   }
     * })
     * 
     */
    create<T extends whatsmeow_sessionsCreateArgs>(args: SelectSubset<T, whatsmeow_sessionsCreateArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "create", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Create many Whatsmeow_sessions.
     * @param {whatsmeow_sessionsCreateManyArgs} args - Arguments to create many Whatsmeow_sessions.
     * @example
     * // Create many Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends whatsmeow_sessionsCreateManyArgs>(args?: SelectSubset<T, whatsmeow_sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Whatsmeow_sessions and returns the data saved in the database.
     * @param {whatsmeow_sessionsCreateManyAndReturnArgs} args - Arguments to create many Whatsmeow_sessions.
     * @example
     * // Create many Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Whatsmeow_sessions and only return the `our_jid`
     * const whatsmeow_sessionsWithOur_jidOnly = await prisma.whatsmeow_sessions.createManyAndReturn({
     *   select: { our_jid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends whatsmeow_sessionsCreateManyAndReturnArgs>(args?: SelectSubset<T, whatsmeow_sessionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "createManyAndReturn", ClientOptions>>

    /**
     * Delete a Whatsmeow_sessions.
     * @param {whatsmeow_sessionsDeleteArgs} args - Arguments to delete one Whatsmeow_sessions.
     * @example
     * // Delete one Whatsmeow_sessions
     * const Whatsmeow_sessions = await prisma.whatsmeow_sessions.delete({
     *   where: {
     *     // ... filter to delete one Whatsmeow_sessions
     *   }
     * })
     * 
     */
    delete<T extends whatsmeow_sessionsDeleteArgs>(args: SelectSubset<T, whatsmeow_sessionsDeleteArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "delete", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Update one Whatsmeow_sessions.
     * @param {whatsmeow_sessionsUpdateArgs} args - Arguments to update one Whatsmeow_sessions.
     * @example
     * // Update one Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends whatsmeow_sessionsUpdateArgs>(args: SelectSubset<T, whatsmeow_sessionsUpdateArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "update", ClientOptions>, never, ExtArgs, ClientOptions>

    /**
     * Delete zero or more Whatsmeow_sessions.
     * @param {whatsmeow_sessionsDeleteManyArgs} args - Arguments to filter Whatsmeow_sessions to delete.
     * @example
     * // Delete a few Whatsmeow_sessions
     * const { count } = await prisma.whatsmeow_sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends whatsmeow_sessionsDeleteManyArgs>(args?: SelectSubset<T, whatsmeow_sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends whatsmeow_sessionsUpdateManyArgs>(args: SelectSubset<T, whatsmeow_sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Whatsmeow_sessions and returns the data updated in the database.
     * @param {whatsmeow_sessionsUpdateManyAndReturnArgs} args - Arguments to update many Whatsmeow_sessions.
     * @example
     * // Update many Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Whatsmeow_sessions and only return the `our_jid`
     * const whatsmeow_sessionsWithOur_jidOnly = await prisma.whatsmeow_sessions.updateManyAndReturn({
     *   select: { our_jid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends whatsmeow_sessionsUpdateManyAndReturnArgs>(args: SelectSubset<T, whatsmeow_sessionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "updateManyAndReturn", ClientOptions>>

    /**
     * Create or update one Whatsmeow_sessions.
     * @param {whatsmeow_sessionsUpsertArgs} args - Arguments to update or create a Whatsmeow_sessions.
     * @example
     * // Update or create a Whatsmeow_sessions
     * const whatsmeow_sessions = await prisma.whatsmeow_sessions.upsert({
     *   create: {
     *     // ... data to create a Whatsmeow_sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Whatsmeow_sessions we want to update
     *   }
     * })
     */
    upsert<T extends whatsmeow_sessionsUpsertArgs>(args: SelectSubset<T, whatsmeow_sessionsUpsertArgs<ExtArgs>>): Prisma__whatsmeow_sessionsClient<$Result.GetResult<Prisma.$whatsmeow_sessionsPayload<ExtArgs>, T, "upsert", ClientOptions>, never, ExtArgs, ClientOptions>


    /**
     * Count the number of Whatsmeow_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sessionsCountArgs} args - Arguments to filter Whatsmeow_sessions to count.
     * @example
     * // Count the number of Whatsmeow_sessions
     * const count = await prisma.whatsmeow_sessions.count({
     *   where: {
     *     // ... the filter for the Whatsmeow_sessions we want to count
     *   }
     * })
    **/
    count<T extends whatsmeow_sessionsCountArgs>(
      args?: Subset<T, whatsmeow_sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Whatsmeow_sessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Whatsmeow_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Whatsmeow_sessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Whatsmeow_sessionsAggregateArgs>(args: Subset<T, Whatsmeow_sessionsAggregateArgs>): Prisma.PrismaPromise<GetWhatsmeow_sessionsAggregateType<T>>

    /**
     * Group by Whatsmeow_sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {whatsmeow_sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends whatsmeow_sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: whatsmeow_sessionsGroupByArgs['orderBy'] }
        : { orderBy?: whatsmeow_sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, whatsmeow_sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhatsmeow_sessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the whatsmeow_sessions model
   */
  readonly fields: whatsmeow_sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for whatsmeow_sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__whatsmeow_sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    whatsmeow_device<T extends whatsmeow_deviceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, whatsmeow_deviceDefaultArgs<ExtArgs>>): Prisma__whatsmeow_deviceClient<$Result.GetResult<Prisma.$whatsmeow_devicePayload<ExtArgs>, T, "findUniqueOrThrow", ClientOptions> | Null, Null, ExtArgs, ClientOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the whatsmeow_sessions model
   */ 
  interface whatsmeow_sessionsFieldRefs {
    readonly our_jid: FieldRef<"whatsmeow_sessions", 'String'>
    readonly their_id: FieldRef<"whatsmeow_sessions", 'String'>
    readonly session: FieldRef<"whatsmeow_sessions", 'Bytes'>
  }
    

  // Custom InputTypes
  /**
   * whatsmeow_sessions findUnique
   */
  export type whatsmeow_sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sessions to fetch.
     */
    where: whatsmeow_sessionsWhereUniqueInput
  }

  /**
   * whatsmeow_sessions findUniqueOrThrow
   */
  export type whatsmeow_sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sessions to fetch.
     */
    where: whatsmeow_sessionsWhereUniqueInput
  }

  /**
   * whatsmeow_sessions findFirst
   */
  export type whatsmeow_sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sessions to fetch.
     */
    where?: whatsmeow_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sessions to fetch.
     */
    orderBy?: whatsmeow_sessionsOrderByWithRelationInput | whatsmeow_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_sessions.
     */
    cursor?: whatsmeow_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_sessions.
     */
    distinct?: Whatsmeow_sessionsScalarFieldEnum | Whatsmeow_sessionsScalarFieldEnum[]
  }

  /**
   * whatsmeow_sessions findFirstOrThrow
   */
  export type whatsmeow_sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sessions to fetch.
     */
    where?: whatsmeow_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sessions to fetch.
     */
    orderBy?: whatsmeow_sessionsOrderByWithRelationInput | whatsmeow_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for whatsmeow_sessions.
     */
    cursor?: whatsmeow_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of whatsmeow_sessions.
     */
    distinct?: Whatsmeow_sessionsScalarFieldEnum | Whatsmeow_sessionsScalarFieldEnum[]
  }

  /**
   * whatsmeow_sessions findMany
   */
  export type whatsmeow_sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * Filter, which whatsmeow_sessions to fetch.
     */
    where?: whatsmeow_sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of whatsmeow_sessions to fetch.
     */
    orderBy?: whatsmeow_sessionsOrderByWithRelationInput | whatsmeow_sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing whatsmeow_sessions.
     */
    cursor?: whatsmeow_sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` whatsmeow_sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` whatsmeow_sessions.
     */
    skip?: number
    distinct?: Whatsmeow_sessionsScalarFieldEnum | Whatsmeow_sessionsScalarFieldEnum[]
  }

  /**
   * whatsmeow_sessions create
   */
  export type whatsmeow_sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to create a whatsmeow_sessions.
     */
    data: XOR<whatsmeow_sessionsCreateInput, whatsmeow_sessionsUncheckedCreateInput>
  }

  /**
   * whatsmeow_sessions createMany
   */
  export type whatsmeow_sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many whatsmeow_sessions.
     */
    data: whatsmeow_sessionsCreateManyInput | whatsmeow_sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * whatsmeow_sessions createManyAndReturn
   */
  export type whatsmeow_sessionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * The data used to create many whatsmeow_sessions.
     */
    data: whatsmeow_sessionsCreateManyInput | whatsmeow_sessionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_sessions update
   */
  export type whatsmeow_sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * The data needed to update a whatsmeow_sessions.
     */
    data: XOR<whatsmeow_sessionsUpdateInput, whatsmeow_sessionsUncheckedUpdateInput>
    /**
     * Choose, which whatsmeow_sessions to update.
     */
    where: whatsmeow_sessionsWhereUniqueInput
  }

  /**
   * whatsmeow_sessions updateMany
   */
  export type whatsmeow_sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update whatsmeow_sessions.
     */
    data: XOR<whatsmeow_sessionsUpdateManyMutationInput, whatsmeow_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_sessions to update
     */
    where?: whatsmeow_sessionsWhereInput
  }

  /**
   * whatsmeow_sessions updateManyAndReturn
   */
  export type whatsmeow_sessionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * The data used to update whatsmeow_sessions.
     */
    data: XOR<whatsmeow_sessionsUpdateManyMutationInput, whatsmeow_sessionsUncheckedUpdateManyInput>
    /**
     * Filter which whatsmeow_sessions to update
     */
    where?: whatsmeow_sessionsWhereInput
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * whatsmeow_sessions upsert
   */
  export type whatsmeow_sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * The filter to search for the whatsmeow_sessions to update in case it exists.
     */
    where: whatsmeow_sessionsWhereUniqueInput
    /**
     * In case the whatsmeow_sessions found by the `where` argument doesn't exist, create a new whatsmeow_sessions with this data.
     */
    create: XOR<whatsmeow_sessionsCreateInput, whatsmeow_sessionsUncheckedCreateInput>
    /**
     * In case the whatsmeow_sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<whatsmeow_sessionsUpdateInput, whatsmeow_sessionsUncheckedUpdateInput>
  }

  /**
   * whatsmeow_sessions delete
   */
  export type whatsmeow_sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
    /**
     * Filter which whatsmeow_sessions to delete.
     */
    where: whatsmeow_sessionsWhereUniqueInput
  }

  /**
   * whatsmeow_sessions deleteMany
   */
  export type whatsmeow_sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which whatsmeow_sessions to delete
     */
    where?: whatsmeow_sessionsWhereInput
  }

  /**
   * whatsmeow_sessions without action
   */
  export type whatsmeow_sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the whatsmeow_sessions
     */
    select?: whatsmeow_sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the whatsmeow_sessions
     */
    omit?: whatsmeow_sessionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: whatsmeow_sessionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const App_usersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    email: 'email',
    password_hash: 'password_hash',
    first_name: 'first_name',
    last_name: 'last_name',
    role: 'role',
    created_at: 'created_at',
    updated_at: 'updated_at',
    is_active: 'is_active'
  };

  export type App_usersScalarFieldEnum = (typeof App_usersScalarFieldEnum)[keyof typeof App_usersScalarFieldEnum]


  export const ChatAssignmentDetailScalarFieldEnum: {
    chatId: 'chatId',
    assignedTo: 'assignedTo',
    assignedBy: 'assignedBy',
    chatAssignmentDetailId: 'chatAssignmentDetailId',
    assignedAt: 'assignedAt'
  };

  export type ChatAssignmentDetailScalarFieldEnum = (typeof ChatAssignmentDetailScalarFieldEnum)[keyof typeof ChatAssignmentDetailScalarFieldEnum]


  export const ChatTagsScalarFieldEnum: {
    tagId: 'tagId',
    chatTagId: 'chatTagId',
    chatId: 'chatId',
    creationDate: 'creationDate',
    createdBy: 'createdBy'
  };

  export type ChatTagsScalarFieldEnum = (typeof ChatTagsScalarFieldEnum)[keyof typeof ChatTagsScalarFieldEnum]


  export const Chat_status_detailsScalarFieldEnum: {
    id: 'id',
    chat_id: 'chat_id',
    status: 'status',
    changed_by: 'changed_by',
    changed_at: 'changed_at',
    reason: 'reason',
    notes: 'notes'
  };

  export type Chat_status_detailsScalarFieldEnum = (typeof Chat_status_detailsScalarFieldEnum)[keyof typeof Chat_status_detailsScalarFieldEnum]


  export const ChatparticipantsScalarFieldEnum: {
    chatid: 'chatid',
    contactid: 'contactid'
  };

  export type ChatparticipantsScalarFieldEnum = (typeof ChatparticipantsScalarFieldEnum)[keyof typeof ChatparticipantsScalarFieldEnum]


  export const ChatsScalarFieldEnum: {
    id: 'id',
    lastMessage: 'lastMessage',
    lastMessageTime: 'lastMessageTime',
    unReadCount: 'unReadCount',
    isOnline: 'isOnline',
    contactId: 'contactId',
    isTyping: 'isTyping',
    userId: 'userId',
    pushname: 'pushname',
    assignedTo: 'assignedTo',
    isarchived: 'isarchived',
    ismuted: 'ismuted',
    status: 'status',
    closedAt: 'closedAt',
    closeReason: 'closeReason',
    participants: 'participants',
    avatar: 'avatar',
    isPinned: 'isPinned'
  };

  export type ChatsScalarFieldEnum = (typeof ChatsScalarFieldEnum)[keyof typeof ChatsScalarFieldEnum]


  export const Cleaned_contactsScalarFieldEnum: {
    phone: 'phone',
    first_name: 'first_name',
    full_name: 'full_name',
    push_name: 'push_name',
    business_name: 'business_name'
  };

  export type Cleaned_contactsScalarFieldEnum = (typeof Cleaned_contactsScalarFieldEnum)[keyof typeof Cleaned_contactsScalarFieldEnum]


  export const ContactsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    address: 'address',
    city: 'city',
    state: 'state',
    zip: 'zip',
    country: 'country',
    lastMessage: 'lastMessage',
    lastMessageTime: 'lastMessageTime',
    unReadCount: 'unReadCount',
    isTyping: 'isTyping',
    isOnline: 'isOnline',
    image: 'image',
    lastSeen: 'lastSeen',
    chatId: 'chatId',
    contactId: 'contactId',
    userId: 'userId',
    tags: 'tags'
  };

  export type ContactsScalarFieldEnum = (typeof ContactsScalarFieldEnum)[keyof typeof ContactsScalarFieldEnum]


  export const ConversationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    is_group: 'is_group',
    created_at: 'created_at'
  };

  export type ConversationsScalarFieldEnum = (typeof ConversationsScalarFieldEnum)[keyof typeof ConversationsScalarFieldEnum]


  export const GroupsScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type GroupsScalarFieldEnum = (typeof GroupsScalarFieldEnum)[keyof typeof GroupsScalarFieldEnum]


  export const MessageTemplatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    content: 'content',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedat: 'updatedat',
    imagePath: 'imagePath',
    mediaPath: 'mediaPath'
  };

  export type MessageTemplatesScalarFieldEnum = (typeof MessageTemplatesScalarFieldEnum)[keyof typeof MessageTemplatesScalarFieldEnum]


  export const Message_historyScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    chat_jid: 'chat_jid',
    sender_jid: 'sender_jid',
    message_id: 'message_id',
    timestamp: 'timestamp',
    message_type: 'message_type',
    text_content: 'text_content',
    media_link: 'media_link',
    quoted_message_id: 'quoted_message_id',
    datajson: 'datajson'
  };

  export type Message_historyScalarFieldEnum = (typeof Message_historyScalarFieldEnum)[keyof typeof Message_historyScalarFieldEnum]


  export const Message_reactionsScalarFieldEnum: {
    messageId: 'messageId',
    participant: 'participant',
    emoji: 'emoji',
    createdAt: 'createdAt',
    userId: 'userId',
    id: 'id'
  };

  export type Message_reactionsScalarFieldEnum = (typeof Message_reactionsScalarFieldEnum)[keyof typeof Message_reactionsScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    chatId: 'chatId',
    message: 'message',
    timeStamp: 'timeStamp',
    isDelivered: 'isDelivered',
    isRead: 'isRead',
    messageType: 'messageType',
    isFromMe: 'isFromMe',
    contactId: 'contactId',
    isEdit: 'isEdit',
    pushname: 'pushname',
    mediaPath: 'mediaPath',
    note: 'note',
    isPinned: 'isPinned',
    userId: 'userId',
    replyToMessageId: 'replyToMessageId'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    applied_at: 'applied_at'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const TagsScalarFieldEnum: {
    tagId: 'tagId',
    tagName: 'tagName'
  };

  export type TagsScalarFieldEnum = (typeof TagsScalarFieldEnum)[keyof typeof TagsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    token: 'token',
    webhook: 'webhook',
    jid: 'jid',
    qrcode: 'qrcode',
    connected: 'connected',
    expiration: 'expiration',
    events: 'events',
    proxy_url: 'proxy_url',
    s3_enabled: 's3_enabled',
    s3_endpoint: 's3_endpoint',
    s3_region: 's3_region',
    s3_bucket: 's3_bucket',
    s3_access_key: 's3_access_key',
    s3_secret_key: 's3_secret_key',
    s3_path_style: 's3_path_style',
    s3_public_url: 's3_public_url',
    media_delivery: 'media_delivery',
    s3_retention_days: 's3_retention_days',
    history: 'history',
    hmac_key: 'hmac_key'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Whatsmeow_app_state_mutation_macsScalarFieldEnum: {
    jid: 'jid',
    name: 'name',
    version: 'version',
    index_mac: 'index_mac',
    value_mac: 'value_mac'
  };

  export type Whatsmeow_app_state_mutation_macsScalarFieldEnum = (typeof Whatsmeow_app_state_mutation_macsScalarFieldEnum)[keyof typeof Whatsmeow_app_state_mutation_macsScalarFieldEnum]


  export const Whatsmeow_app_state_sync_keysScalarFieldEnum: {
    jid: 'jid',
    key_id: 'key_id',
    key_data: 'key_data',
    timestamp: 'timestamp',
    fingerprint: 'fingerprint'
  };

  export type Whatsmeow_app_state_sync_keysScalarFieldEnum = (typeof Whatsmeow_app_state_sync_keysScalarFieldEnum)[keyof typeof Whatsmeow_app_state_sync_keysScalarFieldEnum]


  export const Whatsmeow_app_state_versionScalarFieldEnum: {
    jid: 'jid',
    name: 'name',
    version: 'version',
    hash: 'hash'
  };

  export type Whatsmeow_app_state_versionScalarFieldEnum = (typeof Whatsmeow_app_state_versionScalarFieldEnum)[keyof typeof Whatsmeow_app_state_versionScalarFieldEnum]


  export const Whatsmeow_chat_settingsScalarFieldEnum: {
    our_jid: 'our_jid',
    chat_jid: 'chat_jid',
    muted_until: 'muted_until',
    pinned: 'pinned',
    archived: 'archived'
  };

  export type Whatsmeow_chat_settingsScalarFieldEnum = (typeof Whatsmeow_chat_settingsScalarFieldEnum)[keyof typeof Whatsmeow_chat_settingsScalarFieldEnum]


  export const Whatsmeow_contactsScalarFieldEnum: {
    our_jid: 'our_jid',
    their_jid: 'their_jid',
    first_name: 'first_name',
    full_name: 'full_name',
    push_name: 'push_name',
    business_name: 'business_name',
    redacted_phone: 'redacted_phone'
  };

  export type Whatsmeow_contactsScalarFieldEnum = (typeof Whatsmeow_contactsScalarFieldEnum)[keyof typeof Whatsmeow_contactsScalarFieldEnum]


  export const Whatsmeow_deviceScalarFieldEnum: {
    jid: 'jid',
    lid: 'lid',
    facebook_uuid: 'facebook_uuid',
    registration_id: 'registration_id',
    noise_key: 'noise_key',
    identity_key: 'identity_key',
    signed_pre_key: 'signed_pre_key',
    signed_pre_key_id: 'signed_pre_key_id',
    signed_pre_key_sig: 'signed_pre_key_sig',
    adv_key: 'adv_key',
    adv_details: 'adv_details',
    adv_account_sig: 'adv_account_sig',
    adv_account_sig_key: 'adv_account_sig_key',
    adv_device_sig: 'adv_device_sig',
    platform: 'platform',
    business_name: 'business_name',
    push_name: 'push_name',
    lid_migration_ts: 'lid_migration_ts'
  };

  export type Whatsmeow_deviceScalarFieldEnum = (typeof Whatsmeow_deviceScalarFieldEnum)[keyof typeof Whatsmeow_deviceScalarFieldEnum]


  export const Whatsmeow_event_bufferScalarFieldEnum: {
    our_jid: 'our_jid',
    ciphertext_hash: 'ciphertext_hash',
    plaintext: 'plaintext',
    server_timestamp: 'server_timestamp',
    insert_timestamp: 'insert_timestamp'
  };

  export type Whatsmeow_event_bufferScalarFieldEnum = (typeof Whatsmeow_event_bufferScalarFieldEnum)[keyof typeof Whatsmeow_event_bufferScalarFieldEnum]


  export const Whatsmeow_identity_keysScalarFieldEnum: {
    our_jid: 'our_jid',
    their_id: 'their_id',
    identity: 'identity'
  };

  export type Whatsmeow_identity_keysScalarFieldEnum = (typeof Whatsmeow_identity_keysScalarFieldEnum)[keyof typeof Whatsmeow_identity_keysScalarFieldEnum]


  export const Whatsmeow_lid_mapScalarFieldEnum: {
    lid: 'lid',
    pn: 'pn'
  };

  export type Whatsmeow_lid_mapScalarFieldEnum = (typeof Whatsmeow_lid_mapScalarFieldEnum)[keyof typeof Whatsmeow_lid_mapScalarFieldEnum]


  export const Whatsmeow_message_secretsScalarFieldEnum: {
    our_jid: 'our_jid',
    chat_jid: 'chat_jid',
    sender_jid: 'sender_jid',
    message_id: 'message_id',
    key: 'key'
  };

  export type Whatsmeow_message_secretsScalarFieldEnum = (typeof Whatsmeow_message_secretsScalarFieldEnum)[keyof typeof Whatsmeow_message_secretsScalarFieldEnum]


  export const Whatsmeow_pre_keysScalarFieldEnum: {
    jid: 'jid',
    key_id: 'key_id',
    key: 'key',
    uploaded: 'uploaded'
  };

  export type Whatsmeow_pre_keysScalarFieldEnum = (typeof Whatsmeow_pre_keysScalarFieldEnum)[keyof typeof Whatsmeow_pre_keysScalarFieldEnum]


  export const Whatsmeow_privacy_tokensScalarFieldEnum: {
    our_jid: 'our_jid',
    their_jid: 'their_jid',
    token: 'token',
    timestamp: 'timestamp'
  };

  export type Whatsmeow_privacy_tokensScalarFieldEnum = (typeof Whatsmeow_privacy_tokensScalarFieldEnum)[keyof typeof Whatsmeow_privacy_tokensScalarFieldEnum]


  export const Whatsmeow_sender_keysScalarFieldEnum: {
    our_jid: 'our_jid',
    chat_id: 'chat_id',
    sender_id: 'sender_id',
    sender_key: 'sender_key'
  };

  export type Whatsmeow_sender_keysScalarFieldEnum = (typeof Whatsmeow_sender_keysScalarFieldEnum)[keyof typeof Whatsmeow_sender_keysScalarFieldEnum]


  export const Whatsmeow_sessionsScalarFieldEnum: {
    our_jid: 'our_jid',
    their_id: 'their_id',
    session: 'session'
  };

  export type Whatsmeow_sessionsScalarFieldEnum = (typeof Whatsmeow_sessionsScalarFieldEnum)[keyof typeof Whatsmeow_sessionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type app_usersWhereInput = {
    AND?: app_usersWhereInput | app_usersWhereInput[]
    OR?: app_usersWhereInput[]
    NOT?: app_usersWhereInput | app_usersWhereInput[]
    id?: UuidFilter<"app_users"> | string
    username?: StringFilter<"app_users"> | string
    email?: StringFilter<"app_users"> | string
    password_hash?: StringFilter<"app_users"> | string
    first_name?: StringNullableFilter<"app_users"> | string | null
    last_name?: StringNullableFilter<"app_users"> | string | null
    role?: StringNullableFilter<"app_users"> | string | null
    created_at?: DateTimeNullableFilter<"app_users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"app_users"> | Date | string | null
    is_active?: BoolNullableFilter<"app_users"> | boolean | null
  }

  export type app_usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
  }

  export type app_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: app_usersWhereInput | app_usersWhereInput[]
    OR?: app_usersWhereInput[]
    NOT?: app_usersWhereInput | app_usersWhereInput[]
    password_hash?: StringFilter<"app_users"> | string
    first_name?: StringNullableFilter<"app_users"> | string | null
    last_name?: StringNullableFilter<"app_users"> | string | null
    role?: StringNullableFilter<"app_users"> | string | null
    created_at?: DateTimeNullableFilter<"app_users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"app_users"> | Date | string | null
    is_active?: BoolNullableFilter<"app_users"> | boolean | null
  }, "id" | "username" | "email">

  export type app_usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrderInput | SortOrder
    last_name?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    is_active?: SortOrderInput | SortOrder
    _count?: app_usersCountOrderByAggregateInput
    _max?: app_usersMaxOrderByAggregateInput
    _min?: app_usersMinOrderByAggregateInput
  }

  export type app_usersScalarWhereWithAggregatesInput = {
    AND?: app_usersScalarWhereWithAggregatesInput | app_usersScalarWhereWithAggregatesInput[]
    OR?: app_usersScalarWhereWithAggregatesInput[]
    NOT?: app_usersScalarWhereWithAggregatesInput | app_usersScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"app_users"> | string
    username?: StringWithAggregatesFilter<"app_users"> | string
    email?: StringWithAggregatesFilter<"app_users"> | string
    password_hash?: StringWithAggregatesFilter<"app_users"> | string
    first_name?: StringNullableWithAggregatesFilter<"app_users"> | string | null
    last_name?: StringNullableWithAggregatesFilter<"app_users"> | string | null
    role?: StringNullableWithAggregatesFilter<"app_users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"app_users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"app_users"> | Date | string | null
    is_active?: BoolNullableWithAggregatesFilter<"app_users"> | boolean | null
  }

  export type chatAssignmentDetailWhereInput = {
    AND?: chatAssignmentDetailWhereInput | chatAssignmentDetailWhereInput[]
    OR?: chatAssignmentDetailWhereInput[]
    NOT?: chatAssignmentDetailWhereInput | chatAssignmentDetailWhereInput[]
    chatId?: StringNullableFilter<"chatAssignmentDetail"> | string | null
    assignedTo?: StringNullableFilter<"chatAssignmentDetail"> | string | null
    assignedBy?: StringNullableFilter<"chatAssignmentDetail"> | string | null
    chatAssignmentDetailId?: BigIntFilter<"chatAssignmentDetail"> | bigint | number
    assignedAt?: DateTimeNullableFilter<"chatAssignmentDetail"> | Date | string | null
  }

  export type chatAssignmentDetailOrderByWithRelationInput = {
    chatId?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    chatAssignmentDetailId?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
  }

  export type chatAssignmentDetailWhereUniqueInput = Prisma.AtLeast<{
    chatAssignmentDetailId?: bigint | number
    chatId_assignedTo?: chatAssignmentDetailChatIdAssignedToCompoundUniqueInput
    AND?: chatAssignmentDetailWhereInput | chatAssignmentDetailWhereInput[]
    OR?: chatAssignmentDetailWhereInput[]
    NOT?: chatAssignmentDetailWhereInput | chatAssignmentDetailWhereInput[]
    chatId?: StringNullableFilter<"chatAssignmentDetail"> | string | null
    assignedTo?: StringNullableFilter<"chatAssignmentDetail"> | string | null
    assignedBy?: StringNullableFilter<"chatAssignmentDetail"> | string | null
    assignedAt?: DateTimeNullableFilter<"chatAssignmentDetail"> | Date | string | null
  }, "chatAssignmentDetailId" | "chatId_assignedTo">

  export type chatAssignmentDetailOrderByWithAggregationInput = {
    chatId?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    assignedBy?: SortOrderInput | SortOrder
    chatAssignmentDetailId?: SortOrder
    assignedAt?: SortOrderInput | SortOrder
    _count?: chatAssignmentDetailCountOrderByAggregateInput
    _avg?: chatAssignmentDetailAvgOrderByAggregateInput
    _max?: chatAssignmentDetailMaxOrderByAggregateInput
    _min?: chatAssignmentDetailMinOrderByAggregateInput
    _sum?: chatAssignmentDetailSumOrderByAggregateInput
  }

  export type chatAssignmentDetailScalarWhereWithAggregatesInput = {
    AND?: chatAssignmentDetailScalarWhereWithAggregatesInput | chatAssignmentDetailScalarWhereWithAggregatesInput[]
    OR?: chatAssignmentDetailScalarWhereWithAggregatesInput[]
    NOT?: chatAssignmentDetailScalarWhereWithAggregatesInput | chatAssignmentDetailScalarWhereWithAggregatesInput[]
    chatId?: StringNullableWithAggregatesFilter<"chatAssignmentDetail"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"chatAssignmentDetail"> | string | null
    assignedBy?: StringNullableWithAggregatesFilter<"chatAssignmentDetail"> | string | null
    chatAssignmentDetailId?: BigIntWithAggregatesFilter<"chatAssignmentDetail"> | bigint | number
    assignedAt?: DateTimeNullableWithAggregatesFilter<"chatAssignmentDetail"> | Date | string | null
  }

  export type chatTagsWhereInput = {
    AND?: chatTagsWhereInput | chatTagsWhereInput[]
    OR?: chatTagsWhereInput[]
    NOT?: chatTagsWhereInput | chatTagsWhereInput[]
    tagId?: BigIntFilter<"chatTags"> | bigint | number
    chatTagId?: BigIntFilter<"chatTags"> | bigint | number
    chatId?: StringNullableFilter<"chatTags"> | string | null
    creationDate?: DateTimeNullableFilter<"chatTags"> | Date | string | null
    createdBy?: StringNullableFilter<"chatTags"> | string | null
  }

  export type chatTagsOrderByWithRelationInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
    chatId?: SortOrderInput | SortOrder
    creationDate?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
  }

  export type chatTagsWhereUniqueInput = Prisma.AtLeast<{
    chatTagId?: bigint | number
    AND?: chatTagsWhereInput | chatTagsWhereInput[]
    OR?: chatTagsWhereInput[]
    NOT?: chatTagsWhereInput | chatTagsWhereInput[]
    tagId?: BigIntFilter<"chatTags"> | bigint | number
    chatId?: StringNullableFilter<"chatTags"> | string | null
    creationDate?: DateTimeNullableFilter<"chatTags"> | Date | string | null
    createdBy?: StringNullableFilter<"chatTags"> | string | null
  }, "chatTagId">

  export type chatTagsOrderByWithAggregationInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
    chatId?: SortOrderInput | SortOrder
    creationDate?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    _count?: chatTagsCountOrderByAggregateInput
    _avg?: chatTagsAvgOrderByAggregateInput
    _max?: chatTagsMaxOrderByAggregateInput
    _min?: chatTagsMinOrderByAggregateInput
    _sum?: chatTagsSumOrderByAggregateInput
  }

  export type chatTagsScalarWhereWithAggregatesInput = {
    AND?: chatTagsScalarWhereWithAggregatesInput | chatTagsScalarWhereWithAggregatesInput[]
    OR?: chatTagsScalarWhereWithAggregatesInput[]
    NOT?: chatTagsScalarWhereWithAggregatesInput | chatTagsScalarWhereWithAggregatesInput[]
    tagId?: BigIntWithAggregatesFilter<"chatTags"> | bigint | number
    chatTagId?: BigIntWithAggregatesFilter<"chatTags"> | bigint | number
    chatId?: StringNullableWithAggregatesFilter<"chatTags"> | string | null
    creationDate?: DateTimeNullableWithAggregatesFilter<"chatTags"> | Date | string | null
    createdBy?: StringNullableWithAggregatesFilter<"chatTags"> | string | null
  }

  export type chat_status_detailsWhereInput = {
    AND?: chat_status_detailsWhereInput | chat_status_detailsWhereInput[]
    OR?: chat_status_detailsWhereInput[]
    NOT?: chat_status_detailsWhereInput | chat_status_detailsWhereInput[]
    id?: IntFilter<"chat_status_details"> | number
    chat_id?: StringFilter<"chat_status_details"> | string
    status?: StringFilter<"chat_status_details"> | string
    changed_by?: StringNullableFilter<"chat_status_details"> | string | null
    changed_at?: DateTimeNullableFilter<"chat_status_details"> | Date | string | null
    reason?: StringNullableFilter<"chat_status_details"> | string | null
    notes?: StringNullableFilter<"chat_status_details"> | string | null
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
  }

  export type chat_status_detailsOrderByWithRelationInput = {
    id?: SortOrder
    chat_id?: SortOrder
    status?: SortOrder
    changed_by?: SortOrderInput | SortOrder
    changed_at?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    chats?: chatsOrderByWithRelationInput
  }

  export type chat_status_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: chat_status_detailsWhereInput | chat_status_detailsWhereInput[]
    OR?: chat_status_detailsWhereInput[]
    NOT?: chat_status_detailsWhereInput | chat_status_detailsWhereInput[]
    chat_id?: StringFilter<"chat_status_details"> | string
    status?: StringFilter<"chat_status_details"> | string
    changed_by?: StringNullableFilter<"chat_status_details"> | string | null
    changed_at?: DateTimeNullableFilter<"chat_status_details"> | Date | string | null
    reason?: StringNullableFilter<"chat_status_details"> | string | null
    notes?: StringNullableFilter<"chat_status_details"> | string | null
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
  }, "id">

  export type chat_status_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    chat_id?: SortOrder
    status?: SortOrder
    changed_by?: SortOrderInput | SortOrder
    changed_at?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: chat_status_detailsCountOrderByAggregateInput
    _avg?: chat_status_detailsAvgOrderByAggregateInput
    _max?: chat_status_detailsMaxOrderByAggregateInput
    _min?: chat_status_detailsMinOrderByAggregateInput
    _sum?: chat_status_detailsSumOrderByAggregateInput
  }

  export type chat_status_detailsScalarWhereWithAggregatesInput = {
    AND?: chat_status_detailsScalarWhereWithAggregatesInput | chat_status_detailsScalarWhereWithAggregatesInput[]
    OR?: chat_status_detailsScalarWhereWithAggregatesInput[]
    NOT?: chat_status_detailsScalarWhereWithAggregatesInput | chat_status_detailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"chat_status_details"> | number
    chat_id?: StringWithAggregatesFilter<"chat_status_details"> | string
    status?: StringWithAggregatesFilter<"chat_status_details"> | string
    changed_by?: StringNullableWithAggregatesFilter<"chat_status_details"> | string | null
    changed_at?: DateTimeNullableWithAggregatesFilter<"chat_status_details"> | Date | string | null
    reason?: StringNullableWithAggregatesFilter<"chat_status_details"> | string | null
    notes?: StringNullableWithAggregatesFilter<"chat_status_details"> | string | null
  }

  export type chatparticipantsWhereInput = {
    AND?: chatparticipantsWhereInput | chatparticipantsWhereInput[]
    OR?: chatparticipantsWhereInput[]
    NOT?: chatparticipantsWhereInput | chatparticipantsWhereInput[]
    chatid?: StringFilter<"chatparticipants"> | string
    contactid?: StringFilter<"chatparticipants"> | string
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    contacts?: XOR<ContactsScalarRelationFilter, contactsWhereInput>
  }

  export type chatparticipantsOrderByWithRelationInput = {
    chatid?: SortOrder
    contactid?: SortOrder
    chats?: chatsOrderByWithRelationInput
    contacts?: contactsOrderByWithRelationInput
  }

  export type chatparticipantsWhereUniqueInput = Prisma.AtLeast<{
    chatid_contactid?: chatparticipantsChatidContactidCompoundUniqueInput
    AND?: chatparticipantsWhereInput | chatparticipantsWhereInput[]
    OR?: chatparticipantsWhereInput[]
    NOT?: chatparticipantsWhereInput | chatparticipantsWhereInput[]
    chatid?: StringFilter<"chatparticipants"> | string
    contactid?: StringFilter<"chatparticipants"> | string
    chats?: XOR<ChatsScalarRelationFilter, chatsWhereInput>
    contacts?: XOR<ContactsScalarRelationFilter, contactsWhereInput>
  }, "chatid_contactid">

  export type chatparticipantsOrderByWithAggregationInput = {
    chatid?: SortOrder
    contactid?: SortOrder
    _count?: chatparticipantsCountOrderByAggregateInput
    _max?: chatparticipantsMaxOrderByAggregateInput
    _min?: chatparticipantsMinOrderByAggregateInput
  }

  export type chatparticipantsScalarWhereWithAggregatesInput = {
    AND?: chatparticipantsScalarWhereWithAggregatesInput | chatparticipantsScalarWhereWithAggregatesInput[]
    OR?: chatparticipantsScalarWhereWithAggregatesInput[]
    NOT?: chatparticipantsScalarWhereWithAggregatesInput | chatparticipantsScalarWhereWithAggregatesInput[]
    chatid?: StringWithAggregatesFilter<"chatparticipants"> | string
    contactid?: StringWithAggregatesFilter<"chatparticipants"> | string
  }

  export type chatsWhereInput = {
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    id?: StringFilter<"chats"> | string
    lastMessage?: StringNullableFilter<"chats"> | string | null
    lastMessageTime?: DateTimeNullableFilter<"chats"> | Date | string | null
    unReadCount?: IntNullableFilter<"chats"> | number | null
    isOnline?: BoolNullableFilter<"chats"> | boolean | null
    contactId?: StringNullableFilter<"chats"> | string | null
    isTyping?: StringNullableFilter<"chats"> | string | null
    userId?: StringNullableFilter<"chats"> | string | null
    pushname?: StringNullableFilter<"chats"> | string | null
    assignedTo?: StringNullableFilter<"chats"> | string | null
    isarchived?: BoolNullableFilter<"chats"> | boolean | null
    ismuted?: BoolNullableFilter<"chats"> | boolean | null
    status?: StringNullableFilter<"chats"> | string | null
    closedAt?: DateTimeNullableFilter<"chats"> | Date | string | null
    closeReason?: StringNullableFilter<"chats"> | string | null
    participants?: JsonNullableFilter<"chats">
    avatar?: StringNullableFilter<"chats"> | string | null
    isPinned?: BoolNullableFilter<"chats"> | boolean | null
    chat_status_details?: Chat_status_detailsListRelationFilter
    chatparticipants?: ChatparticipantsListRelationFilter
    messages?: MessagesListRelationFilter
  }

  export type chatsOrderByWithRelationInput = {
    id?: SortOrder
    lastMessage?: SortOrderInput | SortOrder
    lastMessageTime?: SortOrderInput | SortOrder
    unReadCount?: SortOrderInput | SortOrder
    isOnline?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    isTyping?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    pushname?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    isarchived?: SortOrderInput | SortOrder
    ismuted?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    closeReason?: SortOrderInput | SortOrder
    participants?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isPinned?: SortOrderInput | SortOrder
    chat_status_details?: chat_status_detailsOrderByRelationAggregateInput
    chatparticipants?: chatparticipantsOrderByRelationAggregateInput
    messages?: messagesOrderByRelationAggregateInput
  }

  export type chatsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: chatsWhereInput | chatsWhereInput[]
    OR?: chatsWhereInput[]
    NOT?: chatsWhereInput | chatsWhereInput[]
    lastMessage?: StringNullableFilter<"chats"> | string | null
    lastMessageTime?: DateTimeNullableFilter<"chats"> | Date | string | null
    unReadCount?: IntNullableFilter<"chats"> | number | null
    isOnline?: BoolNullableFilter<"chats"> | boolean | null
    contactId?: StringNullableFilter<"chats"> | string | null
    isTyping?: StringNullableFilter<"chats"> | string | null
    userId?: StringNullableFilter<"chats"> | string | null
    pushname?: StringNullableFilter<"chats"> | string | null
    assignedTo?: StringNullableFilter<"chats"> | string | null
    isarchived?: BoolNullableFilter<"chats"> | boolean | null
    ismuted?: BoolNullableFilter<"chats"> | boolean | null
    status?: StringNullableFilter<"chats"> | string | null
    closedAt?: DateTimeNullableFilter<"chats"> | Date | string | null
    closeReason?: StringNullableFilter<"chats"> | string | null
    participants?: JsonNullableFilter<"chats">
    avatar?: StringNullableFilter<"chats"> | string | null
    isPinned?: BoolNullableFilter<"chats"> | boolean | null
    chat_status_details?: Chat_status_detailsListRelationFilter
    chatparticipants?: ChatparticipantsListRelationFilter
    messages?: MessagesListRelationFilter
  }, "id">

  export type chatsOrderByWithAggregationInput = {
    id?: SortOrder
    lastMessage?: SortOrderInput | SortOrder
    lastMessageTime?: SortOrderInput | SortOrder
    unReadCount?: SortOrderInput | SortOrder
    isOnline?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    isTyping?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    pushname?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    isarchived?: SortOrderInput | SortOrder
    ismuted?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    closedAt?: SortOrderInput | SortOrder
    closeReason?: SortOrderInput | SortOrder
    participants?: SortOrderInput | SortOrder
    avatar?: SortOrderInput | SortOrder
    isPinned?: SortOrderInput | SortOrder
    _count?: chatsCountOrderByAggregateInput
    _avg?: chatsAvgOrderByAggregateInput
    _max?: chatsMaxOrderByAggregateInput
    _min?: chatsMinOrderByAggregateInput
    _sum?: chatsSumOrderByAggregateInput
  }

  export type chatsScalarWhereWithAggregatesInput = {
    AND?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    OR?: chatsScalarWhereWithAggregatesInput[]
    NOT?: chatsScalarWhereWithAggregatesInput | chatsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"chats"> | string
    lastMessage?: StringNullableWithAggregatesFilter<"chats"> | string | null
    lastMessageTime?: DateTimeNullableWithAggregatesFilter<"chats"> | Date | string | null
    unReadCount?: IntNullableWithAggregatesFilter<"chats"> | number | null
    isOnline?: BoolNullableWithAggregatesFilter<"chats"> | boolean | null
    contactId?: StringNullableWithAggregatesFilter<"chats"> | string | null
    isTyping?: StringNullableWithAggregatesFilter<"chats"> | string | null
    userId?: StringNullableWithAggregatesFilter<"chats"> | string | null
    pushname?: StringNullableWithAggregatesFilter<"chats"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"chats"> | string | null
    isarchived?: BoolNullableWithAggregatesFilter<"chats"> | boolean | null
    ismuted?: BoolNullableWithAggregatesFilter<"chats"> | boolean | null
    status?: StringNullableWithAggregatesFilter<"chats"> | string | null
    closedAt?: DateTimeNullableWithAggregatesFilter<"chats"> | Date | string | null
    closeReason?: StringNullableWithAggregatesFilter<"chats"> | string | null
    participants?: JsonNullableWithAggregatesFilter<"chats">
    avatar?: StringNullableWithAggregatesFilter<"chats"> | string | null
    isPinned?: BoolNullableWithAggregatesFilter<"chats"> | boolean | null
  }

  export type cleaned_contactsWhereInput = {
    AND?: cleaned_contactsWhereInput | cleaned_contactsWhereInput[]
    OR?: cleaned_contactsWhereInput[]
    NOT?: cleaned_contactsWhereInput | cleaned_contactsWhereInput[]
    phone?: StringFilter<"cleaned_contacts"> | string
    first_name?: StringNullableFilter<"cleaned_contacts"> | string | null
    full_name?: StringNullableFilter<"cleaned_contacts"> | string | null
    push_name?: StringNullableFilter<"cleaned_contacts"> | string | null
    business_name?: StringNullableFilter<"cleaned_contacts"> | string | null
  }

  export type cleaned_contactsOrderByWithRelationInput = {
    phone?: SortOrder
    first_name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    push_name?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
  }

  export type cleaned_contactsWhereUniqueInput = Prisma.AtLeast<{
    phone?: string
    AND?: cleaned_contactsWhereInput | cleaned_contactsWhereInput[]
    OR?: cleaned_contactsWhereInput[]
    NOT?: cleaned_contactsWhereInput | cleaned_contactsWhereInput[]
    first_name?: StringNullableFilter<"cleaned_contacts"> | string | null
    full_name?: StringNullableFilter<"cleaned_contacts"> | string | null
    push_name?: StringNullableFilter<"cleaned_contacts"> | string | null
    business_name?: StringNullableFilter<"cleaned_contacts"> | string | null
  }, "phone">

  export type cleaned_contactsOrderByWithAggregationInput = {
    phone?: SortOrder
    first_name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    push_name?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    _count?: cleaned_contactsCountOrderByAggregateInput
    _max?: cleaned_contactsMaxOrderByAggregateInput
    _min?: cleaned_contactsMinOrderByAggregateInput
  }

  export type cleaned_contactsScalarWhereWithAggregatesInput = {
    AND?: cleaned_contactsScalarWhereWithAggregatesInput | cleaned_contactsScalarWhereWithAggregatesInput[]
    OR?: cleaned_contactsScalarWhereWithAggregatesInput[]
    NOT?: cleaned_contactsScalarWhereWithAggregatesInput | cleaned_contactsScalarWhereWithAggregatesInput[]
    phone?: StringWithAggregatesFilter<"cleaned_contacts"> | string
    first_name?: StringNullableWithAggregatesFilter<"cleaned_contacts"> | string | null
    full_name?: StringNullableWithAggregatesFilter<"cleaned_contacts"> | string | null
    push_name?: StringNullableWithAggregatesFilter<"cleaned_contacts"> | string | null
    business_name?: StringNullableWithAggregatesFilter<"cleaned_contacts"> | string | null
  }

  export type contactsWhereInput = {
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    id?: StringFilter<"contacts"> | string
    name?: StringFilter<"contacts"> | string
    phone?: StringNullableFilter<"contacts"> | string | null
    email?: StringNullableFilter<"contacts"> | string | null
    address?: StringNullableFilter<"contacts"> | string | null
    city?: StringNullableFilter<"contacts"> | string | null
    state?: StringNullableFilter<"contacts"> | string | null
    zip?: StringNullableFilter<"contacts"> | string | null
    country?: StringNullableFilter<"contacts"> | string | null
    lastMessage?: StringNullableFilter<"contacts"> | string | null
    lastMessageTime?: DateTimeNullableFilter<"contacts"> | Date | string | null
    unReadCount?: IntNullableFilter<"contacts"> | number | null
    isTyping?: BoolNullableFilter<"contacts"> | boolean | null
    isOnline?: BoolNullableFilter<"contacts"> | boolean | null
    image?: StringNullableFilter<"contacts"> | string | null
    lastSeen?: DateTimeNullableFilter<"contacts"> | Date | string | null
    chatId?: StringNullableFilter<"contacts"> | string | null
    contactId?: StringNullableFilter<"contacts"> | string | null
    userId?: StringNullableFilter<"contacts"> | string | null
    tags?: JsonNullableFilter<"contacts">
    chatparticipants?: ChatparticipantsListRelationFilter
  }

  export type contactsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    lastMessage?: SortOrderInput | SortOrder
    lastMessageTime?: SortOrderInput | SortOrder
    unReadCount?: SortOrderInput | SortOrder
    isTyping?: SortOrderInput | SortOrder
    isOnline?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    chatId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    chatparticipants?: chatparticipantsOrderByRelationAggregateInput
  }

  export type contactsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contactsWhereInput | contactsWhereInput[]
    OR?: contactsWhereInput[]
    NOT?: contactsWhereInput | contactsWhereInput[]
    name?: StringFilter<"contacts"> | string
    phone?: StringNullableFilter<"contacts"> | string | null
    email?: StringNullableFilter<"contacts"> | string | null
    address?: StringNullableFilter<"contacts"> | string | null
    city?: StringNullableFilter<"contacts"> | string | null
    state?: StringNullableFilter<"contacts"> | string | null
    zip?: StringNullableFilter<"contacts"> | string | null
    country?: StringNullableFilter<"contacts"> | string | null
    lastMessage?: StringNullableFilter<"contacts"> | string | null
    lastMessageTime?: DateTimeNullableFilter<"contacts"> | Date | string | null
    unReadCount?: IntNullableFilter<"contacts"> | number | null
    isTyping?: BoolNullableFilter<"contacts"> | boolean | null
    isOnline?: BoolNullableFilter<"contacts"> | boolean | null
    image?: StringNullableFilter<"contacts"> | string | null
    lastSeen?: DateTimeNullableFilter<"contacts"> | Date | string | null
    chatId?: StringNullableFilter<"contacts"> | string | null
    contactId?: StringNullableFilter<"contacts"> | string | null
    userId?: StringNullableFilter<"contacts"> | string | null
    tags?: JsonNullableFilter<"contacts">
    chatparticipants?: ChatparticipantsListRelationFilter
  }, "id">

  export type contactsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    zip?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    lastMessage?: SortOrderInput | SortOrder
    lastMessageTime?: SortOrderInput | SortOrder
    unReadCount?: SortOrderInput | SortOrder
    isTyping?: SortOrderInput | SortOrder
    isOnline?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    lastSeen?: SortOrderInput | SortOrder
    chatId?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    _count?: contactsCountOrderByAggregateInput
    _avg?: contactsAvgOrderByAggregateInput
    _max?: contactsMaxOrderByAggregateInput
    _min?: contactsMinOrderByAggregateInput
    _sum?: contactsSumOrderByAggregateInput
  }

  export type contactsScalarWhereWithAggregatesInput = {
    AND?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    OR?: contactsScalarWhereWithAggregatesInput[]
    NOT?: contactsScalarWhereWithAggregatesInput | contactsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contacts"> | string
    name?: StringWithAggregatesFilter<"contacts"> | string
    phone?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    email?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    address?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    city?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    state?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    zip?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    country?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    lastMessage?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    lastMessageTime?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
    unReadCount?: IntNullableWithAggregatesFilter<"contacts"> | number | null
    isTyping?: BoolNullableWithAggregatesFilter<"contacts"> | boolean | null
    isOnline?: BoolNullableWithAggregatesFilter<"contacts"> | boolean | null
    image?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    lastSeen?: DateTimeNullableWithAggregatesFilter<"contacts"> | Date | string | null
    chatId?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    contactId?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    userId?: StringNullableWithAggregatesFilter<"contacts"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"contacts">
  }

  export type conversationsWhereInput = {
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    id?: IntFilter<"conversations"> | number
    name?: StringNullableFilter<"conversations"> | string | null
    is_group?: BoolNullableFilter<"conversations"> | boolean | null
    created_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
  }

  export type conversationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    is_group?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
  }

  export type conversationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: conversationsWhereInput | conversationsWhereInput[]
    OR?: conversationsWhereInput[]
    NOT?: conversationsWhereInput | conversationsWhereInput[]
    name?: StringNullableFilter<"conversations"> | string | null
    is_group?: BoolNullableFilter<"conversations"> | boolean | null
    created_at?: DateTimeNullableFilter<"conversations"> | Date | string | null
  }, "id">

  export type conversationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    is_group?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: conversationsCountOrderByAggregateInput
    _avg?: conversationsAvgOrderByAggregateInput
    _max?: conversationsMaxOrderByAggregateInput
    _min?: conversationsMinOrderByAggregateInput
    _sum?: conversationsSumOrderByAggregateInput
  }

  export type conversationsScalarWhereWithAggregatesInput = {
    AND?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    OR?: conversationsScalarWhereWithAggregatesInput[]
    NOT?: conversationsScalarWhereWithAggregatesInput | conversationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"conversations"> | number
    name?: StringNullableWithAggregatesFilter<"conversations"> | string | null
    is_group?: BoolNullableWithAggregatesFilter<"conversations"> | boolean | null
    created_at?: DateTimeNullableWithAggregatesFilter<"conversations"> | Date | string | null
  }

  export type groupsWhereInput = {
    AND?: groupsWhereInput | groupsWhereInput[]
    OR?: groupsWhereInput[]
    NOT?: groupsWhereInput | groupsWhereInput[]
    id?: StringFilter<"groups"> | string
    name?: StringNullableFilter<"groups"> | string | null
  }

  export type groupsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
  }

  export type groupsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: groupsWhereInput | groupsWhereInput[]
    OR?: groupsWhereInput[]
    NOT?: groupsWhereInput | groupsWhereInput[]
    name?: StringNullableFilter<"groups"> | string | null
  }, "id">

  export type groupsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    _count?: groupsCountOrderByAggregateInput
    _max?: groupsMaxOrderByAggregateInput
    _min?: groupsMinOrderByAggregateInput
  }

  export type groupsScalarWhereWithAggregatesInput = {
    AND?: groupsScalarWhereWithAggregatesInput | groupsScalarWhereWithAggregatesInput[]
    OR?: groupsScalarWhereWithAggregatesInput[]
    NOT?: groupsScalarWhereWithAggregatesInput | groupsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"groups"> | string
    name?: StringNullableWithAggregatesFilter<"groups"> | string | null
  }

  export type messageTemplatesWhereInput = {
    AND?: messageTemplatesWhereInput | messageTemplatesWhereInput[]
    OR?: messageTemplatesWhereInput[]
    NOT?: messageTemplatesWhereInput | messageTemplatesWhereInput[]
    id?: IntFilter<"messageTemplates"> | number
    name?: StringFilter<"messageTemplates"> | string
    content?: StringFilter<"messageTemplates"> | string
    createdBy?: StringFilter<"messageTemplates"> | string
    createdAt?: DateTimeNullableFilter<"messageTemplates"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"messageTemplates"> | Date | string | null
    imagePath?: StringNullableFilter<"messageTemplates"> | string | null
    mediaPath?: StringNullableFilter<"messageTemplates"> | string | null
  }

  export type messageTemplatesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    mediaPath?: SortOrderInput | SortOrder
  }

  export type messageTemplatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: messageTemplatesWhereInput | messageTemplatesWhereInput[]
    OR?: messageTemplatesWhereInput[]
    NOT?: messageTemplatesWhereInput | messageTemplatesWhereInput[]
    name?: StringFilter<"messageTemplates"> | string
    content?: StringFilter<"messageTemplates"> | string
    createdBy?: StringFilter<"messageTemplates"> | string
    createdAt?: DateTimeNullableFilter<"messageTemplates"> | Date | string | null
    updatedat?: DateTimeNullableFilter<"messageTemplates"> | Date | string | null
    imagePath?: StringNullableFilter<"messageTemplates"> | string | null
    mediaPath?: StringNullableFilter<"messageTemplates"> | string | null
  }, "id">

  export type messageTemplatesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    updatedat?: SortOrderInput | SortOrder
    imagePath?: SortOrderInput | SortOrder
    mediaPath?: SortOrderInput | SortOrder
    _count?: messageTemplatesCountOrderByAggregateInput
    _avg?: messageTemplatesAvgOrderByAggregateInput
    _max?: messageTemplatesMaxOrderByAggregateInput
    _min?: messageTemplatesMinOrderByAggregateInput
    _sum?: messageTemplatesSumOrderByAggregateInput
  }

  export type messageTemplatesScalarWhereWithAggregatesInput = {
    AND?: messageTemplatesScalarWhereWithAggregatesInput | messageTemplatesScalarWhereWithAggregatesInput[]
    OR?: messageTemplatesScalarWhereWithAggregatesInput[]
    NOT?: messageTemplatesScalarWhereWithAggregatesInput | messageTemplatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"messageTemplates"> | number
    name?: StringWithAggregatesFilter<"messageTemplates"> | string
    content?: StringWithAggregatesFilter<"messageTemplates"> | string
    createdBy?: StringWithAggregatesFilter<"messageTemplates"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"messageTemplates"> | Date | string | null
    updatedat?: DateTimeNullableWithAggregatesFilter<"messageTemplates"> | Date | string | null
    imagePath?: StringNullableWithAggregatesFilter<"messageTemplates"> | string | null
    mediaPath?: StringNullableWithAggregatesFilter<"messageTemplates"> | string | null
  }

  export type message_historyWhereInput = {
    AND?: message_historyWhereInput | message_historyWhereInput[]
    OR?: message_historyWhereInput[]
    NOT?: message_historyWhereInput | message_historyWhereInput[]
    id?: IntFilter<"message_history"> | number
    user_id?: StringFilter<"message_history"> | string
    chat_jid?: StringFilter<"message_history"> | string
    sender_jid?: StringFilter<"message_history"> | string
    message_id?: StringFilter<"message_history"> | string
    timestamp?: DateTimeFilter<"message_history"> | Date | string
    message_type?: StringFilter<"message_history"> | string
    text_content?: StringNullableFilter<"message_history"> | string | null
    media_link?: StringNullableFilter<"message_history"> | string | null
    quoted_message_id?: StringNullableFilter<"message_history"> | string | null
    datajson?: StringNullableFilter<"message_history"> | string | null
  }

  export type message_historyOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    timestamp?: SortOrder
    message_type?: SortOrder
    text_content?: SortOrderInput | SortOrder
    media_link?: SortOrderInput | SortOrder
    quoted_message_id?: SortOrderInput | SortOrder
    datajson?: SortOrderInput | SortOrder
  }

  export type message_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    user_id_message_id?: message_historyUser_idMessage_idCompoundUniqueInput
    AND?: message_historyWhereInput | message_historyWhereInput[]
    OR?: message_historyWhereInput[]
    NOT?: message_historyWhereInput | message_historyWhereInput[]
    user_id?: StringFilter<"message_history"> | string
    chat_jid?: StringFilter<"message_history"> | string
    sender_jid?: StringFilter<"message_history"> | string
    message_id?: StringFilter<"message_history"> | string
    timestamp?: DateTimeFilter<"message_history"> | Date | string
    message_type?: StringFilter<"message_history"> | string
    text_content?: StringNullableFilter<"message_history"> | string | null
    media_link?: StringNullableFilter<"message_history"> | string | null
    quoted_message_id?: StringNullableFilter<"message_history"> | string | null
    datajson?: StringNullableFilter<"message_history"> | string | null
  }, "id" | "user_id_message_id">

  export type message_historyOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    timestamp?: SortOrder
    message_type?: SortOrder
    text_content?: SortOrderInput | SortOrder
    media_link?: SortOrderInput | SortOrder
    quoted_message_id?: SortOrderInput | SortOrder
    datajson?: SortOrderInput | SortOrder
    _count?: message_historyCountOrderByAggregateInput
    _avg?: message_historyAvgOrderByAggregateInput
    _max?: message_historyMaxOrderByAggregateInput
    _min?: message_historyMinOrderByAggregateInput
    _sum?: message_historySumOrderByAggregateInput
  }

  export type message_historyScalarWhereWithAggregatesInput = {
    AND?: message_historyScalarWhereWithAggregatesInput | message_historyScalarWhereWithAggregatesInput[]
    OR?: message_historyScalarWhereWithAggregatesInput[]
    NOT?: message_historyScalarWhereWithAggregatesInput | message_historyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"message_history"> | number
    user_id?: StringWithAggregatesFilter<"message_history"> | string
    chat_jid?: StringWithAggregatesFilter<"message_history"> | string
    sender_jid?: StringWithAggregatesFilter<"message_history"> | string
    message_id?: StringWithAggregatesFilter<"message_history"> | string
    timestamp?: DateTimeWithAggregatesFilter<"message_history"> | Date | string
    message_type?: StringWithAggregatesFilter<"message_history"> | string
    text_content?: StringNullableWithAggregatesFilter<"message_history"> | string | null
    media_link?: StringNullableWithAggregatesFilter<"message_history"> | string | null
    quoted_message_id?: StringNullableWithAggregatesFilter<"message_history"> | string | null
    datajson?: StringNullableWithAggregatesFilter<"message_history"> | string | null
  }

  export type message_reactionsWhereInput = {
    AND?: message_reactionsWhereInput | message_reactionsWhereInput[]
    OR?: message_reactionsWhereInput[]
    NOT?: message_reactionsWhereInput | message_reactionsWhereInput[]
    messageId?: StringFilter<"message_reactions"> | string
    participant?: StringNullableFilter<"message_reactions"> | string | null
    emoji?: StringFilter<"message_reactions"> | string
    createdAt?: DateTimeNullableFilter<"message_reactions"> | Date | string | null
    userId?: StringNullableFilter<"message_reactions"> | string | null
    id?: StringFilter<"message_reactions"> | string
    messages?: XOR<MessagesScalarRelationFilter, messagesWhereInput>
  }

  export type message_reactionsOrderByWithRelationInput = {
    messageId?: SortOrder
    participant?: SortOrderInput | SortOrder
    emoji?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    id?: SortOrder
    messages?: messagesOrderByWithRelationInput
  }

  export type message_reactionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_participant?: message_reactionsMessageIdParticipantCompoundUniqueInput
    AND?: message_reactionsWhereInput | message_reactionsWhereInput[]
    OR?: message_reactionsWhereInput[]
    NOT?: message_reactionsWhereInput | message_reactionsWhereInput[]
    messageId?: StringFilter<"message_reactions"> | string
    participant?: StringNullableFilter<"message_reactions"> | string | null
    emoji?: StringFilter<"message_reactions"> | string
    createdAt?: DateTimeNullableFilter<"message_reactions"> | Date | string | null
    userId?: StringNullableFilter<"message_reactions"> | string | null
    messages?: XOR<MessagesScalarRelationFilter, messagesWhereInput>
  }, "id" | "messageId_participant">

  export type message_reactionsOrderByWithAggregationInput = {
    messageId?: SortOrder
    participant?: SortOrderInput | SortOrder
    emoji?: SortOrder
    createdAt?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: message_reactionsCountOrderByAggregateInput
    _max?: message_reactionsMaxOrderByAggregateInput
    _min?: message_reactionsMinOrderByAggregateInput
  }

  export type message_reactionsScalarWhereWithAggregatesInput = {
    AND?: message_reactionsScalarWhereWithAggregatesInput | message_reactionsScalarWhereWithAggregatesInput[]
    OR?: message_reactionsScalarWhereWithAggregatesInput[]
    NOT?: message_reactionsScalarWhereWithAggregatesInput | message_reactionsScalarWhereWithAggregatesInput[]
    messageId?: StringWithAggregatesFilter<"message_reactions"> | string
    participant?: StringNullableWithAggregatesFilter<"message_reactions"> | string | null
    emoji?: StringWithAggregatesFilter<"message_reactions"> | string
    createdAt?: DateTimeNullableWithAggregatesFilter<"message_reactions"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"message_reactions"> | string | null
    id?: StringWithAggregatesFilter<"message_reactions"> | string
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: StringFilter<"messages"> | string
    chatId?: StringNullableFilter<"messages"> | string | null
    message?: StringFilter<"messages"> | string
    timeStamp?: DateTimeNullableFilter<"messages"> | Date | string | null
    isDelivered?: BoolNullableFilter<"messages"> | boolean | null
    isRead?: BoolNullableFilter<"messages"> | boolean | null
    messageType?: StringNullableFilter<"messages"> | string | null
    isFromMe?: BoolNullableFilter<"messages"> | boolean | null
    contactId?: StringNullableFilter<"messages"> | string | null
    isEdit?: BoolNullableFilter<"messages"> | boolean | null
    pushname?: StringNullableFilter<"messages"> | string | null
    mediaPath?: StringNullableFilter<"messages"> | string | null
    note?: StringNullableFilter<"messages"> | string | null
    isPinned?: BoolNullableFilter<"messages"> | boolean | null
    userId?: StringNullableFilter<"messages"> | string | null
    replyToMessageId?: StringNullableFilter<"messages"> | string | null
    message_reactions?: Message_reactionsListRelationFilter
    chats?: XOR<ChatsNullableScalarRelationFilter, chatsWhereInput> | null
  }

  export type messagesOrderByWithRelationInput = {
    id?: SortOrder
    chatId?: SortOrderInput | SortOrder
    message?: SortOrder
    timeStamp?: SortOrderInput | SortOrder
    isDelivered?: SortOrderInput | SortOrder
    isRead?: SortOrderInput | SortOrder
    messageType?: SortOrderInput | SortOrder
    isFromMe?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    isEdit?: SortOrderInput | SortOrder
    pushname?: SortOrderInput | SortOrder
    mediaPath?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isPinned?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    replyToMessageId?: SortOrderInput | SortOrder
    message_reactions?: message_reactionsOrderByRelationAggregateInput
    chats?: chatsOrderByWithRelationInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    chatId?: StringNullableFilter<"messages"> | string | null
    message?: StringFilter<"messages"> | string
    timeStamp?: DateTimeNullableFilter<"messages"> | Date | string | null
    isDelivered?: BoolNullableFilter<"messages"> | boolean | null
    isRead?: BoolNullableFilter<"messages"> | boolean | null
    messageType?: StringNullableFilter<"messages"> | string | null
    isFromMe?: BoolNullableFilter<"messages"> | boolean | null
    contactId?: StringNullableFilter<"messages"> | string | null
    isEdit?: BoolNullableFilter<"messages"> | boolean | null
    pushname?: StringNullableFilter<"messages"> | string | null
    mediaPath?: StringNullableFilter<"messages"> | string | null
    note?: StringNullableFilter<"messages"> | string | null
    isPinned?: BoolNullableFilter<"messages"> | boolean | null
    userId?: StringNullableFilter<"messages"> | string | null
    replyToMessageId?: StringNullableFilter<"messages"> | string | null
    message_reactions?: Message_reactionsListRelationFilter
    chats?: XOR<ChatsNullableScalarRelationFilter, chatsWhereInput> | null
  }, "id">

  export type messagesOrderByWithAggregationInput = {
    id?: SortOrder
    chatId?: SortOrderInput | SortOrder
    message?: SortOrder
    timeStamp?: SortOrderInput | SortOrder
    isDelivered?: SortOrderInput | SortOrder
    isRead?: SortOrderInput | SortOrder
    messageType?: SortOrderInput | SortOrder
    isFromMe?: SortOrderInput | SortOrder
    contactId?: SortOrderInput | SortOrder
    isEdit?: SortOrderInput | SortOrder
    pushname?: SortOrderInput | SortOrder
    mediaPath?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    isPinned?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    replyToMessageId?: SortOrderInput | SortOrder
    _count?: messagesCountOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"messages"> | string
    chatId?: StringNullableWithAggregatesFilter<"messages"> | string | null
    message?: StringWithAggregatesFilter<"messages"> | string
    timeStamp?: DateTimeNullableWithAggregatesFilter<"messages"> | Date | string | null
    isDelivered?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
    isRead?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
    messageType?: StringNullableWithAggregatesFilter<"messages"> | string | null
    isFromMe?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
    contactId?: StringNullableWithAggregatesFilter<"messages"> | string | null
    isEdit?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
    pushname?: StringNullableWithAggregatesFilter<"messages"> | string | null
    mediaPath?: StringNullableWithAggregatesFilter<"messages"> | string | null
    note?: StringNullableWithAggregatesFilter<"messages"> | string | null
    isPinned?: BoolNullableWithAggregatesFilter<"messages"> | boolean | null
    userId?: StringNullableWithAggregatesFilter<"messages"> | string | null
    replyToMessageId?: StringNullableWithAggregatesFilter<"messages"> | string | null
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    name?: StringFilter<"migrations"> | string
    applied_at?: DateTimeNullableFilter<"migrations"> | Date | string | null
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrderInput | SortOrder
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    name?: StringFilter<"migrations"> | string
    applied_at?: DateTimeNullableFilter<"migrations"> | Date | string | null
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrderInput | SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    name?: StringWithAggregatesFilter<"migrations"> | string
    applied_at?: DateTimeNullableWithAggregatesFilter<"migrations"> | Date | string | null
  }

  export type tagsWhereInput = {
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    tagId?: BigIntFilter<"tags"> | bigint | number
    tagName?: StringNullableFilter<"tags"> | string | null
  }

  export type tagsOrderByWithRelationInput = {
    tagId?: SortOrder
    tagName?: SortOrderInput | SortOrder
  }

  export type tagsWhereUniqueInput = Prisma.AtLeast<{
    tagId?: bigint | number
    AND?: tagsWhereInput | tagsWhereInput[]
    OR?: tagsWhereInput[]
    NOT?: tagsWhereInput | tagsWhereInput[]
    tagName?: StringNullableFilter<"tags"> | string | null
  }, "tagId">

  export type tagsOrderByWithAggregationInput = {
    tagId?: SortOrder
    tagName?: SortOrderInput | SortOrder
    _count?: tagsCountOrderByAggregateInput
    _avg?: tagsAvgOrderByAggregateInput
    _max?: tagsMaxOrderByAggregateInput
    _min?: tagsMinOrderByAggregateInput
    _sum?: tagsSumOrderByAggregateInput
  }

  export type tagsScalarWhereWithAggregatesInput = {
    AND?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    OR?: tagsScalarWhereWithAggregatesInput[]
    NOT?: tagsScalarWhereWithAggregatesInput | tagsScalarWhereWithAggregatesInput[]
    tagId?: BigIntWithAggregatesFilter<"tags"> | bigint | number
    tagName?: StringNullableWithAggregatesFilter<"tags"> | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    token?: StringFilter<"users"> | string
    webhook?: StringFilter<"users"> | string
    jid?: StringFilter<"users"> | string
    qrcode?: StringFilter<"users"> | string
    connected?: IntNullableFilter<"users"> | number | null
    expiration?: IntNullableFilter<"users"> | number | null
    events?: StringFilter<"users"> | string
    proxy_url?: StringNullableFilter<"users"> | string | null
    s3_enabled?: BoolNullableFilter<"users"> | boolean | null
    s3_endpoint?: StringNullableFilter<"users"> | string | null
    s3_region?: StringNullableFilter<"users"> | string | null
    s3_bucket?: StringNullableFilter<"users"> | string | null
    s3_access_key?: StringNullableFilter<"users"> | string | null
    s3_secret_key?: StringNullableFilter<"users"> | string | null
    s3_path_style?: BoolNullableFilter<"users"> | boolean | null
    s3_public_url?: StringNullableFilter<"users"> | string | null
    media_delivery?: StringNullableFilter<"users"> | string | null
    s3_retention_days?: IntNullableFilter<"users"> | number | null
    history?: IntNullableFilter<"users"> | number | null
    hmac_key?: BytesNullableFilter<"users"> | Uint8Array | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    jid?: SortOrder
    qrcode?: SortOrder
    connected?: SortOrderInput | SortOrder
    expiration?: SortOrderInput | SortOrder
    events?: SortOrder
    proxy_url?: SortOrderInput | SortOrder
    s3_enabled?: SortOrderInput | SortOrder
    s3_endpoint?: SortOrderInput | SortOrder
    s3_region?: SortOrderInput | SortOrder
    s3_bucket?: SortOrderInput | SortOrder
    s3_access_key?: SortOrderInput | SortOrder
    s3_secret_key?: SortOrderInput | SortOrder
    s3_path_style?: SortOrderInput | SortOrder
    s3_public_url?: SortOrderInput | SortOrder
    media_delivery?: SortOrderInput | SortOrder
    s3_retention_days?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    hmac_key?: SortOrderInput | SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    token?: StringFilter<"users"> | string
    webhook?: StringFilter<"users"> | string
    jid?: StringFilter<"users"> | string
    qrcode?: StringFilter<"users"> | string
    connected?: IntNullableFilter<"users"> | number | null
    expiration?: IntNullableFilter<"users"> | number | null
    events?: StringFilter<"users"> | string
    proxy_url?: StringNullableFilter<"users"> | string | null
    s3_enabled?: BoolNullableFilter<"users"> | boolean | null
    s3_endpoint?: StringNullableFilter<"users"> | string | null
    s3_region?: StringNullableFilter<"users"> | string | null
    s3_bucket?: StringNullableFilter<"users"> | string | null
    s3_access_key?: StringNullableFilter<"users"> | string | null
    s3_secret_key?: StringNullableFilter<"users"> | string | null
    s3_path_style?: BoolNullableFilter<"users"> | boolean | null
    s3_public_url?: StringNullableFilter<"users"> | string | null
    media_delivery?: StringNullableFilter<"users"> | string | null
    s3_retention_days?: IntNullableFilter<"users"> | number | null
    history?: IntNullableFilter<"users"> | number | null
    hmac_key?: BytesNullableFilter<"users"> | Uint8Array | null
  }, "id">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    jid?: SortOrder
    qrcode?: SortOrder
    connected?: SortOrderInput | SortOrder
    expiration?: SortOrderInput | SortOrder
    events?: SortOrder
    proxy_url?: SortOrderInput | SortOrder
    s3_enabled?: SortOrderInput | SortOrder
    s3_endpoint?: SortOrderInput | SortOrder
    s3_region?: SortOrderInput | SortOrder
    s3_bucket?: SortOrderInput | SortOrder
    s3_access_key?: SortOrderInput | SortOrder
    s3_secret_key?: SortOrderInput | SortOrder
    s3_path_style?: SortOrderInput | SortOrder
    s3_public_url?: SortOrderInput | SortOrder
    media_delivery?: SortOrderInput | SortOrder
    s3_retention_days?: SortOrderInput | SortOrder
    history?: SortOrderInput | SortOrder
    hmac_key?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    token?: StringWithAggregatesFilter<"users"> | string
    webhook?: StringWithAggregatesFilter<"users"> | string
    jid?: StringWithAggregatesFilter<"users"> | string
    qrcode?: StringWithAggregatesFilter<"users"> | string
    connected?: IntNullableWithAggregatesFilter<"users"> | number | null
    expiration?: IntNullableWithAggregatesFilter<"users"> | number | null
    events?: StringWithAggregatesFilter<"users"> | string
    proxy_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_enabled?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    s3_endpoint?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_region?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_bucket?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_access_key?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_secret_key?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_path_style?: BoolNullableWithAggregatesFilter<"users"> | boolean | null
    s3_public_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    media_delivery?: StringNullableWithAggregatesFilter<"users"> | string | null
    s3_retention_days?: IntNullableWithAggregatesFilter<"users"> | number | null
    history?: IntNullableWithAggregatesFilter<"users"> | number | null
    hmac_key?: BytesNullableWithAggregatesFilter<"users"> | Uint8Array | null
  }

  export type whatsmeow_app_state_mutation_macsWhereInput = {
    AND?: whatsmeow_app_state_mutation_macsWhereInput | whatsmeow_app_state_mutation_macsWhereInput[]
    OR?: whatsmeow_app_state_mutation_macsWhereInput[]
    NOT?: whatsmeow_app_state_mutation_macsWhereInput | whatsmeow_app_state_mutation_macsWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_mutation_macs"> | string
    name?: StringFilter<"whatsmeow_app_state_mutation_macs"> | string
    version?: BigIntFilter<"whatsmeow_app_state_mutation_macs"> | bigint | number
    index_mac?: BytesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
    value_mac?: BytesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
    whatsmeow_app_state_version?: XOR<Whatsmeow_app_state_versionScalarRelationFilter, whatsmeow_app_state_versionWhereInput>
  }

  export type whatsmeow_app_state_mutation_macsOrderByWithRelationInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    index_mac?: SortOrder
    value_mac?: SortOrder
    whatsmeow_app_state_version?: whatsmeow_app_state_versionOrderByWithRelationInput
  }

  export type whatsmeow_app_state_mutation_macsWhereUniqueInput = Prisma.AtLeast<{
    jid_name_version_index_mac?: whatsmeow_app_state_mutation_macsJidNameVersionIndex_macCompoundUniqueInput
    AND?: whatsmeow_app_state_mutation_macsWhereInput | whatsmeow_app_state_mutation_macsWhereInput[]
    OR?: whatsmeow_app_state_mutation_macsWhereInput[]
    NOT?: whatsmeow_app_state_mutation_macsWhereInput | whatsmeow_app_state_mutation_macsWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_mutation_macs"> | string
    name?: StringFilter<"whatsmeow_app_state_mutation_macs"> | string
    version?: BigIntFilter<"whatsmeow_app_state_mutation_macs"> | bigint | number
    index_mac?: BytesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
    value_mac?: BytesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
    whatsmeow_app_state_version?: XOR<Whatsmeow_app_state_versionScalarRelationFilter, whatsmeow_app_state_versionWhereInput>
  }, "jid_name_version_index_mac">

  export type whatsmeow_app_state_mutation_macsOrderByWithAggregationInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    index_mac?: SortOrder
    value_mac?: SortOrder
    _count?: whatsmeow_app_state_mutation_macsCountOrderByAggregateInput
    _avg?: whatsmeow_app_state_mutation_macsAvgOrderByAggregateInput
    _max?: whatsmeow_app_state_mutation_macsMaxOrderByAggregateInput
    _min?: whatsmeow_app_state_mutation_macsMinOrderByAggregateInput
    _sum?: whatsmeow_app_state_mutation_macsSumOrderByAggregateInput
  }

  export type whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput | whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput | whatsmeow_app_state_mutation_macsScalarWhereWithAggregatesInput[]
    jid?: StringWithAggregatesFilter<"whatsmeow_app_state_mutation_macs"> | string
    name?: StringWithAggregatesFilter<"whatsmeow_app_state_mutation_macs"> | string
    version?: BigIntWithAggregatesFilter<"whatsmeow_app_state_mutation_macs"> | bigint | number
    index_mac?: BytesWithAggregatesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
    value_mac?: BytesWithAggregatesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysWhereInput = {
    AND?: whatsmeow_app_state_sync_keysWhereInput | whatsmeow_app_state_sync_keysWhereInput[]
    OR?: whatsmeow_app_state_sync_keysWhereInput[]
    NOT?: whatsmeow_app_state_sync_keysWhereInput | whatsmeow_app_state_sync_keysWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_sync_keys"> | string
    key_id?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    key_data?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    timestamp?: BigIntFilter<"whatsmeow_app_state_sync_keys"> | bigint | number
    fingerprint?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_app_state_sync_keysOrderByWithRelationInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key_data?: SortOrder
    timestamp?: SortOrder
    fingerprint?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_app_state_sync_keysWhereUniqueInput = Prisma.AtLeast<{
    jid_key_id?: whatsmeow_app_state_sync_keysJidKey_idCompoundUniqueInput
    AND?: whatsmeow_app_state_sync_keysWhereInput | whatsmeow_app_state_sync_keysWhereInput[]
    OR?: whatsmeow_app_state_sync_keysWhereInput[]
    NOT?: whatsmeow_app_state_sync_keysWhereInput | whatsmeow_app_state_sync_keysWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_sync_keys"> | string
    key_id?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    key_data?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    timestamp?: BigIntFilter<"whatsmeow_app_state_sync_keys"> | bigint | number
    fingerprint?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "jid_key_id">

  export type whatsmeow_app_state_sync_keysOrderByWithAggregationInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key_data?: SortOrder
    timestamp?: SortOrder
    fingerprint?: SortOrder
    _count?: whatsmeow_app_state_sync_keysCountOrderByAggregateInput
    _avg?: whatsmeow_app_state_sync_keysAvgOrderByAggregateInput
    _max?: whatsmeow_app_state_sync_keysMaxOrderByAggregateInput
    _min?: whatsmeow_app_state_sync_keysMinOrderByAggregateInput
    _sum?: whatsmeow_app_state_sync_keysSumOrderByAggregateInput
  }

  export type whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput | whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput | whatsmeow_app_state_sync_keysScalarWhereWithAggregatesInput[]
    jid?: StringWithAggregatesFilter<"whatsmeow_app_state_sync_keys"> | string
    key_id?: BytesWithAggregatesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    key_data?: BytesWithAggregatesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    timestamp?: BigIntWithAggregatesFilter<"whatsmeow_app_state_sync_keys"> | bigint | number
    fingerprint?: BytesWithAggregatesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
  }

  export type whatsmeow_app_state_versionWhereInput = {
    AND?: whatsmeow_app_state_versionWhereInput | whatsmeow_app_state_versionWhereInput[]
    OR?: whatsmeow_app_state_versionWhereInput[]
    NOT?: whatsmeow_app_state_versionWhereInput | whatsmeow_app_state_versionWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_version"> | string
    name?: StringFilter<"whatsmeow_app_state_version"> | string
    version?: BigIntFilter<"whatsmeow_app_state_version"> | bigint | number
    hash?: BytesFilter<"whatsmeow_app_state_version"> | Uint8Array
    whatsmeow_app_state_mutation_macs?: Whatsmeow_app_state_mutation_macsListRelationFilter
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_app_state_versionOrderByWithRelationInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsOrderByRelationAggregateInput
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_app_state_versionWhereUniqueInput = Prisma.AtLeast<{
    jid_name?: whatsmeow_app_state_versionJidNameCompoundUniqueInput
    AND?: whatsmeow_app_state_versionWhereInput | whatsmeow_app_state_versionWhereInput[]
    OR?: whatsmeow_app_state_versionWhereInput[]
    NOT?: whatsmeow_app_state_versionWhereInput | whatsmeow_app_state_versionWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_version"> | string
    name?: StringFilter<"whatsmeow_app_state_version"> | string
    version?: BigIntFilter<"whatsmeow_app_state_version"> | bigint | number
    hash?: BytesFilter<"whatsmeow_app_state_version"> | Uint8Array
    whatsmeow_app_state_mutation_macs?: Whatsmeow_app_state_mutation_macsListRelationFilter
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "jid_name">

  export type whatsmeow_app_state_versionOrderByWithAggregationInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
    _count?: whatsmeow_app_state_versionCountOrderByAggregateInput
    _avg?: whatsmeow_app_state_versionAvgOrderByAggregateInput
    _max?: whatsmeow_app_state_versionMaxOrderByAggregateInput
    _min?: whatsmeow_app_state_versionMinOrderByAggregateInput
    _sum?: whatsmeow_app_state_versionSumOrderByAggregateInput
  }

  export type whatsmeow_app_state_versionScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_app_state_versionScalarWhereWithAggregatesInput | whatsmeow_app_state_versionScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_app_state_versionScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_app_state_versionScalarWhereWithAggregatesInput | whatsmeow_app_state_versionScalarWhereWithAggregatesInput[]
    jid?: StringWithAggregatesFilter<"whatsmeow_app_state_version"> | string
    name?: StringWithAggregatesFilter<"whatsmeow_app_state_version"> | string
    version?: BigIntWithAggregatesFilter<"whatsmeow_app_state_version"> | bigint | number
    hash?: BytesWithAggregatesFilter<"whatsmeow_app_state_version"> | Uint8Array
  }

  export type whatsmeow_chat_settingsWhereInput = {
    AND?: whatsmeow_chat_settingsWhereInput | whatsmeow_chat_settingsWhereInput[]
    OR?: whatsmeow_chat_settingsWhereInput[]
    NOT?: whatsmeow_chat_settingsWhereInput | whatsmeow_chat_settingsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_chat_settings"> | string
    chat_jid?: StringFilter<"whatsmeow_chat_settings"> | string
    muted_until?: BigIntFilter<"whatsmeow_chat_settings"> | bigint | number
    pinned?: BoolFilter<"whatsmeow_chat_settings"> | boolean
    archived?: BoolFilter<"whatsmeow_chat_settings"> | boolean
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_chat_settingsOrderByWithRelationInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    muted_until?: SortOrder
    pinned?: SortOrder
    archived?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_chat_settingsWhereUniqueInput = Prisma.AtLeast<{
    our_jid_chat_jid?: whatsmeow_chat_settingsOur_jidChat_jidCompoundUniqueInput
    AND?: whatsmeow_chat_settingsWhereInput | whatsmeow_chat_settingsWhereInput[]
    OR?: whatsmeow_chat_settingsWhereInput[]
    NOT?: whatsmeow_chat_settingsWhereInput | whatsmeow_chat_settingsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_chat_settings"> | string
    chat_jid?: StringFilter<"whatsmeow_chat_settings"> | string
    muted_until?: BigIntFilter<"whatsmeow_chat_settings"> | bigint | number
    pinned?: BoolFilter<"whatsmeow_chat_settings"> | boolean
    archived?: BoolFilter<"whatsmeow_chat_settings"> | boolean
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_chat_jid">

  export type whatsmeow_chat_settingsOrderByWithAggregationInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    muted_until?: SortOrder
    pinned?: SortOrder
    archived?: SortOrder
    _count?: whatsmeow_chat_settingsCountOrderByAggregateInput
    _avg?: whatsmeow_chat_settingsAvgOrderByAggregateInput
    _max?: whatsmeow_chat_settingsMaxOrderByAggregateInput
    _min?: whatsmeow_chat_settingsMinOrderByAggregateInput
    _sum?: whatsmeow_chat_settingsSumOrderByAggregateInput
  }

  export type whatsmeow_chat_settingsScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_chat_settingsScalarWhereWithAggregatesInput | whatsmeow_chat_settingsScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_chat_settingsScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_chat_settingsScalarWhereWithAggregatesInput | whatsmeow_chat_settingsScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_chat_settings"> | string
    chat_jid?: StringWithAggregatesFilter<"whatsmeow_chat_settings"> | string
    muted_until?: BigIntWithAggregatesFilter<"whatsmeow_chat_settings"> | bigint | number
    pinned?: BoolWithAggregatesFilter<"whatsmeow_chat_settings"> | boolean
    archived?: BoolWithAggregatesFilter<"whatsmeow_chat_settings"> | boolean
  }

  export type whatsmeow_contactsWhereInput = {
    AND?: whatsmeow_contactsWhereInput | whatsmeow_contactsWhereInput[]
    OR?: whatsmeow_contactsWhereInput[]
    NOT?: whatsmeow_contactsWhereInput | whatsmeow_contactsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_contacts"> | string
    their_jid?: StringFilter<"whatsmeow_contacts"> | string
    first_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    full_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    push_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    business_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    redacted_phone?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_contactsOrderByWithRelationInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    first_name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    push_name?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    redacted_phone?: SortOrderInput | SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_contactsWhereUniqueInput = Prisma.AtLeast<{
    our_jid_their_jid?: whatsmeow_contactsOur_jidTheir_jidCompoundUniqueInput
    AND?: whatsmeow_contactsWhereInput | whatsmeow_contactsWhereInput[]
    OR?: whatsmeow_contactsWhereInput[]
    NOT?: whatsmeow_contactsWhereInput | whatsmeow_contactsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_contacts"> | string
    their_jid?: StringFilter<"whatsmeow_contacts"> | string
    first_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    full_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    push_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    business_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    redacted_phone?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_their_jid">

  export type whatsmeow_contactsOrderByWithAggregationInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    first_name?: SortOrderInput | SortOrder
    full_name?: SortOrderInput | SortOrder
    push_name?: SortOrderInput | SortOrder
    business_name?: SortOrderInput | SortOrder
    redacted_phone?: SortOrderInput | SortOrder
    _count?: whatsmeow_contactsCountOrderByAggregateInput
    _max?: whatsmeow_contactsMaxOrderByAggregateInput
    _min?: whatsmeow_contactsMinOrderByAggregateInput
  }

  export type whatsmeow_contactsScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_contactsScalarWhereWithAggregatesInput | whatsmeow_contactsScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_contactsScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_contactsScalarWhereWithAggregatesInput | whatsmeow_contactsScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_contacts"> | string
    their_jid?: StringWithAggregatesFilter<"whatsmeow_contacts"> | string
    first_name?: StringNullableWithAggregatesFilter<"whatsmeow_contacts"> | string | null
    full_name?: StringNullableWithAggregatesFilter<"whatsmeow_contacts"> | string | null
    push_name?: StringNullableWithAggregatesFilter<"whatsmeow_contacts"> | string | null
    business_name?: StringNullableWithAggregatesFilter<"whatsmeow_contacts"> | string | null
    redacted_phone?: StringNullableWithAggregatesFilter<"whatsmeow_contacts"> | string | null
  }

  export type whatsmeow_deviceWhereInput = {
    AND?: whatsmeow_deviceWhereInput | whatsmeow_deviceWhereInput[]
    OR?: whatsmeow_deviceWhereInput[]
    NOT?: whatsmeow_deviceWhereInput | whatsmeow_deviceWhereInput[]
    jid?: StringFilter<"whatsmeow_device"> | string
    lid?: StringNullableFilter<"whatsmeow_device"> | string | null
    facebook_uuid?: UuidNullableFilter<"whatsmeow_device"> | string | null
    registration_id?: BigIntFilter<"whatsmeow_device"> | bigint | number
    noise_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    identity_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    signed_pre_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    signed_pre_key_id?: IntFilter<"whatsmeow_device"> | number
    signed_pre_key_sig?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_details?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_account_sig?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_account_sig_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_device_sig?: BytesFilter<"whatsmeow_device"> | Uint8Array
    platform?: StringFilter<"whatsmeow_device"> | string
    business_name?: StringFilter<"whatsmeow_device"> | string
    push_name?: StringFilter<"whatsmeow_device"> | string
    lid_migration_ts?: BigIntFilter<"whatsmeow_device"> | bigint | number
    whatsmeow_app_state_sync_keys?: Whatsmeow_app_state_sync_keysListRelationFilter
    whatsmeow_app_state_version?: Whatsmeow_app_state_versionListRelationFilter
    whatsmeow_chat_settings?: Whatsmeow_chat_settingsListRelationFilter
    whatsmeow_contacts?: Whatsmeow_contactsListRelationFilter
    whatsmeow_event_buffer?: Whatsmeow_event_bufferListRelationFilter
    whatsmeow_identity_keys?: Whatsmeow_identity_keysListRelationFilter
    whatsmeow_message_secrets?: Whatsmeow_message_secretsListRelationFilter
    whatsmeow_pre_keys?: Whatsmeow_pre_keysListRelationFilter
    whatsmeow_sender_keys?: Whatsmeow_sender_keysListRelationFilter
    whatsmeow_sessions?: Whatsmeow_sessionsListRelationFilter
  }

  export type whatsmeow_deviceOrderByWithRelationInput = {
    jid?: SortOrder
    lid?: SortOrderInput | SortOrder
    facebook_uuid?: SortOrderInput | SortOrder
    registration_id?: SortOrder
    noise_key?: SortOrder
    identity_key?: SortOrder
    signed_pre_key?: SortOrder
    signed_pre_key_id?: SortOrder
    signed_pre_key_sig?: SortOrder
    adv_key?: SortOrder
    adv_details?: SortOrder
    adv_account_sig?: SortOrder
    adv_account_sig_key?: SortOrder
    adv_device_sig?: SortOrder
    platform?: SortOrder
    business_name?: SortOrder
    push_name?: SortOrder
    lid_migration_ts?: SortOrder
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysOrderByRelationAggregateInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionOrderByRelationAggregateInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsOrderByRelationAggregateInput
    whatsmeow_contacts?: whatsmeow_contactsOrderByRelationAggregateInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferOrderByRelationAggregateInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysOrderByRelationAggregateInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsOrderByRelationAggregateInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysOrderByRelationAggregateInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysOrderByRelationAggregateInput
    whatsmeow_sessions?: whatsmeow_sessionsOrderByRelationAggregateInput
  }

  export type whatsmeow_deviceWhereUniqueInput = Prisma.AtLeast<{
    jid?: string
    AND?: whatsmeow_deviceWhereInput | whatsmeow_deviceWhereInput[]
    OR?: whatsmeow_deviceWhereInput[]
    NOT?: whatsmeow_deviceWhereInput | whatsmeow_deviceWhereInput[]
    lid?: StringNullableFilter<"whatsmeow_device"> | string | null
    facebook_uuid?: UuidNullableFilter<"whatsmeow_device"> | string | null
    registration_id?: BigIntFilter<"whatsmeow_device"> | bigint | number
    noise_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    identity_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    signed_pre_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    signed_pre_key_id?: IntFilter<"whatsmeow_device"> | number
    signed_pre_key_sig?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_details?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_account_sig?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_account_sig_key?: BytesFilter<"whatsmeow_device"> | Uint8Array
    adv_device_sig?: BytesFilter<"whatsmeow_device"> | Uint8Array
    platform?: StringFilter<"whatsmeow_device"> | string
    business_name?: StringFilter<"whatsmeow_device"> | string
    push_name?: StringFilter<"whatsmeow_device"> | string
    lid_migration_ts?: BigIntFilter<"whatsmeow_device"> | bigint | number
    whatsmeow_app_state_sync_keys?: Whatsmeow_app_state_sync_keysListRelationFilter
    whatsmeow_app_state_version?: Whatsmeow_app_state_versionListRelationFilter
    whatsmeow_chat_settings?: Whatsmeow_chat_settingsListRelationFilter
    whatsmeow_contacts?: Whatsmeow_contactsListRelationFilter
    whatsmeow_event_buffer?: Whatsmeow_event_bufferListRelationFilter
    whatsmeow_identity_keys?: Whatsmeow_identity_keysListRelationFilter
    whatsmeow_message_secrets?: Whatsmeow_message_secretsListRelationFilter
    whatsmeow_pre_keys?: Whatsmeow_pre_keysListRelationFilter
    whatsmeow_sender_keys?: Whatsmeow_sender_keysListRelationFilter
    whatsmeow_sessions?: Whatsmeow_sessionsListRelationFilter
  }, "jid">

  export type whatsmeow_deviceOrderByWithAggregationInput = {
    jid?: SortOrder
    lid?: SortOrderInput | SortOrder
    facebook_uuid?: SortOrderInput | SortOrder
    registration_id?: SortOrder
    noise_key?: SortOrder
    identity_key?: SortOrder
    signed_pre_key?: SortOrder
    signed_pre_key_id?: SortOrder
    signed_pre_key_sig?: SortOrder
    adv_key?: SortOrder
    adv_details?: SortOrder
    adv_account_sig?: SortOrder
    adv_account_sig_key?: SortOrder
    adv_device_sig?: SortOrder
    platform?: SortOrder
    business_name?: SortOrder
    push_name?: SortOrder
    lid_migration_ts?: SortOrder
    _count?: whatsmeow_deviceCountOrderByAggregateInput
    _avg?: whatsmeow_deviceAvgOrderByAggregateInput
    _max?: whatsmeow_deviceMaxOrderByAggregateInput
    _min?: whatsmeow_deviceMinOrderByAggregateInput
    _sum?: whatsmeow_deviceSumOrderByAggregateInput
  }

  export type whatsmeow_deviceScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_deviceScalarWhereWithAggregatesInput | whatsmeow_deviceScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_deviceScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_deviceScalarWhereWithAggregatesInput | whatsmeow_deviceScalarWhereWithAggregatesInput[]
    jid?: StringWithAggregatesFilter<"whatsmeow_device"> | string
    lid?: StringNullableWithAggregatesFilter<"whatsmeow_device"> | string | null
    facebook_uuid?: UuidNullableWithAggregatesFilter<"whatsmeow_device"> | string | null
    registration_id?: BigIntWithAggregatesFilter<"whatsmeow_device"> | bigint | number
    noise_key?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    identity_key?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    signed_pre_key?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    signed_pre_key_id?: IntWithAggregatesFilter<"whatsmeow_device"> | number
    signed_pre_key_sig?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    adv_key?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    adv_details?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    adv_account_sig?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    adv_account_sig_key?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    adv_device_sig?: BytesWithAggregatesFilter<"whatsmeow_device"> | Uint8Array
    platform?: StringWithAggregatesFilter<"whatsmeow_device"> | string
    business_name?: StringWithAggregatesFilter<"whatsmeow_device"> | string
    push_name?: StringWithAggregatesFilter<"whatsmeow_device"> | string
    lid_migration_ts?: BigIntWithAggregatesFilter<"whatsmeow_device"> | bigint | number
  }

  export type whatsmeow_event_bufferWhereInput = {
    AND?: whatsmeow_event_bufferWhereInput | whatsmeow_event_bufferWhereInput[]
    OR?: whatsmeow_event_bufferWhereInput[]
    NOT?: whatsmeow_event_bufferWhereInput | whatsmeow_event_bufferWhereInput[]
    our_jid?: StringFilter<"whatsmeow_event_buffer"> | string
    ciphertext_hash?: BytesFilter<"whatsmeow_event_buffer"> | Uint8Array
    plaintext?: BytesNullableFilter<"whatsmeow_event_buffer"> | Uint8Array | null
    server_timestamp?: BigIntFilter<"whatsmeow_event_buffer"> | bigint | number
    insert_timestamp?: BigIntFilter<"whatsmeow_event_buffer"> | bigint | number
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_event_bufferOrderByWithRelationInput = {
    our_jid?: SortOrder
    ciphertext_hash?: SortOrder
    plaintext?: SortOrderInput | SortOrder
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_event_bufferWhereUniqueInput = Prisma.AtLeast<{
    our_jid_ciphertext_hash?: whatsmeow_event_bufferOur_jidCiphertext_hashCompoundUniqueInput
    AND?: whatsmeow_event_bufferWhereInput | whatsmeow_event_bufferWhereInput[]
    OR?: whatsmeow_event_bufferWhereInput[]
    NOT?: whatsmeow_event_bufferWhereInput | whatsmeow_event_bufferWhereInput[]
    our_jid?: StringFilter<"whatsmeow_event_buffer"> | string
    ciphertext_hash?: BytesFilter<"whatsmeow_event_buffer"> | Uint8Array
    plaintext?: BytesNullableFilter<"whatsmeow_event_buffer"> | Uint8Array | null
    server_timestamp?: BigIntFilter<"whatsmeow_event_buffer"> | bigint | number
    insert_timestamp?: BigIntFilter<"whatsmeow_event_buffer"> | bigint | number
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_ciphertext_hash">

  export type whatsmeow_event_bufferOrderByWithAggregationInput = {
    our_jid?: SortOrder
    ciphertext_hash?: SortOrder
    plaintext?: SortOrderInput | SortOrder
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
    _count?: whatsmeow_event_bufferCountOrderByAggregateInput
    _avg?: whatsmeow_event_bufferAvgOrderByAggregateInput
    _max?: whatsmeow_event_bufferMaxOrderByAggregateInput
    _min?: whatsmeow_event_bufferMinOrderByAggregateInput
    _sum?: whatsmeow_event_bufferSumOrderByAggregateInput
  }

  export type whatsmeow_event_bufferScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_event_bufferScalarWhereWithAggregatesInput | whatsmeow_event_bufferScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_event_bufferScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_event_bufferScalarWhereWithAggregatesInput | whatsmeow_event_bufferScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_event_buffer"> | string
    ciphertext_hash?: BytesWithAggregatesFilter<"whatsmeow_event_buffer"> | Uint8Array
    plaintext?: BytesNullableWithAggregatesFilter<"whatsmeow_event_buffer"> | Uint8Array | null
    server_timestamp?: BigIntWithAggregatesFilter<"whatsmeow_event_buffer"> | bigint | number
    insert_timestamp?: BigIntWithAggregatesFilter<"whatsmeow_event_buffer"> | bigint | number
  }

  export type whatsmeow_identity_keysWhereInput = {
    AND?: whatsmeow_identity_keysWhereInput | whatsmeow_identity_keysWhereInput[]
    OR?: whatsmeow_identity_keysWhereInput[]
    NOT?: whatsmeow_identity_keysWhereInput | whatsmeow_identity_keysWhereInput[]
    our_jid?: StringFilter<"whatsmeow_identity_keys"> | string
    their_id?: StringFilter<"whatsmeow_identity_keys"> | string
    identity?: BytesFilter<"whatsmeow_identity_keys"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_identity_keysOrderByWithRelationInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    identity?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_identity_keysWhereUniqueInput = Prisma.AtLeast<{
    our_jid_their_id?: whatsmeow_identity_keysOur_jidTheir_idCompoundUniqueInput
    AND?: whatsmeow_identity_keysWhereInput | whatsmeow_identity_keysWhereInput[]
    OR?: whatsmeow_identity_keysWhereInput[]
    NOT?: whatsmeow_identity_keysWhereInput | whatsmeow_identity_keysWhereInput[]
    our_jid?: StringFilter<"whatsmeow_identity_keys"> | string
    their_id?: StringFilter<"whatsmeow_identity_keys"> | string
    identity?: BytesFilter<"whatsmeow_identity_keys"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_their_id">

  export type whatsmeow_identity_keysOrderByWithAggregationInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    identity?: SortOrder
    _count?: whatsmeow_identity_keysCountOrderByAggregateInput
    _max?: whatsmeow_identity_keysMaxOrderByAggregateInput
    _min?: whatsmeow_identity_keysMinOrderByAggregateInput
  }

  export type whatsmeow_identity_keysScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_identity_keysScalarWhereWithAggregatesInput | whatsmeow_identity_keysScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_identity_keysScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_identity_keysScalarWhereWithAggregatesInput | whatsmeow_identity_keysScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_identity_keys"> | string
    their_id?: StringWithAggregatesFilter<"whatsmeow_identity_keys"> | string
    identity?: BytesWithAggregatesFilter<"whatsmeow_identity_keys"> | Uint8Array
  }

  export type whatsmeow_lid_mapWhereInput = {
    AND?: whatsmeow_lid_mapWhereInput | whatsmeow_lid_mapWhereInput[]
    OR?: whatsmeow_lid_mapWhereInput[]
    NOT?: whatsmeow_lid_mapWhereInput | whatsmeow_lid_mapWhereInput[]
    lid?: StringFilter<"whatsmeow_lid_map"> | string
    pn?: StringFilter<"whatsmeow_lid_map"> | string
  }

  export type whatsmeow_lid_mapOrderByWithRelationInput = {
    lid?: SortOrder
    pn?: SortOrder
  }

  export type whatsmeow_lid_mapWhereUniqueInput = Prisma.AtLeast<{
    lid?: string
    pn?: string
    AND?: whatsmeow_lid_mapWhereInput | whatsmeow_lid_mapWhereInput[]
    OR?: whatsmeow_lid_mapWhereInput[]
    NOT?: whatsmeow_lid_mapWhereInput | whatsmeow_lid_mapWhereInput[]
  }, "lid" | "pn">

  export type whatsmeow_lid_mapOrderByWithAggregationInput = {
    lid?: SortOrder
    pn?: SortOrder
    _count?: whatsmeow_lid_mapCountOrderByAggregateInput
    _max?: whatsmeow_lid_mapMaxOrderByAggregateInput
    _min?: whatsmeow_lid_mapMinOrderByAggregateInput
  }

  export type whatsmeow_lid_mapScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_lid_mapScalarWhereWithAggregatesInput | whatsmeow_lid_mapScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_lid_mapScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_lid_mapScalarWhereWithAggregatesInput | whatsmeow_lid_mapScalarWhereWithAggregatesInput[]
    lid?: StringWithAggregatesFilter<"whatsmeow_lid_map"> | string
    pn?: StringWithAggregatesFilter<"whatsmeow_lid_map"> | string
  }

  export type whatsmeow_message_secretsWhereInput = {
    AND?: whatsmeow_message_secretsWhereInput | whatsmeow_message_secretsWhereInput[]
    OR?: whatsmeow_message_secretsWhereInput[]
    NOT?: whatsmeow_message_secretsWhereInput | whatsmeow_message_secretsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    chat_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    sender_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    message_id?: StringFilter<"whatsmeow_message_secrets"> | string
    key?: BytesFilter<"whatsmeow_message_secrets"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_message_secretsOrderByWithRelationInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    key?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_message_secretsWhereUniqueInput = Prisma.AtLeast<{
    our_jid_chat_jid_sender_jid_message_id?: whatsmeow_message_secretsOur_jidChat_jidSender_jidMessage_idCompoundUniqueInput
    AND?: whatsmeow_message_secretsWhereInput | whatsmeow_message_secretsWhereInput[]
    OR?: whatsmeow_message_secretsWhereInput[]
    NOT?: whatsmeow_message_secretsWhereInput | whatsmeow_message_secretsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    chat_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    sender_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    message_id?: StringFilter<"whatsmeow_message_secrets"> | string
    key?: BytesFilter<"whatsmeow_message_secrets"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_chat_jid_sender_jid_message_id">

  export type whatsmeow_message_secretsOrderByWithAggregationInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    key?: SortOrder
    _count?: whatsmeow_message_secretsCountOrderByAggregateInput
    _max?: whatsmeow_message_secretsMaxOrderByAggregateInput
    _min?: whatsmeow_message_secretsMinOrderByAggregateInput
  }

  export type whatsmeow_message_secretsScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_message_secretsScalarWhereWithAggregatesInput | whatsmeow_message_secretsScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_message_secretsScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_message_secretsScalarWhereWithAggregatesInput | whatsmeow_message_secretsScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_message_secrets"> | string
    chat_jid?: StringWithAggregatesFilter<"whatsmeow_message_secrets"> | string
    sender_jid?: StringWithAggregatesFilter<"whatsmeow_message_secrets"> | string
    message_id?: StringWithAggregatesFilter<"whatsmeow_message_secrets"> | string
    key?: BytesWithAggregatesFilter<"whatsmeow_message_secrets"> | Uint8Array
  }

  export type whatsmeow_pre_keysWhereInput = {
    AND?: whatsmeow_pre_keysWhereInput | whatsmeow_pre_keysWhereInput[]
    OR?: whatsmeow_pre_keysWhereInput[]
    NOT?: whatsmeow_pre_keysWhereInput | whatsmeow_pre_keysWhereInput[]
    jid?: StringFilter<"whatsmeow_pre_keys"> | string
    key_id?: IntFilter<"whatsmeow_pre_keys"> | number
    key?: BytesFilter<"whatsmeow_pre_keys"> | Uint8Array
    uploaded?: BoolFilter<"whatsmeow_pre_keys"> | boolean
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_pre_keysOrderByWithRelationInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key?: SortOrder
    uploaded?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_pre_keysWhereUniqueInput = Prisma.AtLeast<{
    jid_key_id?: whatsmeow_pre_keysJidKey_idCompoundUniqueInput
    AND?: whatsmeow_pre_keysWhereInput | whatsmeow_pre_keysWhereInput[]
    OR?: whatsmeow_pre_keysWhereInput[]
    NOT?: whatsmeow_pre_keysWhereInput | whatsmeow_pre_keysWhereInput[]
    jid?: StringFilter<"whatsmeow_pre_keys"> | string
    key_id?: IntFilter<"whatsmeow_pre_keys"> | number
    key?: BytesFilter<"whatsmeow_pre_keys"> | Uint8Array
    uploaded?: BoolFilter<"whatsmeow_pre_keys"> | boolean
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "jid_key_id">

  export type whatsmeow_pre_keysOrderByWithAggregationInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key?: SortOrder
    uploaded?: SortOrder
    _count?: whatsmeow_pre_keysCountOrderByAggregateInput
    _avg?: whatsmeow_pre_keysAvgOrderByAggregateInput
    _max?: whatsmeow_pre_keysMaxOrderByAggregateInput
    _min?: whatsmeow_pre_keysMinOrderByAggregateInput
    _sum?: whatsmeow_pre_keysSumOrderByAggregateInput
  }

  export type whatsmeow_pre_keysScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_pre_keysScalarWhereWithAggregatesInput | whatsmeow_pre_keysScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_pre_keysScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_pre_keysScalarWhereWithAggregatesInput | whatsmeow_pre_keysScalarWhereWithAggregatesInput[]
    jid?: StringWithAggregatesFilter<"whatsmeow_pre_keys"> | string
    key_id?: IntWithAggregatesFilter<"whatsmeow_pre_keys"> | number
    key?: BytesWithAggregatesFilter<"whatsmeow_pre_keys"> | Uint8Array
    uploaded?: BoolWithAggregatesFilter<"whatsmeow_pre_keys"> | boolean
  }

  export type whatsmeow_privacy_tokensWhereInput = {
    AND?: whatsmeow_privacy_tokensWhereInput | whatsmeow_privacy_tokensWhereInput[]
    OR?: whatsmeow_privacy_tokensWhereInput[]
    NOT?: whatsmeow_privacy_tokensWhereInput | whatsmeow_privacy_tokensWhereInput[]
    our_jid?: StringFilter<"whatsmeow_privacy_tokens"> | string
    their_jid?: StringFilter<"whatsmeow_privacy_tokens"> | string
    token?: BytesFilter<"whatsmeow_privacy_tokens"> | Uint8Array
    timestamp?: BigIntFilter<"whatsmeow_privacy_tokens"> | bigint | number
  }

  export type whatsmeow_privacy_tokensOrderByWithRelationInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    token?: SortOrder
    timestamp?: SortOrder
  }

  export type whatsmeow_privacy_tokensWhereUniqueInput = Prisma.AtLeast<{
    our_jid_their_jid?: whatsmeow_privacy_tokensOur_jidTheir_jidCompoundUniqueInput
    AND?: whatsmeow_privacy_tokensWhereInput | whatsmeow_privacy_tokensWhereInput[]
    OR?: whatsmeow_privacy_tokensWhereInput[]
    NOT?: whatsmeow_privacy_tokensWhereInput | whatsmeow_privacy_tokensWhereInput[]
    our_jid?: StringFilter<"whatsmeow_privacy_tokens"> | string
    their_jid?: StringFilter<"whatsmeow_privacy_tokens"> | string
    token?: BytesFilter<"whatsmeow_privacy_tokens"> | Uint8Array
    timestamp?: BigIntFilter<"whatsmeow_privacy_tokens"> | bigint | number
  }, "our_jid_their_jid">

  export type whatsmeow_privacy_tokensOrderByWithAggregationInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    token?: SortOrder
    timestamp?: SortOrder
    _count?: whatsmeow_privacy_tokensCountOrderByAggregateInput
    _avg?: whatsmeow_privacy_tokensAvgOrderByAggregateInput
    _max?: whatsmeow_privacy_tokensMaxOrderByAggregateInput
    _min?: whatsmeow_privacy_tokensMinOrderByAggregateInput
    _sum?: whatsmeow_privacy_tokensSumOrderByAggregateInput
  }

  export type whatsmeow_privacy_tokensScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_privacy_tokensScalarWhereWithAggregatesInput | whatsmeow_privacy_tokensScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_privacy_tokensScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_privacy_tokensScalarWhereWithAggregatesInput | whatsmeow_privacy_tokensScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_privacy_tokens"> | string
    their_jid?: StringWithAggregatesFilter<"whatsmeow_privacy_tokens"> | string
    token?: BytesWithAggregatesFilter<"whatsmeow_privacy_tokens"> | Uint8Array
    timestamp?: BigIntWithAggregatesFilter<"whatsmeow_privacy_tokens"> | bigint | number
  }

  export type whatsmeow_sender_keysWhereInput = {
    AND?: whatsmeow_sender_keysWhereInput | whatsmeow_sender_keysWhereInput[]
    OR?: whatsmeow_sender_keysWhereInput[]
    NOT?: whatsmeow_sender_keysWhereInput | whatsmeow_sender_keysWhereInput[]
    our_jid?: StringFilter<"whatsmeow_sender_keys"> | string
    chat_id?: StringFilter<"whatsmeow_sender_keys"> | string
    sender_id?: StringFilter<"whatsmeow_sender_keys"> | string
    sender_key?: BytesFilter<"whatsmeow_sender_keys"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_sender_keysOrderByWithRelationInput = {
    our_jid?: SortOrder
    chat_id?: SortOrder
    sender_id?: SortOrder
    sender_key?: SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_sender_keysWhereUniqueInput = Prisma.AtLeast<{
    our_jid_chat_id_sender_id?: whatsmeow_sender_keysOur_jidChat_idSender_idCompoundUniqueInput
    AND?: whatsmeow_sender_keysWhereInput | whatsmeow_sender_keysWhereInput[]
    OR?: whatsmeow_sender_keysWhereInput[]
    NOT?: whatsmeow_sender_keysWhereInput | whatsmeow_sender_keysWhereInput[]
    our_jid?: StringFilter<"whatsmeow_sender_keys"> | string
    chat_id?: StringFilter<"whatsmeow_sender_keys"> | string
    sender_id?: StringFilter<"whatsmeow_sender_keys"> | string
    sender_key?: BytesFilter<"whatsmeow_sender_keys"> | Uint8Array
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_chat_id_sender_id">

  export type whatsmeow_sender_keysOrderByWithAggregationInput = {
    our_jid?: SortOrder
    chat_id?: SortOrder
    sender_id?: SortOrder
    sender_key?: SortOrder
    _count?: whatsmeow_sender_keysCountOrderByAggregateInput
    _max?: whatsmeow_sender_keysMaxOrderByAggregateInput
    _min?: whatsmeow_sender_keysMinOrderByAggregateInput
  }

  export type whatsmeow_sender_keysScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_sender_keysScalarWhereWithAggregatesInput | whatsmeow_sender_keysScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_sender_keysScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_sender_keysScalarWhereWithAggregatesInput | whatsmeow_sender_keysScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_sender_keys"> | string
    chat_id?: StringWithAggregatesFilter<"whatsmeow_sender_keys"> | string
    sender_id?: StringWithAggregatesFilter<"whatsmeow_sender_keys"> | string
    sender_key?: BytesWithAggregatesFilter<"whatsmeow_sender_keys"> | Uint8Array
  }

  export type whatsmeow_sessionsWhereInput = {
    AND?: whatsmeow_sessionsWhereInput | whatsmeow_sessionsWhereInput[]
    OR?: whatsmeow_sessionsWhereInput[]
    NOT?: whatsmeow_sessionsWhereInput | whatsmeow_sessionsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_sessions"> | string
    their_id?: StringFilter<"whatsmeow_sessions"> | string
    session?: BytesNullableFilter<"whatsmeow_sessions"> | Uint8Array | null
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }

  export type whatsmeow_sessionsOrderByWithRelationInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    session?: SortOrderInput | SortOrder
    whatsmeow_device?: whatsmeow_deviceOrderByWithRelationInput
  }

  export type whatsmeow_sessionsWhereUniqueInput = Prisma.AtLeast<{
    our_jid_their_id?: whatsmeow_sessionsOur_jidTheir_idCompoundUniqueInput
    AND?: whatsmeow_sessionsWhereInput | whatsmeow_sessionsWhereInput[]
    OR?: whatsmeow_sessionsWhereInput[]
    NOT?: whatsmeow_sessionsWhereInput | whatsmeow_sessionsWhereInput[]
    our_jid?: StringFilter<"whatsmeow_sessions"> | string
    their_id?: StringFilter<"whatsmeow_sessions"> | string
    session?: BytesNullableFilter<"whatsmeow_sessions"> | Uint8Array | null
    whatsmeow_device?: XOR<Whatsmeow_deviceScalarRelationFilter, whatsmeow_deviceWhereInput>
  }, "our_jid_their_id">

  export type whatsmeow_sessionsOrderByWithAggregationInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    session?: SortOrderInput | SortOrder
    _count?: whatsmeow_sessionsCountOrderByAggregateInput
    _max?: whatsmeow_sessionsMaxOrderByAggregateInput
    _min?: whatsmeow_sessionsMinOrderByAggregateInput
  }

  export type whatsmeow_sessionsScalarWhereWithAggregatesInput = {
    AND?: whatsmeow_sessionsScalarWhereWithAggregatesInput | whatsmeow_sessionsScalarWhereWithAggregatesInput[]
    OR?: whatsmeow_sessionsScalarWhereWithAggregatesInput[]
    NOT?: whatsmeow_sessionsScalarWhereWithAggregatesInput | whatsmeow_sessionsScalarWhereWithAggregatesInput[]
    our_jid?: StringWithAggregatesFilter<"whatsmeow_sessions"> | string
    their_id?: StringWithAggregatesFilter<"whatsmeow_sessions"> | string
    session?: BytesNullableWithAggregatesFilter<"whatsmeow_sessions"> | Uint8Array | null
  }

  export type app_usersCreateInput = {
    id: string
    username: string
    email: string
    password_hash: string
    first_name?: string | null
    last_name?: string | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
  }

  export type app_usersUncheckedCreateInput = {
    id: string
    username: string
    email: string
    password_hash: string
    first_name?: string | null
    last_name?: string | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
  }

  export type app_usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type app_usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type app_usersCreateManyInput = {
    id: string
    username: string
    email: string
    password_hash: string
    first_name?: string | null
    last_name?: string | null
    role?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    is_active?: boolean | null
  }

  export type app_usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type app_usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password_hash?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    last_name?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    is_active?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chatAssignmentDetailCreateInput = {
    chatId?: string | null
    assignedTo?: string | null
    assignedBy?: string | null
    chatAssignmentDetailId?: bigint | number
    assignedAt?: Date | string | null
  }

  export type chatAssignmentDetailUncheckedCreateInput = {
    chatId?: string | null
    assignedTo?: string | null
    assignedBy?: string | null
    chatAssignmentDetailId?: bigint | number
    assignedAt?: Date | string | null
  }

  export type chatAssignmentDetailUpdateInput = {
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    chatAssignmentDetailId?: BigIntFieldUpdateOperationsInput | bigint | number
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatAssignmentDetailUncheckedUpdateInput = {
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    chatAssignmentDetailId?: BigIntFieldUpdateOperationsInput | bigint | number
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatAssignmentDetailCreateManyInput = {
    chatId?: string | null
    assignedTo?: string | null
    assignedBy?: string | null
    chatAssignmentDetailId?: bigint | number
    assignedAt?: Date | string | null
  }

  export type chatAssignmentDetailUpdateManyMutationInput = {
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    chatAssignmentDetailId?: BigIntFieldUpdateOperationsInput | bigint | number
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatAssignmentDetailUncheckedUpdateManyInput = {
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    chatAssignmentDetailId?: BigIntFieldUpdateOperationsInput | bigint | number
    assignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type chatTagsCreateInput = {
    tagId?: bigint | number
    chatTagId?: bigint | number
    chatId?: string | null
    creationDate?: Date | string | null
    createdBy?: string | null
  }

  export type chatTagsUncheckedCreateInput = {
    tagId?: bigint | number
    chatTagId?: bigint | number
    chatId?: string | null
    creationDate?: Date | string | null
    createdBy?: string | null
  }

  export type chatTagsUpdateInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatTagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatTagsUncheckedUpdateInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatTagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatTagsCreateManyInput = {
    tagId?: bigint | number
    chatTagId?: bigint | number
    chatId?: string | null
    creationDate?: Date | string | null
    createdBy?: string | null
  }

  export type chatTagsUpdateManyMutationInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatTagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatTagsUncheckedUpdateManyInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatTagId?: BigIntFieldUpdateOperationsInput | bigint | number
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    creationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chat_status_detailsCreateInput = {
    status: string
    changed_by?: string | null
    changed_at?: Date | string | null
    reason?: string | null
    notes?: string | null
    chats: chatsCreateNestedOneWithoutChat_status_detailsInput
  }

  export type chat_status_detailsUncheckedCreateInput = {
    id?: number
    chat_id: string
    status: string
    changed_by?: string | null
    changed_at?: Date | string | null
    reason?: string | null
    notes?: string | null
  }

  export type chat_status_detailsUpdateInput = {
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: chatsUpdateOneRequiredWithoutChat_status_detailsNestedInput
  }

  export type chat_status_detailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    chat_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chat_status_detailsCreateManyInput = {
    id?: number
    chat_id: string
    status: string
    changed_by?: string | null
    changed_at?: Date | string | null
    reason?: string | null
    notes?: string | null
  }

  export type chat_status_detailsUpdateManyMutationInput = {
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chat_status_detailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    chat_id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatparticipantsCreateInput = {
    chats: chatsCreateNestedOneWithoutChatparticipantsInput
    contacts: contactsCreateNestedOneWithoutChatparticipantsInput
  }

  export type chatparticipantsUncheckedCreateInput = {
    chatid: string
    contactid: string
  }

  export type chatparticipantsUpdateInput = {
    chats?: chatsUpdateOneRequiredWithoutChatparticipantsNestedInput
    contacts?: contactsUpdateOneRequiredWithoutChatparticipantsNestedInput
  }

  export type chatparticipantsUncheckedUpdateInput = {
    chatid?: StringFieldUpdateOperationsInput | string
    contactid?: StringFieldUpdateOperationsInput | string
  }

  export type chatparticipantsCreateManyInput = {
    chatid: string
    contactid: string
  }

  export type chatparticipantsUpdateManyMutationInput = {

  }

  export type chatparticipantsUncheckedUpdateManyInput = {
    chatid?: StringFieldUpdateOperationsInput | string
    contactid?: StringFieldUpdateOperationsInput | string
  }

  export type chatsCreateInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chat_status_details?: chat_status_detailsCreateNestedManyWithoutChatsInput
    chatparticipants?: chatparticipantsCreateNestedManyWithoutChatsInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chat_status_details?: chat_status_detailsUncheckedCreateNestedManyWithoutChatsInput
    chatparticipants?: chatparticipantsUncheckedCreateNestedManyWithoutChatsInput
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_status_details?: chat_status_detailsUpdateManyWithoutChatsNestedInput
    chatparticipants?: chatparticipantsUpdateManyWithoutChatsNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_status_details?: chat_status_detailsUncheckedUpdateManyWithoutChatsNestedInput
    chatparticipants?: chatparticipantsUncheckedUpdateManyWithoutChatsNestedInput
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type chatsCreateManyInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
  }

  export type chatsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type chatsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type cleaned_contactsCreateInput = {
    phone: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
  }

  export type cleaned_contactsUncheckedCreateInput = {
    phone: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
  }

  export type cleaned_contactsUpdateInput = {
    phone?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cleaned_contactsUncheckedUpdateInput = {
    phone?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cleaned_contactsCreateManyInput = {
    phone: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
  }

  export type cleaned_contactsUpdateManyMutationInput = {
    phone?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cleaned_contactsUncheckedUpdateManyInput = {
    phone?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type contactsCreateInput = {
    id: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isTyping?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    lastSeen?: Date | string | null
    chatId?: string | null
    contactId?: string | null
    userId?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    chatparticipants?: chatparticipantsCreateNestedManyWithoutContactsInput
  }

  export type contactsUncheckedCreateInput = {
    id: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isTyping?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    lastSeen?: Date | string | null
    chatId?: string | null
    contactId?: string | null
    userId?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    chatparticipants?: chatparticipantsUncheckedCreateNestedManyWithoutContactsInput
  }

  export type contactsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isTyping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    chatparticipants?: chatparticipantsUpdateManyWithoutContactsNestedInput
  }

  export type contactsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isTyping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    chatparticipants?: chatparticipantsUncheckedUpdateManyWithoutContactsNestedInput
  }

  export type contactsCreateManyInput = {
    id: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isTyping?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    lastSeen?: Date | string | null
    chatId?: string | null
    contactId?: string | null
    userId?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type contactsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isTyping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type contactsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isTyping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type conversationsCreateInput = {
    name?: string | null
    is_group?: boolean | null
    created_at?: Date | string | null
  }

  export type conversationsUncheckedCreateInput = {
    id?: number
    name?: string | null
    is_group?: boolean | null
    created_at?: Date | string | null
  }

  export type conversationsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    is_group?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    is_group?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsCreateManyInput = {
    id?: number
    name?: string | null
    is_group?: boolean | null
    created_at?: Date | string | null
  }

  export type conversationsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    is_group?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type conversationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    is_group?: NullableBoolFieldUpdateOperationsInput | boolean | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type groupsCreateInput = {
    id: string
    name?: string | null
  }

  export type groupsUncheckedCreateInput = {
    id: string
    name?: string | null
  }

  export type groupsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupsCreateManyInput = {
    id: string
    name?: string | null
  }

  export type groupsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type groupsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageTemplatesCreateInput = {
    name: string
    content: string
    createdBy: string
    createdAt?: Date | string | null
    updatedat?: Date | string | null
    imagePath?: string | null
    mediaPath?: string | null
  }

  export type messageTemplatesUncheckedCreateInput = {
    id?: number
    name: string
    content: string
    createdBy: string
    createdAt?: Date | string | null
    updatedat?: Date | string | null
    imagePath?: string | null
    mediaPath?: string | null
  }

  export type messageTemplatesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageTemplatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageTemplatesCreateManyInput = {
    id?: number
    name: string
    content: string
    createdBy: string
    createdAt?: Date | string | null
    updatedat?: Date | string | null
    imagePath?: string | null
    mediaPath?: string | null
  }

  export type messageTemplatesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messageTemplatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updatedat?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    imagePath?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type message_historyCreateInput = {
    user_id: string
    chat_jid: string
    sender_jid: string
    message_id: string
    timestamp: Date | string
    message_type: string
    text_content?: string | null
    media_link?: string | null
    quoted_message_id?: string | null
    datajson?: string | null
  }

  export type message_historyUncheckedCreateInput = {
    id?: number
    user_id: string
    chat_jid: string
    sender_jid: string
    message_id: string
    timestamp: Date | string
    message_type: string
    text_content?: string | null
    media_link?: string | null
    quoted_message_id?: string | null
    datajson?: string | null
  }

  export type message_historyUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message_type?: StringFieldUpdateOperationsInput | string
    text_content?: NullableStringFieldUpdateOperationsInput | string | null
    media_link?: NullableStringFieldUpdateOperationsInput | string | null
    quoted_message_id?: NullableStringFieldUpdateOperationsInput | string | null
    datajson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type message_historyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message_type?: StringFieldUpdateOperationsInput | string
    text_content?: NullableStringFieldUpdateOperationsInput | string | null
    media_link?: NullableStringFieldUpdateOperationsInput | string | null
    quoted_message_id?: NullableStringFieldUpdateOperationsInput | string | null
    datajson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type message_historyCreateManyInput = {
    id?: number
    user_id: string
    chat_jid: string
    sender_jid: string
    message_id: string
    timestamp: Date | string
    message_type: string
    text_content?: string | null
    media_link?: string | null
    quoted_message_id?: string | null
    datajson?: string | null
  }

  export type message_historyUpdateManyMutationInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message_type?: StringFieldUpdateOperationsInput | string
    text_content?: NullableStringFieldUpdateOperationsInput | string | null
    media_link?: NullableStringFieldUpdateOperationsInput | string | null
    quoted_message_id?: NullableStringFieldUpdateOperationsInput | string | null
    datajson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type message_historyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    message_type?: StringFieldUpdateOperationsInput | string
    text_content?: NullableStringFieldUpdateOperationsInput | string | null
    media_link?: NullableStringFieldUpdateOperationsInput | string | null
    quoted_message_id?: NullableStringFieldUpdateOperationsInput | string | null
    datajson?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type message_reactionsCreateInput = {
    participant?: string | null
    emoji: string
    createdAt?: Date | string | null
    userId?: string | null
    id: string
    messages: messagesCreateNestedOneWithoutMessage_reactionsInput
  }

  export type message_reactionsUncheckedCreateInput = {
    messageId: string
    participant?: string | null
    emoji: string
    createdAt?: Date | string | null
    userId?: string | null
    id: string
  }

  export type message_reactionsUpdateInput = {
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
    messages?: messagesUpdateOneRequiredWithoutMessage_reactionsNestedInput
  }

  export type message_reactionsUncheckedUpdateInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type message_reactionsCreateManyInput = {
    messageId: string
    participant?: string | null
    emoji: string
    createdAt?: Date | string | null
    userId?: string | null
    id: string
  }

  export type message_reactionsUpdateManyMutationInput = {
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type message_reactionsUncheckedUpdateManyInput = {
    messageId?: StringFieldUpdateOperationsInput | string
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type messagesCreateInput = {
    id: string
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
    message_reactions?: message_reactionsCreateNestedManyWithoutMessagesInput
    chats?: chatsCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateInput = {
    id: string
    chatId?: string | null
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
    message_reactions?: message_reactionsUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    message_reactions?: message_reactionsUpdateManyWithoutMessagesNestedInput
    chats?: chatsUpdateOneWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    message_reactions?: message_reactionsUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesCreateManyInput = {
    id: string
    chatId?: string | null
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
  }

  export type messagesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type messagesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type migrationsCreateInput = {
    id: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUncheckedCreateInput = {
    id: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsCreateManyInput = {
    id: number
    name: string
    applied_at?: Date | string | null
  }

  export type migrationsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    applied_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type tagsCreateInput = {
    tagId?: bigint | number
    tagName?: string | null
  }

  export type tagsUncheckedCreateInput = {
    tagId?: bigint | number
    tagName?: string | null
  }

  export type tagsUpdateInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tagsUncheckedUpdateInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tagsCreateManyInput = {
    tagId?: bigint | number
    tagName?: string | null
  }

  export type tagsUpdateManyMutationInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type tagsUncheckedUpdateManyInput = {
    tagId?: BigIntFieldUpdateOperationsInput | bigint | number
    tagName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateInput = {
    id: string
    name: string
    token: string
    webhook?: string
    jid?: string
    qrcode?: string
    connected?: number | null
    expiration?: number | null
    events?: string
    proxy_url?: string | null
    s3_enabled?: boolean | null
    s3_endpoint?: string | null
    s3_region?: string | null
    s3_bucket?: string | null
    s3_access_key?: string | null
    s3_secret_key?: string | null
    s3_path_style?: boolean | null
    s3_public_url?: string | null
    media_delivery?: string | null
    s3_retention_days?: number | null
    history?: number | null
    hmac_key?: Uint8Array | null
  }

  export type usersUncheckedCreateInput = {
    id: string
    name: string
    token: string
    webhook?: string
    jid?: string
    qrcode?: string
    connected?: number | null
    expiration?: number | null
    events?: string
    proxy_url?: string | null
    s3_enabled?: boolean | null
    s3_endpoint?: string | null
    s3_region?: string | null
    s3_bucket?: string | null
    s3_access_key?: string | null
    s3_secret_key?: string | null
    s3_path_style?: boolean | null
    s3_public_url?: string | null
    media_delivery?: string | null
    s3_retention_days?: number | null
    history?: number | null
    hmac_key?: Uint8Array | null
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    webhook?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    qrcode?: StringFieldUpdateOperationsInput | string
    connected?: NullableIntFieldUpdateOperationsInput | number | null
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    events?: StringFieldUpdateOperationsInput | string
    proxy_url?: NullableStringFieldUpdateOperationsInput | string | null
    s3_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3_region?: NullableStringFieldUpdateOperationsInput | string | null
    s3_bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3_access_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_path_style?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_public_url?: NullableStringFieldUpdateOperationsInput | string | null
    media_delivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3_retention_days?: NullableIntFieldUpdateOperationsInput | number | null
    history?: NullableIntFieldUpdateOperationsInput | number | null
    hmac_key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    webhook?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    qrcode?: StringFieldUpdateOperationsInput | string
    connected?: NullableIntFieldUpdateOperationsInput | number | null
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    events?: StringFieldUpdateOperationsInput | string
    proxy_url?: NullableStringFieldUpdateOperationsInput | string | null
    s3_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3_region?: NullableStringFieldUpdateOperationsInput | string | null
    s3_bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3_access_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_path_style?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_public_url?: NullableStringFieldUpdateOperationsInput | string | null
    media_delivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3_retention_days?: NullableIntFieldUpdateOperationsInput | number | null
    history?: NullableIntFieldUpdateOperationsInput | number | null
    hmac_key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type usersCreateManyInput = {
    id: string
    name: string
    token: string
    webhook?: string
    jid?: string
    qrcode?: string
    connected?: number | null
    expiration?: number | null
    events?: string
    proxy_url?: string | null
    s3_enabled?: boolean | null
    s3_endpoint?: string | null
    s3_region?: string | null
    s3_bucket?: string | null
    s3_access_key?: string | null
    s3_secret_key?: string | null
    s3_path_style?: boolean | null
    s3_public_url?: string | null
    media_delivery?: string | null
    s3_retention_days?: number | null
    history?: number | null
    hmac_key?: Uint8Array | null
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    webhook?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    qrcode?: StringFieldUpdateOperationsInput | string
    connected?: NullableIntFieldUpdateOperationsInput | number | null
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    events?: StringFieldUpdateOperationsInput | string
    proxy_url?: NullableStringFieldUpdateOperationsInput | string | null
    s3_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3_region?: NullableStringFieldUpdateOperationsInput | string | null
    s3_bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3_access_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_path_style?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_public_url?: NullableStringFieldUpdateOperationsInput | string | null
    media_delivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3_retention_days?: NullableIntFieldUpdateOperationsInput | number | null
    history?: NullableIntFieldUpdateOperationsInput | number | null
    hmac_key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    webhook?: StringFieldUpdateOperationsInput | string
    jid?: StringFieldUpdateOperationsInput | string
    qrcode?: StringFieldUpdateOperationsInput | string
    connected?: NullableIntFieldUpdateOperationsInput | number | null
    expiration?: NullableIntFieldUpdateOperationsInput | number | null
    events?: StringFieldUpdateOperationsInput | string
    proxy_url?: NullableStringFieldUpdateOperationsInput | string | null
    s3_enabled?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    s3_region?: NullableStringFieldUpdateOperationsInput | string | null
    s3_bucket?: NullableStringFieldUpdateOperationsInput | string | null
    s3_access_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_secret_key?: NullableStringFieldUpdateOperationsInput | string | null
    s3_path_style?: NullableBoolFieldUpdateOperationsInput | boolean | null
    s3_public_url?: NullableStringFieldUpdateOperationsInput | string | null
    media_delivery?: NullableStringFieldUpdateOperationsInput | string | null
    s3_retention_days?: NullableIntFieldUpdateOperationsInput | number | null
    history?: NullableIntFieldUpdateOperationsInput | number | null
    hmac_key?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type whatsmeow_app_state_mutation_macsCreateInput = {
    version: bigint | number
    index_mac: Uint8Array
    value_mac: Uint8Array
    whatsmeow_app_state_version: whatsmeow_app_state_versionCreateNestedOneWithoutWhatsmeow_app_state_mutation_macsInput
  }

  export type whatsmeow_app_state_mutation_macsUncheckedCreateInput = {
    jid: string
    name: string
    version: bigint | number
    index_mac: Uint8Array
    value_mac: Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUpdateInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateOneRequiredWithoutWhatsmeow_app_state_mutation_macsNestedInput
  }

  export type whatsmeow_app_state_mutation_macsUncheckedUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsCreateManyInput = {
    jid: string
    name: string
    version: bigint | number
    index_mac: Uint8Array
    value_mac: Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUpdateManyMutationInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUncheckedUpdateManyInput = {
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysCreateInput = {
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint | number
    fingerprint: Uint8Array
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_app_state_sync_keysInput
  }

  export type whatsmeow_app_state_sync_keysUncheckedCreateInput = {
    jid: string
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint | number
    fingerprint: Uint8Array
  }

  export type whatsmeow_app_state_sync_keysUpdateInput = {
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_app_state_sync_keysNestedInput
  }

  export type whatsmeow_app_state_sync_keysUncheckedUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysCreateManyInput = {
    jid: string
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint | number
    fingerprint: Uint8Array
  }

  export type whatsmeow_app_state_sync_keysUpdateManyMutationInput = {
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysUncheckedUpdateManyInput = {
    jid?: StringFieldUpdateOperationsInput | string
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_versionCreateInput = {
    name: string
    version: bigint | number
    hash: Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsCreateNestedManyWithoutWhatsmeow_app_state_versionInput
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_app_state_versionInput
  }

  export type whatsmeow_app_state_versionUncheckedCreateInput = {
    jid: string
    name: string
    version: bigint | number
    hash: Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsUncheckedCreateNestedManyWithoutWhatsmeow_app_state_versionInput
  }

  export type whatsmeow_app_state_versionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsUpdateManyWithoutWhatsmeow_app_state_versionNestedInput
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_app_state_versionNestedInput
  }

  export type whatsmeow_app_state_versionUncheckedUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsUncheckedUpdateManyWithoutWhatsmeow_app_state_versionNestedInput
  }

  export type whatsmeow_app_state_versionCreateManyInput = {
    jid: string
    name: string
    version: bigint | number
    hash: Uint8Array
  }

  export type whatsmeow_app_state_versionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_versionUncheckedUpdateManyInput = {
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_chat_settingsCreateInput = {
    chat_jid: string
    muted_until?: bigint | number
    pinned?: boolean
    archived?: boolean
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_chat_settingsInput
  }

  export type whatsmeow_chat_settingsUncheckedCreateInput = {
    our_jid: string
    chat_jid: string
    muted_until?: bigint | number
    pinned?: boolean
    archived?: boolean
  }

  export type whatsmeow_chat_settingsUpdateInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_chat_settingsNestedInput
  }

  export type whatsmeow_chat_settingsUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_chat_settingsCreateManyInput = {
    our_jid: string
    chat_jid: string
    muted_until?: bigint | number
    pinned?: boolean
    archived?: boolean
  }

  export type whatsmeow_chat_settingsUpdateManyMutationInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_chat_settingsUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_contactsCreateInput = {
    their_jid: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
    redacted_phone?: string | null
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_contactsInput
  }

  export type whatsmeow_contactsUncheckedCreateInput = {
    our_jid: string
    their_jid: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
    redacted_phone?: string | null
  }

  export type whatsmeow_contactsUpdateInput = {
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_contactsNestedInput
  }

  export type whatsmeow_contactsUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type whatsmeow_contactsCreateManyInput = {
    our_jid: string
    their_jid: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
    redacted_phone?: string | null
  }

  export type whatsmeow_contactsUpdateManyMutationInput = {
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type whatsmeow_contactsUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type whatsmeow_deviceCreateInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateManyInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
  }

  export type whatsmeow_deviceUpdateManyMutationInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_deviceUncheckedUpdateManyInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_event_bufferCreateInput = {
    ciphertext_hash: Uint8Array
    plaintext?: Uint8Array | null
    server_timestamp: bigint | number
    insert_timestamp: bigint | number
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_event_bufferInput
  }

  export type whatsmeow_event_bufferUncheckedCreateInput = {
    our_jid: string
    ciphertext_hash: Uint8Array
    plaintext?: Uint8Array | null
    server_timestamp: bigint | number
    insert_timestamp: bigint | number
  }

  export type whatsmeow_event_bufferUpdateInput = {
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_event_bufferNestedInput
  }

  export type whatsmeow_event_bufferUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_event_bufferCreateManyInput = {
    our_jid: string
    ciphertext_hash: Uint8Array
    plaintext?: Uint8Array | null
    server_timestamp: bigint | number
    insert_timestamp: bigint | number
  }

  export type whatsmeow_event_bufferUpdateManyMutationInput = {
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_event_bufferUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_identity_keysCreateInput = {
    their_id: string
    identity: Uint8Array
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_identity_keysInput
  }

  export type whatsmeow_identity_keysUncheckedCreateInput = {
    our_jid: string
    their_id: string
    identity: Uint8Array
  }

  export type whatsmeow_identity_keysUpdateInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_identity_keysNestedInput
  }

  export type whatsmeow_identity_keysUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_identity_keysCreateManyInput = {
    our_jid: string
    their_id: string
    identity: Uint8Array
  }

  export type whatsmeow_identity_keysUpdateManyMutationInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_identity_keysUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_lid_mapCreateInput = {
    lid: string
    pn: string
  }

  export type whatsmeow_lid_mapUncheckedCreateInput = {
    lid: string
    pn: string
  }

  export type whatsmeow_lid_mapUpdateInput = {
    lid?: StringFieldUpdateOperationsInput | string
    pn?: StringFieldUpdateOperationsInput | string
  }

  export type whatsmeow_lid_mapUncheckedUpdateInput = {
    lid?: StringFieldUpdateOperationsInput | string
    pn?: StringFieldUpdateOperationsInput | string
  }

  export type whatsmeow_lid_mapCreateManyInput = {
    lid: string
    pn: string
  }

  export type whatsmeow_lid_mapUpdateManyMutationInput = {
    lid?: StringFieldUpdateOperationsInput | string
    pn?: StringFieldUpdateOperationsInput | string
  }

  export type whatsmeow_lid_mapUncheckedUpdateManyInput = {
    lid?: StringFieldUpdateOperationsInput | string
    pn?: StringFieldUpdateOperationsInput | string
  }

  export type whatsmeow_message_secretsCreateInput = {
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_message_secretsInput
  }

  export type whatsmeow_message_secretsUncheckedCreateInput = {
    our_jid: string
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
  }

  export type whatsmeow_message_secretsUpdateInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_message_secretsNestedInput
  }

  export type whatsmeow_message_secretsUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_message_secretsCreateManyInput = {
    our_jid: string
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
  }

  export type whatsmeow_message_secretsUpdateManyMutationInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_message_secretsUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_pre_keysCreateInput = {
    key_id: number
    key: Uint8Array
    uploaded: boolean
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_pre_keysInput
  }

  export type whatsmeow_pre_keysUncheckedCreateInput = {
    jid: string
    key_id: number
    key: Uint8Array
    uploaded: boolean
  }

  export type whatsmeow_pre_keysUpdateInput = {
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_pre_keysNestedInput
  }

  export type whatsmeow_pre_keysUncheckedUpdateInput = {
    jid?: StringFieldUpdateOperationsInput | string
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_pre_keysCreateManyInput = {
    jid: string
    key_id: number
    key: Uint8Array
    uploaded: boolean
  }

  export type whatsmeow_pre_keysUpdateManyMutationInput = {
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_pre_keysUncheckedUpdateManyInput = {
    jid?: StringFieldUpdateOperationsInput | string
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_privacy_tokensCreateInput = {
    our_jid: string
    their_jid: string
    token: Uint8Array
    timestamp: bigint | number
  }

  export type whatsmeow_privacy_tokensUncheckedCreateInput = {
    our_jid: string
    their_jid: string
    token: Uint8Array
    timestamp: bigint | number
  }

  export type whatsmeow_privacy_tokensUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_jid?: StringFieldUpdateOperationsInput | string
    token?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_privacy_tokensUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_jid?: StringFieldUpdateOperationsInput | string
    token?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_privacy_tokensCreateManyInput = {
    our_jid: string
    their_jid: string
    token: Uint8Array
    timestamp: bigint | number
  }

  export type whatsmeow_privacy_tokensUpdateManyMutationInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_jid?: StringFieldUpdateOperationsInput | string
    token?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_privacy_tokensUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_jid?: StringFieldUpdateOperationsInput | string
    token?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_sender_keysCreateInput = {
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_sender_keysInput
  }

  export type whatsmeow_sender_keysUncheckedCreateInput = {
    our_jid: string
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
  }

  export type whatsmeow_sender_keysUpdateInput = {
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_sender_keysNestedInput
  }

  export type whatsmeow_sender_keysUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_sender_keysCreateManyInput = {
    our_jid: string
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
  }

  export type whatsmeow_sender_keysUpdateManyMutationInput = {
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_sender_keysUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_sessionsCreateInput = {
    their_id: string
    session?: Uint8Array | null
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_sessionsInput
  }

  export type whatsmeow_sessionsUncheckedCreateInput = {
    our_jid: string
    their_id: string
    session?: Uint8Array | null
  }

  export type whatsmeow_sessionsUpdateInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_sessionsNestedInput
  }

  export type whatsmeow_sessionsUncheckedUpdateInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type whatsmeow_sessionsCreateManyInput = {
    our_jid: string
    their_id: string
    session?: Uint8Array | null
  }

  export type whatsmeow_sessionsUpdateManyMutationInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type whatsmeow_sessionsUncheckedUpdateManyInput = {
    our_jid?: StringFieldUpdateOperationsInput | string
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type app_usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
  }

  export type app_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
  }

  export type app_usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    email?: SortOrder
    password_hash?: SortOrder
    first_name?: SortOrder
    last_name?: SortOrder
    role?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    is_active?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type chatAssignmentDetailChatIdAssignedToCompoundUniqueInput = {
    chatId: string
    assignedTo: string
  }

  export type chatAssignmentDetailCountOrderByAggregateInput = {
    chatId?: SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    chatAssignmentDetailId?: SortOrder
    assignedAt?: SortOrder
  }

  export type chatAssignmentDetailAvgOrderByAggregateInput = {
    chatAssignmentDetailId?: SortOrder
  }

  export type chatAssignmentDetailMaxOrderByAggregateInput = {
    chatId?: SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    chatAssignmentDetailId?: SortOrder
    assignedAt?: SortOrder
  }

  export type chatAssignmentDetailMinOrderByAggregateInput = {
    chatId?: SortOrder
    assignedTo?: SortOrder
    assignedBy?: SortOrder
    chatAssignmentDetailId?: SortOrder
    assignedAt?: SortOrder
  }

  export type chatAssignmentDetailSumOrderByAggregateInput = {
    chatAssignmentDetailId?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type chatTagsCountOrderByAggregateInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
    chatId?: SortOrder
    creationDate?: SortOrder
    createdBy?: SortOrder
  }

  export type chatTagsAvgOrderByAggregateInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
  }

  export type chatTagsMaxOrderByAggregateInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
    chatId?: SortOrder
    creationDate?: SortOrder
    createdBy?: SortOrder
  }

  export type chatTagsMinOrderByAggregateInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
    chatId?: SortOrder
    creationDate?: SortOrder
    createdBy?: SortOrder
  }

  export type chatTagsSumOrderByAggregateInput = {
    tagId?: SortOrder
    chatTagId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ChatsScalarRelationFilter = {
    is?: chatsWhereInput
    isNot?: chatsWhereInput
  }

  export type chat_status_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    chat_id?: SortOrder
    status?: SortOrder
    changed_by?: SortOrder
    changed_at?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
  }

  export type chat_status_detailsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type chat_status_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    chat_id?: SortOrder
    status?: SortOrder
    changed_by?: SortOrder
    changed_at?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
  }

  export type chat_status_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    chat_id?: SortOrder
    status?: SortOrder
    changed_by?: SortOrder
    changed_at?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
  }

  export type chat_status_detailsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ContactsScalarRelationFilter = {
    is?: contactsWhereInput
    isNot?: contactsWhereInput
  }

  export type chatparticipantsChatidContactidCompoundUniqueInput = {
    chatid: string
    contactid: string
  }

  export type chatparticipantsCountOrderByAggregateInput = {
    chatid?: SortOrder
    contactid?: SortOrder
  }

  export type chatparticipantsMaxOrderByAggregateInput = {
    chatid?: SortOrder
    contactid?: SortOrder
  }

  export type chatparticipantsMinOrderByAggregateInput = {
    chatid?: SortOrder
    contactid?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type Chat_status_detailsListRelationFilter = {
    every?: chat_status_detailsWhereInput
    some?: chat_status_detailsWhereInput
    none?: chat_status_detailsWhereInput
  }

  export type ChatparticipantsListRelationFilter = {
    every?: chatparticipantsWhereInput
    some?: chatparticipantsWhereInput
    none?: chatparticipantsWhereInput
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type chat_status_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatparticipantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type chatsCountOrderByAggregateInput = {
    id?: SortOrder
    lastMessage?: SortOrder
    lastMessageTime?: SortOrder
    unReadCount?: SortOrder
    isOnline?: SortOrder
    contactId?: SortOrder
    isTyping?: SortOrder
    userId?: SortOrder
    pushname?: SortOrder
    assignedTo?: SortOrder
    isarchived?: SortOrder
    ismuted?: SortOrder
    status?: SortOrder
    closedAt?: SortOrder
    closeReason?: SortOrder
    participants?: SortOrder
    avatar?: SortOrder
    isPinned?: SortOrder
  }

  export type chatsAvgOrderByAggregateInput = {
    unReadCount?: SortOrder
  }

  export type chatsMaxOrderByAggregateInput = {
    id?: SortOrder
    lastMessage?: SortOrder
    lastMessageTime?: SortOrder
    unReadCount?: SortOrder
    isOnline?: SortOrder
    contactId?: SortOrder
    isTyping?: SortOrder
    userId?: SortOrder
    pushname?: SortOrder
    assignedTo?: SortOrder
    isarchived?: SortOrder
    ismuted?: SortOrder
    status?: SortOrder
    closedAt?: SortOrder
    closeReason?: SortOrder
    avatar?: SortOrder
    isPinned?: SortOrder
  }

  export type chatsMinOrderByAggregateInput = {
    id?: SortOrder
    lastMessage?: SortOrder
    lastMessageTime?: SortOrder
    unReadCount?: SortOrder
    isOnline?: SortOrder
    contactId?: SortOrder
    isTyping?: SortOrder
    userId?: SortOrder
    pushname?: SortOrder
    assignedTo?: SortOrder
    isarchived?: SortOrder
    ismuted?: SortOrder
    status?: SortOrder
    closedAt?: SortOrder
    closeReason?: SortOrder
    avatar?: SortOrder
    isPinned?: SortOrder
  }

  export type chatsSumOrderByAggregateInput = {
    unReadCount?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type cleaned_contactsCountOrderByAggregateInput = {
    phone?: SortOrder
    first_name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    business_name?: SortOrder
  }

  export type cleaned_contactsMaxOrderByAggregateInput = {
    phone?: SortOrder
    first_name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    business_name?: SortOrder
  }

  export type cleaned_contactsMinOrderByAggregateInput = {
    phone?: SortOrder
    first_name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    business_name?: SortOrder
  }

  export type contactsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    lastMessage?: SortOrder
    lastMessageTime?: SortOrder
    unReadCount?: SortOrder
    isTyping?: SortOrder
    isOnline?: SortOrder
    image?: SortOrder
    lastSeen?: SortOrder
    chatId?: SortOrder
    contactId?: SortOrder
    userId?: SortOrder
    tags?: SortOrder
  }

  export type contactsAvgOrderByAggregateInput = {
    unReadCount?: SortOrder
  }

  export type contactsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    lastMessage?: SortOrder
    lastMessageTime?: SortOrder
    unReadCount?: SortOrder
    isTyping?: SortOrder
    isOnline?: SortOrder
    image?: SortOrder
    lastSeen?: SortOrder
    chatId?: SortOrder
    contactId?: SortOrder
    userId?: SortOrder
  }

  export type contactsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    address?: SortOrder
    city?: SortOrder
    state?: SortOrder
    zip?: SortOrder
    country?: SortOrder
    lastMessage?: SortOrder
    lastMessageTime?: SortOrder
    unReadCount?: SortOrder
    isTyping?: SortOrder
    isOnline?: SortOrder
    image?: SortOrder
    lastSeen?: SortOrder
    chatId?: SortOrder
    contactId?: SortOrder
    userId?: SortOrder
  }

  export type contactsSumOrderByAggregateInput = {
    unReadCount?: SortOrder
  }

  export type conversationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_group?: SortOrder
    created_at?: SortOrder
  }

  export type conversationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type conversationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_group?: SortOrder
    created_at?: SortOrder
  }

  export type conversationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    is_group?: SortOrder
    created_at?: SortOrder
  }

  export type conversationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type groupsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type groupsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type messageTemplatesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedat?: SortOrder
    imagePath?: SortOrder
    mediaPath?: SortOrder
  }

  export type messageTemplatesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type messageTemplatesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedat?: SortOrder
    imagePath?: SortOrder
    mediaPath?: SortOrder
  }

  export type messageTemplatesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    content?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedat?: SortOrder
    imagePath?: SortOrder
    mediaPath?: SortOrder
  }

  export type messageTemplatesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type message_historyUser_idMessage_idCompoundUniqueInput = {
    user_id: string
    message_id: string
  }

  export type message_historyCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    timestamp?: SortOrder
    message_type?: SortOrder
    text_content?: SortOrder
    media_link?: SortOrder
    quoted_message_id?: SortOrder
    datajson?: SortOrder
  }

  export type message_historyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type message_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    timestamp?: SortOrder
    message_type?: SortOrder
    text_content?: SortOrder
    media_link?: SortOrder
    quoted_message_id?: SortOrder
    datajson?: SortOrder
  }

  export type message_historyMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    timestamp?: SortOrder
    message_type?: SortOrder
    text_content?: SortOrder
    media_link?: SortOrder
    quoted_message_id?: SortOrder
    datajson?: SortOrder
  }

  export type message_historySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type MessagesScalarRelationFilter = {
    is?: messagesWhereInput
    isNot?: messagesWhereInput
  }

  export type message_reactionsMessageIdParticipantCompoundUniqueInput = {
    messageId: string
    participant: string
  }

  export type message_reactionsCountOrderByAggregateInput = {
    messageId?: SortOrder
    participant?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    id?: SortOrder
  }

  export type message_reactionsMaxOrderByAggregateInput = {
    messageId?: SortOrder
    participant?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    id?: SortOrder
  }

  export type message_reactionsMinOrderByAggregateInput = {
    messageId?: SortOrder
    participant?: SortOrder
    emoji?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    id?: SortOrder
  }

  export type Message_reactionsListRelationFilter = {
    every?: message_reactionsWhereInput
    some?: message_reactionsWhereInput
    none?: message_reactionsWhereInput
  }

  export type ChatsNullableScalarRelationFilter = {
    is?: chatsWhereInput | null
    isNot?: chatsWhereInput | null
  }

  export type message_reactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messagesCountOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    timeStamp?: SortOrder
    isDelivered?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    isFromMe?: SortOrder
    contactId?: SortOrder
    isEdit?: SortOrder
    pushname?: SortOrder
    mediaPath?: SortOrder
    note?: SortOrder
    isPinned?: SortOrder
    userId?: SortOrder
    replyToMessageId?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    timeStamp?: SortOrder
    isDelivered?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    isFromMe?: SortOrder
    contactId?: SortOrder
    isEdit?: SortOrder
    pushname?: SortOrder
    mediaPath?: SortOrder
    note?: SortOrder
    isPinned?: SortOrder
    userId?: SortOrder
    replyToMessageId?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    id?: SortOrder
    chatId?: SortOrder
    message?: SortOrder
    timeStamp?: SortOrder
    isDelivered?: SortOrder
    isRead?: SortOrder
    messageType?: SortOrder
    isFromMe?: SortOrder
    contactId?: SortOrder
    isEdit?: SortOrder
    pushname?: SortOrder
    mediaPath?: SortOrder
    note?: SortOrder
    isPinned?: SortOrder
    userId?: SortOrder
    replyToMessageId?: SortOrder
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    applied_at?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type tagsCountOrderByAggregateInput = {
    tagId?: SortOrder
    tagName?: SortOrder
  }

  export type tagsAvgOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type tagsMaxOrderByAggregateInput = {
    tagId?: SortOrder
    tagName?: SortOrder
  }

  export type tagsMinOrderByAggregateInput = {
    tagId?: SortOrder
    tagName?: SortOrder
  }

  export type tagsSumOrderByAggregateInput = {
    tagId?: SortOrder
  }

  export type BytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    jid?: SortOrder
    qrcode?: SortOrder
    connected?: SortOrder
    expiration?: SortOrder
    events?: SortOrder
    proxy_url?: SortOrder
    s3_enabled?: SortOrder
    s3_endpoint?: SortOrder
    s3_region?: SortOrder
    s3_bucket?: SortOrder
    s3_access_key?: SortOrder
    s3_secret_key?: SortOrder
    s3_path_style?: SortOrder
    s3_public_url?: SortOrder
    media_delivery?: SortOrder
    s3_retention_days?: SortOrder
    history?: SortOrder
    hmac_key?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    connected?: SortOrder
    expiration?: SortOrder
    s3_retention_days?: SortOrder
    history?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    jid?: SortOrder
    qrcode?: SortOrder
    connected?: SortOrder
    expiration?: SortOrder
    events?: SortOrder
    proxy_url?: SortOrder
    s3_enabled?: SortOrder
    s3_endpoint?: SortOrder
    s3_region?: SortOrder
    s3_bucket?: SortOrder
    s3_access_key?: SortOrder
    s3_secret_key?: SortOrder
    s3_path_style?: SortOrder
    s3_public_url?: SortOrder
    media_delivery?: SortOrder
    s3_retention_days?: SortOrder
    history?: SortOrder
    hmac_key?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    token?: SortOrder
    webhook?: SortOrder
    jid?: SortOrder
    qrcode?: SortOrder
    connected?: SortOrder
    expiration?: SortOrder
    events?: SortOrder
    proxy_url?: SortOrder
    s3_enabled?: SortOrder
    s3_endpoint?: SortOrder
    s3_region?: SortOrder
    s3_bucket?: SortOrder
    s3_access_key?: SortOrder
    s3_secret_key?: SortOrder
    s3_path_style?: SortOrder
    s3_public_url?: SortOrder
    media_delivery?: SortOrder
    s3_retention_days?: SortOrder
    history?: SortOrder
    hmac_key?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    connected?: SortOrder
    expiration?: SortOrder
    s3_retention_days?: SortOrder
    history?: SortOrder
  }

  export type BytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type Whatsmeow_app_state_versionScalarRelationFilter = {
    is?: whatsmeow_app_state_versionWhereInput
    isNot?: whatsmeow_app_state_versionWhereInput
  }

  export type whatsmeow_app_state_mutation_macsJidNameVersionIndex_macCompoundUniqueInput = {
    jid: string
    name: string
    version: bigint | number
    index_mac: Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsCountOrderByAggregateInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    index_mac?: SortOrder
    value_mac?: SortOrder
  }

  export type whatsmeow_app_state_mutation_macsAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type whatsmeow_app_state_mutation_macsMaxOrderByAggregateInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    index_mac?: SortOrder
    value_mac?: SortOrder
  }

  export type whatsmeow_app_state_mutation_macsMinOrderByAggregateInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    index_mac?: SortOrder
    value_mac?: SortOrder
  }

  export type whatsmeow_app_state_mutation_macsSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type Whatsmeow_deviceScalarRelationFilter = {
    is?: whatsmeow_deviceWhereInput
    isNot?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_app_state_sync_keysJidKey_idCompoundUniqueInput = {
    jid: string
    key_id: Uint8Array
  }

  export type whatsmeow_app_state_sync_keysCountOrderByAggregateInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key_data?: SortOrder
    timestamp?: SortOrder
    fingerprint?: SortOrder
  }

  export type whatsmeow_app_state_sync_keysAvgOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type whatsmeow_app_state_sync_keysMaxOrderByAggregateInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key_data?: SortOrder
    timestamp?: SortOrder
    fingerprint?: SortOrder
  }

  export type whatsmeow_app_state_sync_keysMinOrderByAggregateInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key_data?: SortOrder
    timestamp?: SortOrder
    fingerprint?: SortOrder
  }

  export type whatsmeow_app_state_sync_keysSumOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type Whatsmeow_app_state_mutation_macsListRelationFilter = {
    every?: whatsmeow_app_state_mutation_macsWhereInput
    some?: whatsmeow_app_state_mutation_macsWhereInput
    none?: whatsmeow_app_state_mutation_macsWhereInput
  }

  export type whatsmeow_app_state_mutation_macsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_app_state_versionJidNameCompoundUniqueInput = {
    jid: string
    name: string
  }

  export type whatsmeow_app_state_versionCountOrderByAggregateInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
  }

  export type whatsmeow_app_state_versionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type whatsmeow_app_state_versionMaxOrderByAggregateInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
  }

  export type whatsmeow_app_state_versionMinOrderByAggregateInput = {
    jid?: SortOrder
    name?: SortOrder
    version?: SortOrder
    hash?: SortOrder
  }

  export type whatsmeow_app_state_versionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type whatsmeow_chat_settingsOur_jidChat_jidCompoundUniqueInput = {
    our_jid: string
    chat_jid: string
  }

  export type whatsmeow_chat_settingsCountOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    muted_until?: SortOrder
    pinned?: SortOrder
    archived?: SortOrder
  }

  export type whatsmeow_chat_settingsAvgOrderByAggregateInput = {
    muted_until?: SortOrder
  }

  export type whatsmeow_chat_settingsMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    muted_until?: SortOrder
    pinned?: SortOrder
    archived?: SortOrder
  }

  export type whatsmeow_chat_settingsMinOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    muted_until?: SortOrder
    pinned?: SortOrder
    archived?: SortOrder
  }

  export type whatsmeow_chat_settingsSumOrderByAggregateInput = {
    muted_until?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type whatsmeow_contactsOur_jidTheir_jidCompoundUniqueInput = {
    our_jid: string
    their_jid: string
  }

  export type whatsmeow_contactsCountOrderByAggregateInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    first_name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    business_name?: SortOrder
    redacted_phone?: SortOrder
  }

  export type whatsmeow_contactsMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    first_name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    business_name?: SortOrder
    redacted_phone?: SortOrder
  }

  export type whatsmeow_contactsMinOrderByAggregateInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    first_name?: SortOrder
    full_name?: SortOrder
    push_name?: SortOrder
    business_name?: SortOrder
    redacted_phone?: SortOrder
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type Whatsmeow_app_state_sync_keysListRelationFilter = {
    every?: whatsmeow_app_state_sync_keysWhereInput
    some?: whatsmeow_app_state_sync_keysWhereInput
    none?: whatsmeow_app_state_sync_keysWhereInput
  }

  export type Whatsmeow_app_state_versionListRelationFilter = {
    every?: whatsmeow_app_state_versionWhereInput
    some?: whatsmeow_app_state_versionWhereInput
    none?: whatsmeow_app_state_versionWhereInput
  }

  export type Whatsmeow_chat_settingsListRelationFilter = {
    every?: whatsmeow_chat_settingsWhereInput
    some?: whatsmeow_chat_settingsWhereInput
    none?: whatsmeow_chat_settingsWhereInput
  }

  export type Whatsmeow_contactsListRelationFilter = {
    every?: whatsmeow_contactsWhereInput
    some?: whatsmeow_contactsWhereInput
    none?: whatsmeow_contactsWhereInput
  }

  export type Whatsmeow_event_bufferListRelationFilter = {
    every?: whatsmeow_event_bufferWhereInput
    some?: whatsmeow_event_bufferWhereInput
    none?: whatsmeow_event_bufferWhereInput
  }

  export type Whatsmeow_identity_keysListRelationFilter = {
    every?: whatsmeow_identity_keysWhereInput
    some?: whatsmeow_identity_keysWhereInput
    none?: whatsmeow_identity_keysWhereInput
  }

  export type Whatsmeow_message_secretsListRelationFilter = {
    every?: whatsmeow_message_secretsWhereInput
    some?: whatsmeow_message_secretsWhereInput
    none?: whatsmeow_message_secretsWhereInput
  }

  export type Whatsmeow_pre_keysListRelationFilter = {
    every?: whatsmeow_pre_keysWhereInput
    some?: whatsmeow_pre_keysWhereInput
    none?: whatsmeow_pre_keysWhereInput
  }

  export type Whatsmeow_sender_keysListRelationFilter = {
    every?: whatsmeow_sender_keysWhereInput
    some?: whatsmeow_sender_keysWhereInput
    none?: whatsmeow_sender_keysWhereInput
  }

  export type Whatsmeow_sessionsListRelationFilter = {
    every?: whatsmeow_sessionsWhereInput
    some?: whatsmeow_sessionsWhereInput
    none?: whatsmeow_sessionsWhereInput
  }

  export type whatsmeow_app_state_sync_keysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_app_state_versionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_chat_settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_contactsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_event_bufferOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_identity_keysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_message_secretsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_pre_keysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_sender_keysOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_sessionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type whatsmeow_deviceCountOrderByAggregateInput = {
    jid?: SortOrder
    lid?: SortOrder
    facebook_uuid?: SortOrder
    registration_id?: SortOrder
    noise_key?: SortOrder
    identity_key?: SortOrder
    signed_pre_key?: SortOrder
    signed_pre_key_id?: SortOrder
    signed_pre_key_sig?: SortOrder
    adv_key?: SortOrder
    adv_details?: SortOrder
    adv_account_sig?: SortOrder
    adv_account_sig_key?: SortOrder
    adv_device_sig?: SortOrder
    platform?: SortOrder
    business_name?: SortOrder
    push_name?: SortOrder
    lid_migration_ts?: SortOrder
  }

  export type whatsmeow_deviceAvgOrderByAggregateInput = {
    registration_id?: SortOrder
    signed_pre_key_id?: SortOrder
    lid_migration_ts?: SortOrder
  }

  export type whatsmeow_deviceMaxOrderByAggregateInput = {
    jid?: SortOrder
    lid?: SortOrder
    facebook_uuid?: SortOrder
    registration_id?: SortOrder
    noise_key?: SortOrder
    identity_key?: SortOrder
    signed_pre_key?: SortOrder
    signed_pre_key_id?: SortOrder
    signed_pre_key_sig?: SortOrder
    adv_key?: SortOrder
    adv_details?: SortOrder
    adv_account_sig?: SortOrder
    adv_account_sig_key?: SortOrder
    adv_device_sig?: SortOrder
    platform?: SortOrder
    business_name?: SortOrder
    push_name?: SortOrder
    lid_migration_ts?: SortOrder
  }

  export type whatsmeow_deviceMinOrderByAggregateInput = {
    jid?: SortOrder
    lid?: SortOrder
    facebook_uuid?: SortOrder
    registration_id?: SortOrder
    noise_key?: SortOrder
    identity_key?: SortOrder
    signed_pre_key?: SortOrder
    signed_pre_key_id?: SortOrder
    signed_pre_key_sig?: SortOrder
    adv_key?: SortOrder
    adv_details?: SortOrder
    adv_account_sig?: SortOrder
    adv_account_sig_key?: SortOrder
    adv_device_sig?: SortOrder
    platform?: SortOrder
    business_name?: SortOrder
    push_name?: SortOrder
    lid_migration_ts?: SortOrder
  }

  export type whatsmeow_deviceSumOrderByAggregateInput = {
    registration_id?: SortOrder
    signed_pre_key_id?: SortOrder
    lid_migration_ts?: SortOrder
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type whatsmeow_event_bufferOur_jidCiphertext_hashCompoundUniqueInput = {
    our_jid: string
    ciphertext_hash: Uint8Array
  }

  export type whatsmeow_event_bufferCountOrderByAggregateInput = {
    our_jid?: SortOrder
    ciphertext_hash?: SortOrder
    plaintext?: SortOrder
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
  }

  export type whatsmeow_event_bufferAvgOrderByAggregateInput = {
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
  }

  export type whatsmeow_event_bufferMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    ciphertext_hash?: SortOrder
    plaintext?: SortOrder
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
  }

  export type whatsmeow_event_bufferMinOrderByAggregateInput = {
    our_jid?: SortOrder
    ciphertext_hash?: SortOrder
    plaintext?: SortOrder
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
  }

  export type whatsmeow_event_bufferSumOrderByAggregateInput = {
    server_timestamp?: SortOrder
    insert_timestamp?: SortOrder
  }

  export type whatsmeow_identity_keysOur_jidTheir_idCompoundUniqueInput = {
    our_jid: string
    their_id: string
  }

  export type whatsmeow_identity_keysCountOrderByAggregateInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    identity?: SortOrder
  }

  export type whatsmeow_identity_keysMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    identity?: SortOrder
  }

  export type whatsmeow_identity_keysMinOrderByAggregateInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    identity?: SortOrder
  }

  export type whatsmeow_lid_mapCountOrderByAggregateInput = {
    lid?: SortOrder
    pn?: SortOrder
  }

  export type whatsmeow_lid_mapMaxOrderByAggregateInput = {
    lid?: SortOrder
    pn?: SortOrder
  }

  export type whatsmeow_lid_mapMinOrderByAggregateInput = {
    lid?: SortOrder
    pn?: SortOrder
  }

  export type whatsmeow_message_secretsOur_jidChat_jidSender_jidMessage_idCompoundUniqueInput = {
    our_jid: string
    chat_jid: string
    sender_jid: string
    message_id: string
  }

  export type whatsmeow_message_secretsCountOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    key?: SortOrder
  }

  export type whatsmeow_message_secretsMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    key?: SortOrder
  }

  export type whatsmeow_message_secretsMinOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_jid?: SortOrder
    sender_jid?: SortOrder
    message_id?: SortOrder
    key?: SortOrder
  }

  export type whatsmeow_pre_keysJidKey_idCompoundUniqueInput = {
    jid: string
    key_id: number
  }

  export type whatsmeow_pre_keysCountOrderByAggregateInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key?: SortOrder
    uploaded?: SortOrder
  }

  export type whatsmeow_pre_keysAvgOrderByAggregateInput = {
    key_id?: SortOrder
  }

  export type whatsmeow_pre_keysMaxOrderByAggregateInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key?: SortOrder
    uploaded?: SortOrder
  }

  export type whatsmeow_pre_keysMinOrderByAggregateInput = {
    jid?: SortOrder
    key_id?: SortOrder
    key?: SortOrder
    uploaded?: SortOrder
  }

  export type whatsmeow_pre_keysSumOrderByAggregateInput = {
    key_id?: SortOrder
  }

  export type whatsmeow_privacy_tokensOur_jidTheir_jidCompoundUniqueInput = {
    our_jid: string
    their_jid: string
  }

  export type whatsmeow_privacy_tokensCountOrderByAggregateInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    token?: SortOrder
    timestamp?: SortOrder
  }

  export type whatsmeow_privacy_tokensAvgOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type whatsmeow_privacy_tokensMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    token?: SortOrder
    timestamp?: SortOrder
  }

  export type whatsmeow_privacy_tokensMinOrderByAggregateInput = {
    our_jid?: SortOrder
    their_jid?: SortOrder
    token?: SortOrder
    timestamp?: SortOrder
  }

  export type whatsmeow_privacy_tokensSumOrderByAggregateInput = {
    timestamp?: SortOrder
  }

  export type whatsmeow_sender_keysOur_jidChat_idSender_idCompoundUniqueInput = {
    our_jid: string
    chat_id: string
    sender_id: string
  }

  export type whatsmeow_sender_keysCountOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_id?: SortOrder
    sender_id?: SortOrder
    sender_key?: SortOrder
  }

  export type whatsmeow_sender_keysMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_id?: SortOrder
    sender_id?: SortOrder
    sender_key?: SortOrder
  }

  export type whatsmeow_sender_keysMinOrderByAggregateInput = {
    our_jid?: SortOrder
    chat_id?: SortOrder
    sender_id?: SortOrder
    sender_key?: SortOrder
  }

  export type whatsmeow_sessionsOur_jidTheir_idCompoundUniqueInput = {
    our_jid: string
    their_id: string
  }

  export type whatsmeow_sessionsCountOrderByAggregateInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    session?: SortOrder
  }

  export type whatsmeow_sessionsMaxOrderByAggregateInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    session?: SortOrder
  }

  export type whatsmeow_sessionsMinOrderByAggregateInput = {
    our_jid?: SortOrder
    their_id?: SortOrder
    session?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type chatsCreateNestedOneWithoutChat_status_detailsInput = {
    create?: XOR<chatsCreateWithoutChat_status_detailsInput, chatsUncheckedCreateWithoutChat_status_detailsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChat_status_detailsInput
    connect?: chatsWhereUniqueInput
  }

  export type chatsUpdateOneRequiredWithoutChat_status_detailsNestedInput = {
    create?: XOR<chatsCreateWithoutChat_status_detailsInput, chatsUncheckedCreateWithoutChat_status_detailsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChat_status_detailsInput
    upsert?: chatsUpsertWithoutChat_status_detailsInput
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutChat_status_detailsInput, chatsUpdateWithoutChat_status_detailsInput>, chatsUncheckedUpdateWithoutChat_status_detailsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type chatsCreateNestedOneWithoutChatparticipantsInput = {
    create?: XOR<chatsCreateWithoutChatparticipantsInput, chatsUncheckedCreateWithoutChatparticipantsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChatparticipantsInput
    connect?: chatsWhereUniqueInput
  }

  export type contactsCreateNestedOneWithoutChatparticipantsInput = {
    create?: XOR<contactsCreateWithoutChatparticipantsInput, contactsUncheckedCreateWithoutChatparticipantsInput>
    connectOrCreate?: contactsCreateOrConnectWithoutChatparticipantsInput
    connect?: contactsWhereUniqueInput
  }

  export type chatsUpdateOneRequiredWithoutChatparticipantsNestedInput = {
    create?: XOR<chatsCreateWithoutChatparticipantsInput, chatsUncheckedCreateWithoutChatparticipantsInput>
    connectOrCreate?: chatsCreateOrConnectWithoutChatparticipantsInput
    upsert?: chatsUpsertWithoutChatparticipantsInput
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutChatparticipantsInput, chatsUpdateWithoutChatparticipantsInput>, chatsUncheckedUpdateWithoutChatparticipantsInput>
  }

  export type contactsUpdateOneRequiredWithoutChatparticipantsNestedInput = {
    create?: XOR<contactsCreateWithoutChatparticipantsInput, contactsUncheckedCreateWithoutChatparticipantsInput>
    connectOrCreate?: contactsCreateOrConnectWithoutChatparticipantsInput
    upsert?: contactsUpsertWithoutChatparticipantsInput
    connect?: contactsWhereUniqueInput
    update?: XOR<XOR<contactsUpdateToOneWithWhereWithoutChatparticipantsInput, contactsUpdateWithoutChatparticipantsInput>, contactsUncheckedUpdateWithoutChatparticipantsInput>
  }

  export type chat_status_detailsCreateNestedManyWithoutChatsInput = {
    create?: XOR<chat_status_detailsCreateWithoutChatsInput, chat_status_detailsUncheckedCreateWithoutChatsInput> | chat_status_detailsCreateWithoutChatsInput[] | chat_status_detailsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chat_status_detailsCreateOrConnectWithoutChatsInput | chat_status_detailsCreateOrConnectWithoutChatsInput[]
    createMany?: chat_status_detailsCreateManyChatsInputEnvelope
    connect?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
  }

  export type chatparticipantsCreateNestedManyWithoutChatsInput = {
    create?: XOR<chatparticipantsCreateWithoutChatsInput, chatparticipantsUncheckedCreateWithoutChatsInput> | chatparticipantsCreateWithoutChatsInput[] | chatparticipantsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutChatsInput | chatparticipantsCreateOrConnectWithoutChatsInput[]
    createMany?: chatparticipantsCreateManyChatsInputEnvelope
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutChatsInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type chat_status_detailsUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<chat_status_detailsCreateWithoutChatsInput, chat_status_detailsUncheckedCreateWithoutChatsInput> | chat_status_detailsCreateWithoutChatsInput[] | chat_status_detailsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chat_status_detailsCreateOrConnectWithoutChatsInput | chat_status_detailsCreateOrConnectWithoutChatsInput[]
    createMany?: chat_status_detailsCreateManyChatsInputEnvelope
    connect?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
  }

  export type chatparticipantsUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<chatparticipantsCreateWithoutChatsInput, chatparticipantsUncheckedCreateWithoutChatsInput> | chatparticipantsCreateWithoutChatsInput[] | chatparticipantsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutChatsInput | chatparticipantsCreateOrConnectWithoutChatsInput[]
    createMany?: chatparticipantsCreateManyChatsInputEnvelope
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutChatsInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type chat_status_detailsUpdateManyWithoutChatsNestedInput = {
    create?: XOR<chat_status_detailsCreateWithoutChatsInput, chat_status_detailsUncheckedCreateWithoutChatsInput> | chat_status_detailsCreateWithoutChatsInput[] | chat_status_detailsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chat_status_detailsCreateOrConnectWithoutChatsInput | chat_status_detailsCreateOrConnectWithoutChatsInput[]
    upsert?: chat_status_detailsUpsertWithWhereUniqueWithoutChatsInput | chat_status_detailsUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: chat_status_detailsCreateManyChatsInputEnvelope
    set?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    disconnect?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    delete?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    connect?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    update?: chat_status_detailsUpdateWithWhereUniqueWithoutChatsInput | chat_status_detailsUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: chat_status_detailsUpdateManyWithWhereWithoutChatsInput | chat_status_detailsUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: chat_status_detailsScalarWhereInput | chat_status_detailsScalarWhereInput[]
  }

  export type chatparticipantsUpdateManyWithoutChatsNestedInput = {
    create?: XOR<chatparticipantsCreateWithoutChatsInput, chatparticipantsUncheckedCreateWithoutChatsInput> | chatparticipantsCreateWithoutChatsInput[] | chatparticipantsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutChatsInput | chatparticipantsCreateOrConnectWithoutChatsInput[]
    upsert?: chatparticipantsUpsertWithWhereUniqueWithoutChatsInput | chatparticipantsUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: chatparticipantsCreateManyChatsInputEnvelope
    set?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    disconnect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    delete?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    update?: chatparticipantsUpdateWithWhereUniqueWithoutChatsInput | chatparticipantsUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: chatparticipantsUpdateManyWithWhereWithoutChatsInput | chatparticipantsUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: chatparticipantsScalarWhereInput | chatparticipantsScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutChatsNestedInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutChatsInput | messagesUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutChatsInput | messagesUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutChatsInput | messagesUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type chat_status_detailsUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<chat_status_detailsCreateWithoutChatsInput, chat_status_detailsUncheckedCreateWithoutChatsInput> | chat_status_detailsCreateWithoutChatsInput[] | chat_status_detailsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chat_status_detailsCreateOrConnectWithoutChatsInput | chat_status_detailsCreateOrConnectWithoutChatsInput[]
    upsert?: chat_status_detailsUpsertWithWhereUniqueWithoutChatsInput | chat_status_detailsUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: chat_status_detailsCreateManyChatsInputEnvelope
    set?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    disconnect?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    delete?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    connect?: chat_status_detailsWhereUniqueInput | chat_status_detailsWhereUniqueInput[]
    update?: chat_status_detailsUpdateWithWhereUniqueWithoutChatsInput | chat_status_detailsUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: chat_status_detailsUpdateManyWithWhereWithoutChatsInput | chat_status_detailsUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: chat_status_detailsScalarWhereInput | chat_status_detailsScalarWhereInput[]
  }

  export type chatparticipantsUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<chatparticipantsCreateWithoutChatsInput, chatparticipantsUncheckedCreateWithoutChatsInput> | chatparticipantsCreateWithoutChatsInput[] | chatparticipantsUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutChatsInput | chatparticipantsCreateOrConnectWithoutChatsInput[]
    upsert?: chatparticipantsUpsertWithWhereUniqueWithoutChatsInput | chatparticipantsUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: chatparticipantsCreateManyChatsInputEnvelope
    set?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    disconnect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    delete?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    update?: chatparticipantsUpdateWithWhereUniqueWithoutChatsInput | chatparticipantsUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: chatparticipantsUpdateManyWithWhereWithoutChatsInput | chatparticipantsUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: chatparticipantsScalarWhereInput | chatparticipantsScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutChatsNestedInput = {
    create?: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput> | messagesCreateWithoutChatsInput[] | messagesUncheckedCreateWithoutChatsInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutChatsInput | messagesCreateOrConnectWithoutChatsInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutChatsInput | messagesUpsertWithWhereUniqueWithoutChatsInput[]
    createMany?: messagesCreateManyChatsInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutChatsInput | messagesUpdateWithWhereUniqueWithoutChatsInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutChatsInput | messagesUpdateManyWithWhereWithoutChatsInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type chatparticipantsCreateNestedManyWithoutContactsInput = {
    create?: XOR<chatparticipantsCreateWithoutContactsInput, chatparticipantsUncheckedCreateWithoutContactsInput> | chatparticipantsCreateWithoutContactsInput[] | chatparticipantsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutContactsInput | chatparticipantsCreateOrConnectWithoutContactsInput[]
    createMany?: chatparticipantsCreateManyContactsInputEnvelope
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
  }

  export type chatparticipantsUncheckedCreateNestedManyWithoutContactsInput = {
    create?: XOR<chatparticipantsCreateWithoutContactsInput, chatparticipantsUncheckedCreateWithoutContactsInput> | chatparticipantsCreateWithoutContactsInput[] | chatparticipantsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutContactsInput | chatparticipantsCreateOrConnectWithoutContactsInput[]
    createMany?: chatparticipantsCreateManyContactsInputEnvelope
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
  }

  export type chatparticipantsUpdateManyWithoutContactsNestedInput = {
    create?: XOR<chatparticipantsCreateWithoutContactsInput, chatparticipantsUncheckedCreateWithoutContactsInput> | chatparticipantsCreateWithoutContactsInput[] | chatparticipantsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutContactsInput | chatparticipantsCreateOrConnectWithoutContactsInput[]
    upsert?: chatparticipantsUpsertWithWhereUniqueWithoutContactsInput | chatparticipantsUpsertWithWhereUniqueWithoutContactsInput[]
    createMany?: chatparticipantsCreateManyContactsInputEnvelope
    set?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    disconnect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    delete?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    update?: chatparticipantsUpdateWithWhereUniqueWithoutContactsInput | chatparticipantsUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: chatparticipantsUpdateManyWithWhereWithoutContactsInput | chatparticipantsUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: chatparticipantsScalarWhereInput | chatparticipantsScalarWhereInput[]
  }

  export type chatparticipantsUncheckedUpdateManyWithoutContactsNestedInput = {
    create?: XOR<chatparticipantsCreateWithoutContactsInput, chatparticipantsUncheckedCreateWithoutContactsInput> | chatparticipantsCreateWithoutContactsInput[] | chatparticipantsUncheckedCreateWithoutContactsInput[]
    connectOrCreate?: chatparticipantsCreateOrConnectWithoutContactsInput | chatparticipantsCreateOrConnectWithoutContactsInput[]
    upsert?: chatparticipantsUpsertWithWhereUniqueWithoutContactsInput | chatparticipantsUpsertWithWhereUniqueWithoutContactsInput[]
    createMany?: chatparticipantsCreateManyContactsInputEnvelope
    set?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    disconnect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    delete?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    connect?: chatparticipantsWhereUniqueInput | chatparticipantsWhereUniqueInput[]
    update?: chatparticipantsUpdateWithWhereUniqueWithoutContactsInput | chatparticipantsUpdateWithWhereUniqueWithoutContactsInput[]
    updateMany?: chatparticipantsUpdateManyWithWhereWithoutContactsInput | chatparticipantsUpdateManyWithWhereWithoutContactsInput[]
    deleteMany?: chatparticipantsScalarWhereInput | chatparticipantsScalarWhereInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type messagesCreateNestedOneWithoutMessage_reactionsInput = {
    create?: XOR<messagesCreateWithoutMessage_reactionsInput, messagesUncheckedCreateWithoutMessage_reactionsInput>
    connectOrCreate?: messagesCreateOrConnectWithoutMessage_reactionsInput
    connect?: messagesWhereUniqueInput
  }

  export type messagesUpdateOneRequiredWithoutMessage_reactionsNestedInput = {
    create?: XOR<messagesCreateWithoutMessage_reactionsInput, messagesUncheckedCreateWithoutMessage_reactionsInput>
    connectOrCreate?: messagesCreateOrConnectWithoutMessage_reactionsInput
    upsert?: messagesUpsertWithoutMessage_reactionsInput
    connect?: messagesWhereUniqueInput
    update?: XOR<XOR<messagesUpdateToOneWithWhereWithoutMessage_reactionsInput, messagesUpdateWithoutMessage_reactionsInput>, messagesUncheckedUpdateWithoutMessage_reactionsInput>
  }

  export type message_reactionsCreateNestedManyWithoutMessagesInput = {
    create?: XOR<message_reactionsCreateWithoutMessagesInput, message_reactionsUncheckedCreateWithoutMessagesInput> | message_reactionsCreateWithoutMessagesInput[] | message_reactionsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: message_reactionsCreateOrConnectWithoutMessagesInput | message_reactionsCreateOrConnectWithoutMessagesInput[]
    createMany?: message_reactionsCreateManyMessagesInputEnvelope
    connect?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
  }

  export type chatsCreateNestedOneWithoutMessagesInput = {
    create?: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: chatsCreateOrConnectWithoutMessagesInput
    connect?: chatsWhereUniqueInput
  }

  export type message_reactionsUncheckedCreateNestedManyWithoutMessagesInput = {
    create?: XOR<message_reactionsCreateWithoutMessagesInput, message_reactionsUncheckedCreateWithoutMessagesInput> | message_reactionsCreateWithoutMessagesInput[] | message_reactionsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: message_reactionsCreateOrConnectWithoutMessagesInput | message_reactionsCreateOrConnectWithoutMessagesInput[]
    createMany?: message_reactionsCreateManyMessagesInputEnvelope
    connect?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
  }

  export type message_reactionsUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<message_reactionsCreateWithoutMessagesInput, message_reactionsUncheckedCreateWithoutMessagesInput> | message_reactionsCreateWithoutMessagesInput[] | message_reactionsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: message_reactionsCreateOrConnectWithoutMessagesInput | message_reactionsCreateOrConnectWithoutMessagesInput[]
    upsert?: message_reactionsUpsertWithWhereUniqueWithoutMessagesInput | message_reactionsUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: message_reactionsCreateManyMessagesInputEnvelope
    set?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    disconnect?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    delete?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    connect?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    update?: message_reactionsUpdateWithWhereUniqueWithoutMessagesInput | message_reactionsUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: message_reactionsUpdateManyWithWhereWithoutMessagesInput | message_reactionsUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: message_reactionsScalarWhereInput | message_reactionsScalarWhereInput[]
  }

  export type chatsUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: chatsCreateOrConnectWithoutMessagesInput
    upsert?: chatsUpsertWithoutMessagesInput
    disconnect?: chatsWhereInput | boolean
    delete?: chatsWhereInput | boolean
    connect?: chatsWhereUniqueInput
    update?: XOR<XOR<chatsUpdateToOneWithWhereWithoutMessagesInput, chatsUpdateWithoutMessagesInput>, chatsUncheckedUpdateWithoutMessagesInput>
  }

  export type message_reactionsUncheckedUpdateManyWithoutMessagesNestedInput = {
    create?: XOR<message_reactionsCreateWithoutMessagesInput, message_reactionsUncheckedCreateWithoutMessagesInput> | message_reactionsCreateWithoutMessagesInput[] | message_reactionsUncheckedCreateWithoutMessagesInput[]
    connectOrCreate?: message_reactionsCreateOrConnectWithoutMessagesInput | message_reactionsCreateOrConnectWithoutMessagesInput[]
    upsert?: message_reactionsUpsertWithWhereUniqueWithoutMessagesInput | message_reactionsUpsertWithWhereUniqueWithoutMessagesInput[]
    createMany?: message_reactionsCreateManyMessagesInputEnvelope
    set?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    disconnect?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    delete?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    connect?: message_reactionsWhereUniqueInput | message_reactionsWhereUniqueInput[]
    update?: message_reactionsUpdateWithWhereUniqueWithoutMessagesInput | message_reactionsUpdateWithWhereUniqueWithoutMessagesInput[]
    updateMany?: message_reactionsUpdateManyWithWhereWithoutMessagesInput | message_reactionsUpdateManyWithWhereWithoutMessagesInput[]
    deleteMany?: message_reactionsScalarWhereInput | message_reactionsScalarWhereInput[]
  }

  export type NullableBytesFieldUpdateOperationsInput = {
    set?: Uint8Array | null
  }

  export type whatsmeow_app_state_versionCreateNestedOneWithoutWhatsmeow_app_state_mutation_macsInput = {
    create?: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_app_state_mutation_macsInput>
    connectOrCreate?: whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_app_state_mutation_macsInput
    connect?: whatsmeow_app_state_versionWhereUniqueInput
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Uint8Array
  }

  export type whatsmeow_app_state_versionUpdateOneRequiredWithoutWhatsmeow_app_state_mutation_macsNestedInput = {
    create?: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_app_state_mutation_macsInput>
    connectOrCreate?: whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_app_state_mutation_macsInput
    upsert?: whatsmeow_app_state_versionUpsertWithoutWhatsmeow_app_state_mutation_macsInput
    connect?: whatsmeow_app_state_versionWhereUniqueInput
    update?: XOR<XOR<whatsmeow_app_state_versionUpdateToOneWithWhereWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUpdateWithoutWhatsmeow_app_state_mutation_macsInput>, whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_app_state_mutation_macsInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_app_state_sync_keysInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_sync_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_app_state_sync_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_app_state_sync_keysNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_sync_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_app_state_sync_keysInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_app_state_sync_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_sync_keysInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_sync_keysInput>
  }

  export type whatsmeow_app_state_mutation_macsCreateNestedManyWithoutWhatsmeow_app_state_versionInput = {
    create?: XOR<whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput> | whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput[] | whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput[]
    connectOrCreate?: whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput[]
    createMany?: whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInputEnvelope
    connect?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_app_state_versionInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_versionInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_app_state_versionInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_app_state_mutation_macsUncheckedCreateNestedManyWithoutWhatsmeow_app_state_versionInput = {
    create?: XOR<whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput> | whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput[] | whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput[]
    connectOrCreate?: whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput[]
    createMany?: whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInputEnvelope
    connect?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
  }

  export type whatsmeow_app_state_mutation_macsUpdateManyWithoutWhatsmeow_app_state_versionNestedInput = {
    create?: XOR<whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput> | whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput[] | whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput[]
    connectOrCreate?: whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput[]
    upsert?: whatsmeow_app_state_mutation_macsUpsertWithWhereUniqueWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsUpsertWithWhereUniqueWithoutWhatsmeow_app_state_versionInput[]
    createMany?: whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInputEnvelope
    set?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    disconnect?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    delete?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    connect?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    update?: whatsmeow_app_state_mutation_macsUpdateWithWhereUniqueWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsUpdateWithWhereUniqueWithoutWhatsmeow_app_state_versionInput[]
    updateMany?: whatsmeow_app_state_mutation_macsUpdateManyWithWhereWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsUpdateManyWithWhereWithoutWhatsmeow_app_state_versionInput[]
    deleteMany?: whatsmeow_app_state_mutation_macsScalarWhereInput | whatsmeow_app_state_mutation_macsScalarWhereInput[]
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_app_state_versionNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_versionInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_app_state_versionInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_app_state_versionInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_versionInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_app_state_mutation_macsUncheckedUpdateManyWithoutWhatsmeow_app_state_versionNestedInput = {
    create?: XOR<whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput> | whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput[] | whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput[]
    connectOrCreate?: whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput[]
    upsert?: whatsmeow_app_state_mutation_macsUpsertWithWhereUniqueWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsUpsertWithWhereUniqueWithoutWhatsmeow_app_state_versionInput[]
    createMany?: whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInputEnvelope
    set?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    disconnect?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    delete?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    connect?: whatsmeow_app_state_mutation_macsWhereUniqueInput | whatsmeow_app_state_mutation_macsWhereUniqueInput[]
    update?: whatsmeow_app_state_mutation_macsUpdateWithWhereUniqueWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsUpdateWithWhereUniqueWithoutWhatsmeow_app_state_versionInput[]
    updateMany?: whatsmeow_app_state_mutation_macsUpdateManyWithWhereWithoutWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsUpdateManyWithWhereWithoutWhatsmeow_app_state_versionInput[]
    deleteMany?: whatsmeow_app_state_mutation_macsScalarWhereInput | whatsmeow_app_state_mutation_macsScalarWhereInput[]
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_chat_settingsInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_chat_settingsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_chat_settingsInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_chat_settingsNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_chat_settingsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_chat_settingsInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_chat_settingsInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUpdateWithoutWhatsmeow_chat_settingsInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_chat_settingsInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_contactsInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_contactsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_contactsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_contactsInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_contactsNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_contactsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_contactsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_contactsInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_contactsInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_contactsInput, whatsmeow_deviceUpdateWithoutWhatsmeow_contactsInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_contactsInput>
  }

  export type whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
  }

  export type whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
  }

  export type whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
  }

  export type whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_contactsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
  }

  export type whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_event_bufferCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
  }

  export type whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_identity_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
  }

  export type whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_message_secretsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
  }

  export type whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_pre_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
  }

  export type whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sender_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
  }

  export type whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sessionsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
  }

  export type whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
  }

  export type whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
  }

  export type whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
  }

  export type whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_contactsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
  }

  export type whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_event_bufferCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
  }

  export type whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_identity_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
  }

  export type whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_message_secretsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
  }

  export type whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_pre_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
  }

  export type whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sender_keysCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
  }

  export type whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput = {
    create?: XOR<whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sessionsCreateManyWhatsmeow_deviceInputEnvelope
    connect?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
  }

  export type whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_app_state_sync_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    disconnect?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    delete?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    connect?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    update?: whatsmeow_app_state_sync_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_app_state_sync_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_app_state_sync_keysScalarWhereInput | whatsmeow_app_state_sync_keysScalarWhereInput[]
  }

  export type whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_app_state_versionUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    disconnect?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    delete?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    connect?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    update?: whatsmeow_app_state_versionUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_app_state_versionUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_app_state_versionScalarWhereInput | whatsmeow_app_state_versionScalarWhereInput[]
  }

  export type whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_chat_settingsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    disconnect?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    delete?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    connect?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    update?: whatsmeow_chat_settingsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_chat_settingsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_chat_settingsScalarWhereInput | whatsmeow_chat_settingsScalarWhereInput[]
  }

  export type whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_contactsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_contactsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_contactsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    disconnect?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    delete?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    connect?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    update?: whatsmeow_contactsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_contactsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_contactsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_contactsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_contactsScalarWhereInput | whatsmeow_contactsScalarWhereInput[]
  }

  export type whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_event_bufferUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_event_bufferCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    disconnect?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    delete?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    connect?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    update?: whatsmeow_event_bufferUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_event_bufferUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_event_bufferScalarWhereInput | whatsmeow_event_bufferScalarWhereInput[]
  }

  export type whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_identity_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_identity_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    disconnect?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    delete?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    connect?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    update?: whatsmeow_identity_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_identity_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_identity_keysScalarWhereInput | whatsmeow_identity_keysScalarWhereInput[]
  }

  export type whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_message_secretsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_message_secretsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    disconnect?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    delete?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    connect?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    update?: whatsmeow_message_secretsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_message_secretsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_message_secretsScalarWhereInput | whatsmeow_message_secretsScalarWhereInput[]
  }

  export type whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_pre_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_pre_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    disconnect?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    delete?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    connect?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    update?: whatsmeow_pre_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_pre_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_pre_keysScalarWhereInput | whatsmeow_pre_keysScalarWhereInput[]
  }

  export type whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_sender_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sender_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    disconnect?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    delete?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    connect?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    update?: whatsmeow_sender_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_sender_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_sender_keysScalarWhereInput | whatsmeow_sender_keysScalarWhereInput[]
  }

  export type whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_sessionsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sessionsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sessionsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    disconnect?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    delete?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    connect?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    update?: whatsmeow_sessionsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sessionsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_sessionsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_sessionsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_sessionsScalarWhereInput | whatsmeow_sessionsScalarWhereInput[]
  }

  export type whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_app_state_sync_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    disconnect?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    delete?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    connect?: whatsmeow_app_state_sync_keysWhereUniqueInput | whatsmeow_app_state_sync_keysWhereUniqueInput[]
    update?: whatsmeow_app_state_sync_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_app_state_sync_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_app_state_sync_keysScalarWhereInput | whatsmeow_app_state_sync_keysScalarWhereInput[]
  }

  export type whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_app_state_versionUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    disconnect?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    delete?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    connect?: whatsmeow_app_state_versionWhereUniqueInput | whatsmeow_app_state_versionWhereUniqueInput[]
    update?: whatsmeow_app_state_versionUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_app_state_versionUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_app_state_versionUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_app_state_versionScalarWhereInput | whatsmeow_app_state_versionScalarWhereInput[]
  }

  export type whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_chat_settingsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    disconnect?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    delete?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    connect?: whatsmeow_chat_settingsWhereUniqueInput | whatsmeow_chat_settingsWhereUniqueInput[]
    update?: whatsmeow_chat_settingsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_chat_settingsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_chat_settingsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_chat_settingsScalarWhereInput | whatsmeow_chat_settingsScalarWhereInput[]
  }

  export type whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_contactsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_contactsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_contactsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    disconnect?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    delete?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    connect?: whatsmeow_contactsWhereUniqueInput | whatsmeow_contactsWhereUniqueInput[]
    update?: whatsmeow_contactsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_contactsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_contactsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_contactsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_contactsScalarWhereInput | whatsmeow_contactsScalarWhereInput[]
  }

  export type whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_event_bufferUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_event_bufferCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    disconnect?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    delete?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    connect?: whatsmeow_event_bufferWhereUniqueInput | whatsmeow_event_bufferWhereUniqueInput[]
    update?: whatsmeow_event_bufferUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_event_bufferUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_event_bufferUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_event_bufferScalarWhereInput | whatsmeow_event_bufferScalarWhereInput[]
  }

  export type whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_identity_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_identity_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    disconnect?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    delete?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    connect?: whatsmeow_identity_keysWhereUniqueInput | whatsmeow_identity_keysWhereUniqueInput[]
    update?: whatsmeow_identity_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_identity_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_identity_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_identity_keysScalarWhereInput | whatsmeow_identity_keysScalarWhereInput[]
  }

  export type whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_message_secretsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_message_secretsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    disconnect?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    delete?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    connect?: whatsmeow_message_secretsWhereUniqueInput | whatsmeow_message_secretsWhereUniqueInput[]
    update?: whatsmeow_message_secretsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_message_secretsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_message_secretsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_message_secretsScalarWhereInput | whatsmeow_message_secretsScalarWhereInput[]
  }

  export type whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_pre_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_pre_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    disconnect?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    delete?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    connect?: whatsmeow_pre_keysWhereUniqueInput | whatsmeow_pre_keysWhereUniqueInput[]
    update?: whatsmeow_pre_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_pre_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_pre_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_pre_keysScalarWhereInput | whatsmeow_pre_keysScalarWhereInput[]
  }

  export type whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_sender_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sender_keysCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    disconnect?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    delete?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    connect?: whatsmeow_sender_keysWhereUniqueInput | whatsmeow_sender_keysWhereUniqueInput[]
    update?: whatsmeow_sender_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_sender_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_sender_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_sender_keysScalarWhereInput | whatsmeow_sender_keysScalarWhereInput[]
  }

  export type whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput = {
    create?: XOR<whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput> | whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput[] | whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput[]
    connectOrCreate?: whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput | whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput[]
    upsert?: whatsmeow_sessionsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sessionsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    createMany?: whatsmeow_sessionsCreateManyWhatsmeow_deviceInputEnvelope
    set?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    disconnect?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    delete?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    connect?: whatsmeow_sessionsWhereUniqueInput | whatsmeow_sessionsWhereUniqueInput[]
    update?: whatsmeow_sessionsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput | whatsmeow_sessionsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput[]
    updateMany?: whatsmeow_sessionsUpdateManyWithWhereWithoutWhatsmeow_deviceInput | whatsmeow_sessionsUpdateManyWithWhereWithoutWhatsmeow_deviceInput[]
    deleteMany?: whatsmeow_sessionsScalarWhereInput | whatsmeow_sessionsScalarWhereInput[]
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_event_bufferInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_event_bufferInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_event_bufferInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_event_bufferNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_event_bufferInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_event_bufferInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_event_bufferInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUpdateWithoutWhatsmeow_event_bufferInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_event_bufferInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_identity_keysInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_identity_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_identity_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_identity_keysNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_identity_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_identity_keysInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_identity_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUpdateWithoutWhatsmeow_identity_keysInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_identity_keysInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_message_secretsInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_message_secretsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_message_secretsInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_message_secretsNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_message_secretsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_message_secretsInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_message_secretsInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUpdateWithoutWhatsmeow_message_secretsInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_message_secretsInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_pre_keysInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_pre_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_pre_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_pre_keysNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_pre_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_pre_keysInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_pre_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUpdateWithoutWhatsmeow_pre_keysInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_pre_keysInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_sender_keysInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sender_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_sender_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_sender_keysNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sender_keysInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_sender_keysInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_sender_keysInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUpdateWithoutWhatsmeow_sender_keysInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sender_keysInput>
  }

  export type whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_sessionsInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sessionsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_sessionsInput
    connect?: whatsmeow_deviceWhereUniqueInput
  }

  export type whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_sessionsNestedInput = {
    create?: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sessionsInput>
    connectOrCreate?: whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_sessionsInput
    upsert?: whatsmeow_deviceUpsertWithoutWhatsmeow_sessionsInput
    connect?: whatsmeow_deviceWhereUniqueInput
    update?: XOR<XOR<whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUpdateWithoutWhatsmeow_sessionsInput>, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sessionsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBytesNullableFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableFilter<$PrismaModel> | Uint8Array | null
  }

  export type NestedBytesNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel> | null
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel> | null
    not?: NestedBytesNullableWithAggregatesFilter<$PrismaModel> | Uint8Array | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBytesNullableFilter<$PrismaModel>
    _max?: NestedBytesNullableFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Uint8Array
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Uint8Array | BytesFieldRefInput<$PrismaModel>
    in?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Uint8Array[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Uint8Array
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type chatsCreateWithoutChat_status_detailsInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chatparticipants?: chatparticipantsCreateNestedManyWithoutChatsInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutChat_status_detailsInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chatparticipants?: chatparticipantsUncheckedCreateNestedManyWithoutChatsInput
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutChat_status_detailsInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutChat_status_detailsInput, chatsUncheckedCreateWithoutChat_status_detailsInput>
  }

  export type chatsUpsertWithoutChat_status_detailsInput = {
    update: XOR<chatsUpdateWithoutChat_status_detailsInput, chatsUncheckedUpdateWithoutChat_status_detailsInput>
    create: XOR<chatsCreateWithoutChat_status_detailsInput, chatsUncheckedCreateWithoutChat_status_detailsInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutChat_status_detailsInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutChat_status_detailsInput, chatsUncheckedUpdateWithoutChat_status_detailsInput>
  }

  export type chatsUpdateWithoutChat_status_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chatparticipants?: chatparticipantsUpdateManyWithoutChatsNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutChat_status_detailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chatparticipants?: chatparticipantsUncheckedUpdateManyWithoutChatsNestedInput
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type chatsCreateWithoutChatparticipantsInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chat_status_details?: chat_status_detailsCreateNestedManyWithoutChatsInput
    messages?: messagesCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutChatparticipantsInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chat_status_details?: chat_status_detailsUncheckedCreateNestedManyWithoutChatsInput
    messages?: messagesUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutChatparticipantsInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutChatparticipantsInput, chatsUncheckedCreateWithoutChatparticipantsInput>
  }

  export type contactsCreateWithoutChatparticipantsInput = {
    id: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isTyping?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    lastSeen?: Date | string | null
    chatId?: string | null
    contactId?: string | null
    userId?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type contactsUncheckedCreateWithoutChatparticipantsInput = {
    id: string
    name: string
    phone?: string | null
    email?: string | null
    address?: string | null
    city?: string | null
    state?: string | null
    zip?: string | null
    country?: string | null
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isTyping?: boolean | null
    isOnline?: boolean | null
    image?: string | null
    lastSeen?: Date | string | null
    chatId?: string | null
    contactId?: string | null
    userId?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type contactsCreateOrConnectWithoutChatparticipantsInput = {
    where: contactsWhereUniqueInput
    create: XOR<contactsCreateWithoutChatparticipantsInput, contactsUncheckedCreateWithoutChatparticipantsInput>
  }

  export type chatsUpsertWithoutChatparticipantsInput = {
    update: XOR<chatsUpdateWithoutChatparticipantsInput, chatsUncheckedUpdateWithoutChatparticipantsInput>
    create: XOR<chatsCreateWithoutChatparticipantsInput, chatsUncheckedCreateWithoutChatparticipantsInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutChatparticipantsInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutChatparticipantsInput, chatsUncheckedUpdateWithoutChatparticipantsInput>
  }

  export type chatsUpdateWithoutChatparticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_status_details?: chat_status_detailsUpdateManyWithoutChatsNestedInput
    messages?: messagesUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutChatparticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_status_details?: chat_status_detailsUncheckedUpdateManyWithoutChatsNestedInput
    messages?: messagesUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type contactsUpsertWithoutChatparticipantsInput = {
    update: XOR<contactsUpdateWithoutChatparticipantsInput, contactsUncheckedUpdateWithoutChatparticipantsInput>
    create: XOR<contactsCreateWithoutChatparticipantsInput, contactsUncheckedCreateWithoutChatparticipantsInput>
    where?: contactsWhereInput
  }

  export type contactsUpdateToOneWithWhereWithoutChatparticipantsInput = {
    where?: contactsWhereInput
    data: XOR<contactsUpdateWithoutChatparticipantsInput, contactsUncheckedUpdateWithoutChatparticipantsInput>
  }

  export type contactsUpdateWithoutChatparticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isTyping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type contactsUncheckedUpdateWithoutChatparticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    zip?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isTyping?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type chat_status_detailsCreateWithoutChatsInput = {
    status: string
    changed_by?: string | null
    changed_at?: Date | string | null
    reason?: string | null
    notes?: string | null
  }

  export type chat_status_detailsUncheckedCreateWithoutChatsInput = {
    id?: number
    status: string
    changed_by?: string | null
    changed_at?: Date | string | null
    reason?: string | null
    notes?: string | null
  }

  export type chat_status_detailsCreateOrConnectWithoutChatsInput = {
    where: chat_status_detailsWhereUniqueInput
    create: XOR<chat_status_detailsCreateWithoutChatsInput, chat_status_detailsUncheckedCreateWithoutChatsInput>
  }

  export type chat_status_detailsCreateManyChatsInputEnvelope = {
    data: chat_status_detailsCreateManyChatsInput | chat_status_detailsCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type chatparticipantsCreateWithoutChatsInput = {
    contacts: contactsCreateNestedOneWithoutChatparticipantsInput
  }

  export type chatparticipantsUncheckedCreateWithoutChatsInput = {
    contactid: string
  }

  export type chatparticipantsCreateOrConnectWithoutChatsInput = {
    where: chatparticipantsWhereUniqueInput
    create: XOR<chatparticipantsCreateWithoutChatsInput, chatparticipantsUncheckedCreateWithoutChatsInput>
  }

  export type chatparticipantsCreateManyChatsInputEnvelope = {
    data: chatparticipantsCreateManyChatsInput | chatparticipantsCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutChatsInput = {
    id: string
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
    message_reactions?: message_reactionsCreateNestedManyWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutChatsInput = {
    id: string
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
    message_reactions?: message_reactionsUncheckedCreateNestedManyWithoutMessagesInput
  }

  export type messagesCreateOrConnectWithoutChatsInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput>
  }

  export type messagesCreateManyChatsInputEnvelope = {
    data: messagesCreateManyChatsInput | messagesCreateManyChatsInput[]
    skipDuplicates?: boolean
  }

  export type chat_status_detailsUpsertWithWhereUniqueWithoutChatsInput = {
    where: chat_status_detailsWhereUniqueInput
    update: XOR<chat_status_detailsUpdateWithoutChatsInput, chat_status_detailsUncheckedUpdateWithoutChatsInput>
    create: XOR<chat_status_detailsCreateWithoutChatsInput, chat_status_detailsUncheckedCreateWithoutChatsInput>
  }

  export type chat_status_detailsUpdateWithWhereUniqueWithoutChatsInput = {
    where: chat_status_detailsWhereUniqueInput
    data: XOR<chat_status_detailsUpdateWithoutChatsInput, chat_status_detailsUncheckedUpdateWithoutChatsInput>
  }

  export type chat_status_detailsUpdateManyWithWhereWithoutChatsInput = {
    where: chat_status_detailsScalarWhereInput
    data: XOR<chat_status_detailsUpdateManyMutationInput, chat_status_detailsUncheckedUpdateManyWithoutChatsInput>
  }

  export type chat_status_detailsScalarWhereInput = {
    AND?: chat_status_detailsScalarWhereInput | chat_status_detailsScalarWhereInput[]
    OR?: chat_status_detailsScalarWhereInput[]
    NOT?: chat_status_detailsScalarWhereInput | chat_status_detailsScalarWhereInput[]
    id?: IntFilter<"chat_status_details"> | number
    chat_id?: StringFilter<"chat_status_details"> | string
    status?: StringFilter<"chat_status_details"> | string
    changed_by?: StringNullableFilter<"chat_status_details"> | string | null
    changed_at?: DateTimeNullableFilter<"chat_status_details"> | Date | string | null
    reason?: StringNullableFilter<"chat_status_details"> | string | null
    notes?: StringNullableFilter<"chat_status_details"> | string | null
  }

  export type chatparticipantsUpsertWithWhereUniqueWithoutChatsInput = {
    where: chatparticipantsWhereUniqueInput
    update: XOR<chatparticipantsUpdateWithoutChatsInput, chatparticipantsUncheckedUpdateWithoutChatsInput>
    create: XOR<chatparticipantsCreateWithoutChatsInput, chatparticipantsUncheckedCreateWithoutChatsInput>
  }

  export type chatparticipantsUpdateWithWhereUniqueWithoutChatsInput = {
    where: chatparticipantsWhereUniqueInput
    data: XOR<chatparticipantsUpdateWithoutChatsInput, chatparticipantsUncheckedUpdateWithoutChatsInput>
  }

  export type chatparticipantsUpdateManyWithWhereWithoutChatsInput = {
    where: chatparticipantsScalarWhereInput
    data: XOR<chatparticipantsUpdateManyMutationInput, chatparticipantsUncheckedUpdateManyWithoutChatsInput>
  }

  export type chatparticipantsScalarWhereInput = {
    AND?: chatparticipantsScalarWhereInput | chatparticipantsScalarWhereInput[]
    OR?: chatparticipantsScalarWhereInput[]
    NOT?: chatparticipantsScalarWhereInput | chatparticipantsScalarWhereInput[]
    chatid?: StringFilter<"chatparticipants"> | string
    contactid?: StringFilter<"chatparticipants"> | string
  }

  export type messagesUpsertWithWhereUniqueWithoutChatsInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutChatsInput, messagesUncheckedUpdateWithoutChatsInput>
    create: XOR<messagesCreateWithoutChatsInput, messagesUncheckedCreateWithoutChatsInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutChatsInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutChatsInput, messagesUncheckedUpdateWithoutChatsInput>
  }

  export type messagesUpdateManyWithWhereWithoutChatsInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutChatsInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    id?: StringFilter<"messages"> | string
    chatId?: StringNullableFilter<"messages"> | string | null
    message?: StringFilter<"messages"> | string
    timeStamp?: DateTimeNullableFilter<"messages"> | Date | string | null
    isDelivered?: BoolNullableFilter<"messages"> | boolean | null
    isRead?: BoolNullableFilter<"messages"> | boolean | null
    messageType?: StringNullableFilter<"messages"> | string | null
    isFromMe?: BoolNullableFilter<"messages"> | boolean | null
    contactId?: StringNullableFilter<"messages"> | string | null
    isEdit?: BoolNullableFilter<"messages"> | boolean | null
    pushname?: StringNullableFilter<"messages"> | string | null
    mediaPath?: StringNullableFilter<"messages"> | string | null
    note?: StringNullableFilter<"messages"> | string | null
    isPinned?: BoolNullableFilter<"messages"> | boolean | null
    userId?: StringNullableFilter<"messages"> | string | null
    replyToMessageId?: StringNullableFilter<"messages"> | string | null
  }

  export type chatparticipantsCreateWithoutContactsInput = {
    chats: chatsCreateNestedOneWithoutChatparticipantsInput
  }

  export type chatparticipantsUncheckedCreateWithoutContactsInput = {
    chatid: string
  }

  export type chatparticipantsCreateOrConnectWithoutContactsInput = {
    where: chatparticipantsWhereUniqueInput
    create: XOR<chatparticipantsCreateWithoutContactsInput, chatparticipantsUncheckedCreateWithoutContactsInput>
  }

  export type chatparticipantsCreateManyContactsInputEnvelope = {
    data: chatparticipantsCreateManyContactsInput | chatparticipantsCreateManyContactsInput[]
    skipDuplicates?: boolean
  }

  export type chatparticipantsUpsertWithWhereUniqueWithoutContactsInput = {
    where: chatparticipantsWhereUniqueInput
    update: XOR<chatparticipantsUpdateWithoutContactsInput, chatparticipantsUncheckedUpdateWithoutContactsInput>
    create: XOR<chatparticipantsCreateWithoutContactsInput, chatparticipantsUncheckedCreateWithoutContactsInput>
  }

  export type chatparticipantsUpdateWithWhereUniqueWithoutContactsInput = {
    where: chatparticipantsWhereUniqueInput
    data: XOR<chatparticipantsUpdateWithoutContactsInput, chatparticipantsUncheckedUpdateWithoutContactsInput>
  }

  export type chatparticipantsUpdateManyWithWhereWithoutContactsInput = {
    where: chatparticipantsScalarWhereInput
    data: XOR<chatparticipantsUpdateManyMutationInput, chatparticipantsUncheckedUpdateManyWithoutContactsInput>
  }

  export type messagesCreateWithoutMessage_reactionsInput = {
    id: string
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
    chats?: chatsCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateWithoutMessage_reactionsInput = {
    id: string
    chatId?: string | null
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
  }

  export type messagesCreateOrConnectWithoutMessage_reactionsInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutMessage_reactionsInput, messagesUncheckedCreateWithoutMessage_reactionsInput>
  }

  export type messagesUpsertWithoutMessage_reactionsInput = {
    update: XOR<messagesUpdateWithoutMessage_reactionsInput, messagesUncheckedUpdateWithoutMessage_reactionsInput>
    create: XOR<messagesCreateWithoutMessage_reactionsInput, messagesUncheckedCreateWithoutMessage_reactionsInput>
    where?: messagesWhereInput
  }

  export type messagesUpdateToOneWithWhereWithoutMessage_reactionsInput = {
    where?: messagesWhereInput
    data: XOR<messagesUpdateWithoutMessage_reactionsInput, messagesUncheckedUpdateWithoutMessage_reactionsInput>
  }

  export type messagesUpdateWithoutMessage_reactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    chats?: chatsUpdateOneWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutMessage_reactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    chatId?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type message_reactionsCreateWithoutMessagesInput = {
    participant?: string | null
    emoji: string
    createdAt?: Date | string | null
    userId?: string | null
    id: string
  }

  export type message_reactionsUncheckedCreateWithoutMessagesInput = {
    participant?: string | null
    emoji: string
    createdAt?: Date | string | null
    userId?: string | null
    id: string
  }

  export type message_reactionsCreateOrConnectWithoutMessagesInput = {
    where: message_reactionsWhereUniqueInput
    create: XOR<message_reactionsCreateWithoutMessagesInput, message_reactionsUncheckedCreateWithoutMessagesInput>
  }

  export type message_reactionsCreateManyMessagesInputEnvelope = {
    data: message_reactionsCreateManyMessagesInput | message_reactionsCreateManyMessagesInput[]
    skipDuplicates?: boolean
  }

  export type chatsCreateWithoutMessagesInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chat_status_details?: chat_status_detailsCreateNestedManyWithoutChatsInput
    chatparticipants?: chatparticipantsCreateNestedManyWithoutChatsInput
  }

  export type chatsUncheckedCreateWithoutMessagesInput = {
    id: string
    lastMessage?: string | null
    lastMessageTime?: Date | string | null
    unReadCount?: number | null
    isOnline?: boolean | null
    contactId?: string | null
    isTyping?: string | null
    userId?: string | null
    pushname?: string | null
    assignedTo?: string | null
    isarchived?: boolean | null
    ismuted?: boolean | null
    status?: string | null
    closedAt?: Date | string | null
    closeReason?: string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: string | null
    isPinned?: boolean | null
    chat_status_details?: chat_status_detailsUncheckedCreateNestedManyWithoutChatsInput
    chatparticipants?: chatparticipantsUncheckedCreateNestedManyWithoutChatsInput
  }

  export type chatsCreateOrConnectWithoutMessagesInput = {
    where: chatsWhereUniqueInput
    create: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
  }

  export type message_reactionsUpsertWithWhereUniqueWithoutMessagesInput = {
    where: message_reactionsWhereUniqueInput
    update: XOR<message_reactionsUpdateWithoutMessagesInput, message_reactionsUncheckedUpdateWithoutMessagesInput>
    create: XOR<message_reactionsCreateWithoutMessagesInput, message_reactionsUncheckedCreateWithoutMessagesInput>
  }

  export type message_reactionsUpdateWithWhereUniqueWithoutMessagesInput = {
    where: message_reactionsWhereUniqueInput
    data: XOR<message_reactionsUpdateWithoutMessagesInput, message_reactionsUncheckedUpdateWithoutMessagesInput>
  }

  export type message_reactionsUpdateManyWithWhereWithoutMessagesInput = {
    where: message_reactionsScalarWhereInput
    data: XOR<message_reactionsUpdateManyMutationInput, message_reactionsUncheckedUpdateManyWithoutMessagesInput>
  }

  export type message_reactionsScalarWhereInput = {
    AND?: message_reactionsScalarWhereInput | message_reactionsScalarWhereInput[]
    OR?: message_reactionsScalarWhereInput[]
    NOT?: message_reactionsScalarWhereInput | message_reactionsScalarWhereInput[]
    messageId?: StringFilter<"message_reactions"> | string
    participant?: StringNullableFilter<"message_reactions"> | string | null
    emoji?: StringFilter<"message_reactions"> | string
    createdAt?: DateTimeNullableFilter<"message_reactions"> | Date | string | null
    userId?: StringNullableFilter<"message_reactions"> | string | null
    id?: StringFilter<"message_reactions"> | string
  }

  export type chatsUpsertWithoutMessagesInput = {
    update: XOR<chatsUpdateWithoutMessagesInput, chatsUncheckedUpdateWithoutMessagesInput>
    create: XOR<chatsCreateWithoutMessagesInput, chatsUncheckedCreateWithoutMessagesInput>
    where?: chatsWhereInput
  }

  export type chatsUpdateToOneWithWhereWithoutMessagesInput = {
    where?: chatsWhereInput
    data: XOR<chatsUpdateWithoutMessagesInput, chatsUncheckedUpdateWithoutMessagesInput>
  }

  export type chatsUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_status_details?: chat_status_detailsUpdateManyWithoutChatsNestedInput
    chatparticipants?: chatparticipantsUpdateManyWithoutChatsNestedInput
  }

  export type chatsUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    lastMessage?: NullableStringFieldUpdateOperationsInput | string | null
    lastMessageTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    unReadCount?: NullableIntFieldUpdateOperationsInput | number | null
    isOnline?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isTyping?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    isarchived?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ismuted?: NullableBoolFieldUpdateOperationsInput | boolean | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    closedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    closeReason?: NullableStringFieldUpdateOperationsInput | string | null
    participants?: NullableJsonNullValueInput | InputJsonValue
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    chat_status_details?: chat_status_detailsUncheckedUpdateManyWithoutChatsNestedInput
    chatparticipants?: chatparticipantsUncheckedUpdateManyWithoutChatsNestedInput
  }

  export type whatsmeow_app_state_versionCreateWithoutWhatsmeow_app_state_mutation_macsInput = {
    name: string
    version: bigint | number
    hash: Uint8Array
    whatsmeow_device: whatsmeow_deviceCreateNestedOneWithoutWhatsmeow_app_state_versionInput
  }

  export type whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_app_state_mutation_macsInput = {
    jid: string
    name: string
    version: bigint | number
    hash: Uint8Array
  }

  export type whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_app_state_mutation_macsInput = {
    where: whatsmeow_app_state_versionWhereUniqueInput
    create: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_app_state_mutation_macsInput>
  }

  export type whatsmeow_app_state_versionUpsertWithoutWhatsmeow_app_state_mutation_macsInput = {
    update: XOR<whatsmeow_app_state_versionUpdateWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_app_state_mutation_macsInput>
    create: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_app_state_mutation_macsInput>
    where?: whatsmeow_app_state_versionWhereInput
  }

  export type whatsmeow_app_state_versionUpdateToOneWithWhereWithoutWhatsmeow_app_state_mutation_macsInput = {
    where?: whatsmeow_app_state_versionWhereInput
    data: XOR<whatsmeow_app_state_versionUpdateWithoutWhatsmeow_app_state_mutation_macsInput, whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_app_state_mutation_macsInput>
  }

  export type whatsmeow_app_state_versionUpdateWithoutWhatsmeow_app_state_mutation_macsInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_device?: whatsmeow_deviceUpdateOneRequiredWithoutWhatsmeow_app_state_versionNestedInput
  }

  export type whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_app_state_mutation_macsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_app_state_sync_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_sync_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_app_state_sync_keysInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_sync_keysInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_app_state_sync_keysInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_sync_keysInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_sync_keysInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_app_state_sync_keysInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_sync_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_sync_keysInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_sync_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_sync_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput = {
    version: bigint | number
    index_mac: Uint8Array
    value_mac: Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput = {
    version: bigint | number
    index_mac: Uint8Array
    value_mac: Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsCreateOrConnectWithoutWhatsmeow_app_state_versionInput = {
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
    create: XOR<whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInputEnvelope = {
    data: whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInput | whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_app_state_versionInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_versionInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_app_state_versionInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_app_state_mutation_macsUpsertWithWhereUniqueWithoutWhatsmeow_app_state_versionInput = {
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
    update: XOR<whatsmeow_app_state_mutation_macsUpdateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedUpdateWithoutWhatsmeow_app_state_versionInput>
    create: XOR<whatsmeow_app_state_mutation_macsCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedCreateWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_app_state_mutation_macsUpdateWithWhereUniqueWithoutWhatsmeow_app_state_versionInput = {
    where: whatsmeow_app_state_mutation_macsWhereUniqueInput
    data: XOR<whatsmeow_app_state_mutation_macsUpdateWithoutWhatsmeow_app_state_versionInput, whatsmeow_app_state_mutation_macsUncheckedUpdateWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_app_state_mutation_macsUpdateManyWithWhereWithoutWhatsmeow_app_state_versionInput = {
    where: whatsmeow_app_state_mutation_macsScalarWhereInput
    data: XOR<whatsmeow_app_state_mutation_macsUpdateManyMutationInput, whatsmeow_app_state_mutation_macsUncheckedUpdateManyWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_app_state_mutation_macsScalarWhereInput = {
    AND?: whatsmeow_app_state_mutation_macsScalarWhereInput | whatsmeow_app_state_mutation_macsScalarWhereInput[]
    OR?: whatsmeow_app_state_mutation_macsScalarWhereInput[]
    NOT?: whatsmeow_app_state_mutation_macsScalarWhereInput | whatsmeow_app_state_mutation_macsScalarWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_mutation_macs"> | string
    name?: StringFilter<"whatsmeow_app_state_mutation_macs"> | string
    version?: BigIntFilter<"whatsmeow_app_state_mutation_macs"> | bigint | number
    index_mac?: BytesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
    value_mac?: BytesFilter<"whatsmeow_app_state_mutation_macs"> | Uint8Array
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_app_state_versionInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_versionInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_app_state_versionInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_app_state_versionInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_versionInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_versionInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_app_state_versionInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_app_state_versionInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_chat_settingsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_chat_settingsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_chat_settingsInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_chat_settingsInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_chat_settingsInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_chat_settingsInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_chat_settingsInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_chat_settingsInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_chat_settingsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_chat_settingsInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_chat_settingsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_chat_settingsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_contactsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_contactsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_contactsInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_contactsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_contactsInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_contactsInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_contactsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_contactsInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_contactsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_contactsInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_contactsInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_contactsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_contactsInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_contactsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_contactsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput = {
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint | number
    fingerprint: Uint8Array
  }

  export type whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput = {
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint | number
    fingerprint: Uint8Array
  }

  export type whatsmeow_app_state_sync_keysCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
    create: XOR<whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInput | whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput = {
    name: string
    version: bigint | number
    hash: Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsCreateNestedManyWithoutWhatsmeow_app_state_versionInput
  }

  export type whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput = {
    name: string
    version: bigint | number
    hash: Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsUncheckedCreateNestedManyWithoutWhatsmeow_app_state_versionInput
  }

  export type whatsmeow_app_state_versionCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_versionWhereUniqueInput
    create: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInput | whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput = {
    chat_jid: string
    muted_until?: bigint | number
    pinned?: boolean
    archived?: boolean
  }

  export type whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput = {
    chat_jid: string
    muted_until?: bigint | number
    pinned?: boolean
    archived?: boolean
  }

  export type whatsmeow_chat_settingsCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_chat_settingsWhereUniqueInput
    create: XOR<whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInput | whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput = {
    their_jid: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
    redacted_phone?: string | null
  }

  export type whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput = {
    their_jid: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
    redacted_phone?: string | null
  }

  export type whatsmeow_contactsCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_contactsWhereUniqueInput
    create: XOR<whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_contactsCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_contactsCreateManyWhatsmeow_deviceInput | whatsmeow_contactsCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput = {
    ciphertext_hash: Uint8Array
    plaintext?: Uint8Array | null
    server_timestamp: bigint | number
    insert_timestamp: bigint | number
  }

  export type whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput = {
    ciphertext_hash: Uint8Array
    plaintext?: Uint8Array | null
    server_timestamp: bigint | number
    insert_timestamp: bigint | number
  }

  export type whatsmeow_event_bufferCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_event_bufferWhereUniqueInput
    create: XOR<whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_event_bufferCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_event_bufferCreateManyWhatsmeow_deviceInput | whatsmeow_event_bufferCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput = {
    their_id: string
    identity: Uint8Array
  }

  export type whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput = {
    their_id: string
    identity: Uint8Array
  }

  export type whatsmeow_identity_keysCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_identity_keysWhereUniqueInput
    create: XOR<whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_identity_keysCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_identity_keysCreateManyWhatsmeow_deviceInput | whatsmeow_identity_keysCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput = {
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
  }

  export type whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput = {
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
  }

  export type whatsmeow_message_secretsCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_message_secretsWhereUniqueInput
    create: XOR<whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_message_secretsCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_message_secretsCreateManyWhatsmeow_deviceInput | whatsmeow_message_secretsCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput = {
    key_id: number
    key: Uint8Array
    uploaded: boolean
  }

  export type whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput = {
    key_id: number
    key: Uint8Array
    uploaded: boolean
  }

  export type whatsmeow_pre_keysCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_pre_keysWhereUniqueInput
    create: XOR<whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_pre_keysCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_pre_keysCreateManyWhatsmeow_deviceInput | whatsmeow_pre_keysCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput = {
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
  }

  export type whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput = {
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
  }

  export type whatsmeow_sender_keysCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sender_keysWhereUniqueInput
    create: XOR<whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sender_keysCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_sender_keysCreateManyWhatsmeow_deviceInput | whatsmeow_sender_keysCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput = {
    their_id: string
    session?: Uint8Array | null
  }

  export type whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput = {
    their_id: string
    session?: Uint8Array | null
  }

  export type whatsmeow_sessionsCreateOrConnectWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sessionsWhereUniqueInput
    create: XOR<whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sessionsCreateManyWhatsmeow_deviceInputEnvelope = {
    data: whatsmeow_sessionsCreateManyWhatsmeow_deviceInput | whatsmeow_sessionsCreateManyWhatsmeow_deviceInput[]
    skipDuplicates?: boolean
  }

  export type whatsmeow_app_state_sync_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
    update: XOR<whatsmeow_app_state_sync_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_app_state_sync_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_sync_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_sync_keysWhereUniqueInput
    data: XOR<whatsmeow_app_state_sync_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_sync_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_sync_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_sync_keysScalarWhereInput
    data: XOR<whatsmeow_app_state_sync_keysUpdateManyMutationInput, whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_sync_keysScalarWhereInput = {
    AND?: whatsmeow_app_state_sync_keysScalarWhereInput | whatsmeow_app_state_sync_keysScalarWhereInput[]
    OR?: whatsmeow_app_state_sync_keysScalarWhereInput[]
    NOT?: whatsmeow_app_state_sync_keysScalarWhereInput | whatsmeow_app_state_sync_keysScalarWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_sync_keys"> | string
    key_id?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    key_data?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
    timestamp?: BigIntFilter<"whatsmeow_app_state_sync_keys"> | bigint | number
    fingerprint?: BytesFilter<"whatsmeow_app_state_sync_keys"> | Uint8Array
  }

  export type whatsmeow_app_state_versionUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_versionWhereUniqueInput
    update: XOR<whatsmeow_app_state_versionUpdateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_app_state_versionCreateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_versionUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_versionWhereUniqueInput
    data: XOR<whatsmeow_app_state_versionUpdateWithoutWhatsmeow_deviceInput, whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_versionUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_app_state_versionScalarWhereInput
    data: XOR<whatsmeow_app_state_versionUpdateManyMutationInput, whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_app_state_versionScalarWhereInput = {
    AND?: whatsmeow_app_state_versionScalarWhereInput | whatsmeow_app_state_versionScalarWhereInput[]
    OR?: whatsmeow_app_state_versionScalarWhereInput[]
    NOT?: whatsmeow_app_state_versionScalarWhereInput | whatsmeow_app_state_versionScalarWhereInput[]
    jid?: StringFilter<"whatsmeow_app_state_version"> | string
    name?: StringFilter<"whatsmeow_app_state_version"> | string
    version?: BigIntFilter<"whatsmeow_app_state_version"> | bigint | number
    hash?: BytesFilter<"whatsmeow_app_state_version"> | Uint8Array
  }

  export type whatsmeow_chat_settingsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_chat_settingsWhereUniqueInput
    update: XOR<whatsmeow_chat_settingsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_chat_settingsCreateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_chat_settingsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_chat_settingsWhereUniqueInput
    data: XOR<whatsmeow_chat_settingsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_chat_settingsUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_chat_settingsUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_chat_settingsScalarWhereInput
    data: XOR<whatsmeow_chat_settingsUpdateManyMutationInput, whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_chat_settingsScalarWhereInput = {
    AND?: whatsmeow_chat_settingsScalarWhereInput | whatsmeow_chat_settingsScalarWhereInput[]
    OR?: whatsmeow_chat_settingsScalarWhereInput[]
    NOT?: whatsmeow_chat_settingsScalarWhereInput | whatsmeow_chat_settingsScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_chat_settings"> | string
    chat_jid?: StringFilter<"whatsmeow_chat_settings"> | string
    muted_until?: BigIntFilter<"whatsmeow_chat_settings"> | bigint | number
    pinned?: BoolFilter<"whatsmeow_chat_settings"> | boolean
    archived?: BoolFilter<"whatsmeow_chat_settings"> | boolean
  }

  export type whatsmeow_contactsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_contactsWhereUniqueInput
    update: XOR<whatsmeow_contactsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_contactsCreateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_contactsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_contactsWhereUniqueInput
    data: XOR<whatsmeow_contactsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_contactsUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_contactsUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_contactsScalarWhereInput
    data: XOR<whatsmeow_contactsUpdateManyMutationInput, whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_contactsScalarWhereInput = {
    AND?: whatsmeow_contactsScalarWhereInput | whatsmeow_contactsScalarWhereInput[]
    OR?: whatsmeow_contactsScalarWhereInput[]
    NOT?: whatsmeow_contactsScalarWhereInput | whatsmeow_contactsScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_contacts"> | string
    their_jid?: StringFilter<"whatsmeow_contacts"> | string
    first_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    full_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    push_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    business_name?: StringNullableFilter<"whatsmeow_contacts"> | string | null
    redacted_phone?: StringNullableFilter<"whatsmeow_contacts"> | string | null
  }

  export type whatsmeow_event_bufferUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_event_bufferWhereUniqueInput
    update: XOR<whatsmeow_event_bufferUpdateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_event_bufferCreateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_event_bufferUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_event_bufferWhereUniqueInput
    data: XOR<whatsmeow_event_bufferUpdateWithoutWhatsmeow_deviceInput, whatsmeow_event_bufferUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_event_bufferUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_event_bufferScalarWhereInput
    data: XOR<whatsmeow_event_bufferUpdateManyMutationInput, whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_event_bufferScalarWhereInput = {
    AND?: whatsmeow_event_bufferScalarWhereInput | whatsmeow_event_bufferScalarWhereInput[]
    OR?: whatsmeow_event_bufferScalarWhereInput[]
    NOT?: whatsmeow_event_bufferScalarWhereInput | whatsmeow_event_bufferScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_event_buffer"> | string
    ciphertext_hash?: BytesFilter<"whatsmeow_event_buffer"> | Uint8Array
    plaintext?: BytesNullableFilter<"whatsmeow_event_buffer"> | Uint8Array | null
    server_timestamp?: BigIntFilter<"whatsmeow_event_buffer"> | bigint | number
    insert_timestamp?: BigIntFilter<"whatsmeow_event_buffer"> | bigint | number
  }

  export type whatsmeow_identity_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_identity_keysWhereUniqueInput
    update: XOR<whatsmeow_identity_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_identity_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_identity_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_identity_keysWhereUniqueInput
    data: XOR<whatsmeow_identity_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_identity_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_identity_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_identity_keysScalarWhereInput
    data: XOR<whatsmeow_identity_keysUpdateManyMutationInput, whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_identity_keysScalarWhereInput = {
    AND?: whatsmeow_identity_keysScalarWhereInput | whatsmeow_identity_keysScalarWhereInput[]
    OR?: whatsmeow_identity_keysScalarWhereInput[]
    NOT?: whatsmeow_identity_keysScalarWhereInput | whatsmeow_identity_keysScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_identity_keys"> | string
    their_id?: StringFilter<"whatsmeow_identity_keys"> | string
    identity?: BytesFilter<"whatsmeow_identity_keys"> | Uint8Array
  }

  export type whatsmeow_message_secretsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_message_secretsWhereUniqueInput
    update: XOR<whatsmeow_message_secretsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_message_secretsCreateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_message_secretsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_message_secretsWhereUniqueInput
    data: XOR<whatsmeow_message_secretsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_message_secretsUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_message_secretsUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_message_secretsScalarWhereInput
    data: XOR<whatsmeow_message_secretsUpdateManyMutationInput, whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_message_secretsScalarWhereInput = {
    AND?: whatsmeow_message_secretsScalarWhereInput | whatsmeow_message_secretsScalarWhereInput[]
    OR?: whatsmeow_message_secretsScalarWhereInput[]
    NOT?: whatsmeow_message_secretsScalarWhereInput | whatsmeow_message_secretsScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    chat_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    sender_jid?: StringFilter<"whatsmeow_message_secrets"> | string
    message_id?: StringFilter<"whatsmeow_message_secrets"> | string
    key?: BytesFilter<"whatsmeow_message_secrets"> | Uint8Array
  }

  export type whatsmeow_pre_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_pre_keysWhereUniqueInput
    update: XOR<whatsmeow_pre_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_pre_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_pre_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_pre_keysWhereUniqueInput
    data: XOR<whatsmeow_pre_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_pre_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_pre_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_pre_keysScalarWhereInput
    data: XOR<whatsmeow_pre_keysUpdateManyMutationInput, whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_pre_keysScalarWhereInput = {
    AND?: whatsmeow_pre_keysScalarWhereInput | whatsmeow_pre_keysScalarWhereInput[]
    OR?: whatsmeow_pre_keysScalarWhereInput[]
    NOT?: whatsmeow_pre_keysScalarWhereInput | whatsmeow_pre_keysScalarWhereInput[]
    jid?: StringFilter<"whatsmeow_pre_keys"> | string
    key_id?: IntFilter<"whatsmeow_pre_keys"> | number
    key?: BytesFilter<"whatsmeow_pre_keys"> | Uint8Array
    uploaded?: BoolFilter<"whatsmeow_pre_keys"> | boolean
  }

  export type whatsmeow_sender_keysUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sender_keysWhereUniqueInput
    update: XOR<whatsmeow_sender_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_sender_keysCreateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sender_keysUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sender_keysWhereUniqueInput
    data: XOR<whatsmeow_sender_keysUpdateWithoutWhatsmeow_deviceInput, whatsmeow_sender_keysUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sender_keysUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sender_keysScalarWhereInput
    data: XOR<whatsmeow_sender_keysUpdateManyMutationInput, whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sender_keysScalarWhereInput = {
    AND?: whatsmeow_sender_keysScalarWhereInput | whatsmeow_sender_keysScalarWhereInput[]
    OR?: whatsmeow_sender_keysScalarWhereInput[]
    NOT?: whatsmeow_sender_keysScalarWhereInput | whatsmeow_sender_keysScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_sender_keys"> | string
    chat_id?: StringFilter<"whatsmeow_sender_keys"> | string
    sender_id?: StringFilter<"whatsmeow_sender_keys"> | string
    sender_key?: BytesFilter<"whatsmeow_sender_keys"> | Uint8Array
  }

  export type whatsmeow_sessionsUpsertWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sessionsWhereUniqueInput
    update: XOR<whatsmeow_sessionsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedUpdateWithoutWhatsmeow_deviceInput>
    create: XOR<whatsmeow_sessionsCreateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedCreateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sessionsUpdateWithWhereUniqueWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sessionsWhereUniqueInput
    data: XOR<whatsmeow_sessionsUpdateWithoutWhatsmeow_deviceInput, whatsmeow_sessionsUncheckedUpdateWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sessionsUpdateManyWithWhereWithoutWhatsmeow_deviceInput = {
    where: whatsmeow_sessionsScalarWhereInput
    data: XOR<whatsmeow_sessionsUpdateManyMutationInput, whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceInput>
  }

  export type whatsmeow_sessionsScalarWhereInput = {
    AND?: whatsmeow_sessionsScalarWhereInput | whatsmeow_sessionsScalarWhereInput[]
    OR?: whatsmeow_sessionsScalarWhereInput[]
    NOT?: whatsmeow_sessionsScalarWhereInput | whatsmeow_sessionsScalarWhereInput[]
    our_jid?: StringFilter<"whatsmeow_sessions"> | string
    their_id?: StringFilter<"whatsmeow_sessions"> | string
    session?: BytesNullableFilter<"whatsmeow_sessions"> | Uint8Array | null
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_event_bufferInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_event_bufferInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_event_bufferInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_event_bufferInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_event_bufferInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_event_bufferInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_event_bufferInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_event_bufferInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_event_bufferInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_event_bufferInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_event_bufferInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_event_bufferInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_identity_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_identity_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_identity_keysInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_identity_keysInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_identity_keysInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_identity_keysInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_identity_keysInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_identity_keysInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_identity_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_identity_keysInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_identity_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_identity_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_message_secretsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_message_secretsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_message_secretsInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_message_secretsInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_message_secretsInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_message_secretsInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_message_secretsInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_message_secretsInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_message_secretsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_message_secretsInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_message_secretsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_message_secretsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_pre_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_pre_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_pre_keysInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_pre_keysInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_pre_keysInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_pre_keysInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_pre_keysInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_pre_keysInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_pre_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_pre_keysInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_pre_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_pre_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_sender_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sender_keysInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_sender_keysInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sender_keysInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_sender_keysInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sender_keysInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sender_keysInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_sender_keysInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_sender_keysInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sender_keysInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_sender_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sender_keysInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sessions?: whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceCreateWithoutWhatsmeow_sessionsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sessionsInput = {
    jid: string
    lid?: string | null
    facebook_uuid?: string | null
    registration_id: bigint | number
    noise_key: Uint8Array
    identity_key: Uint8Array
    signed_pre_key: Uint8Array
    signed_pre_key_id: number
    signed_pre_key_sig: Uint8Array
    adv_key: Uint8Array
    adv_details: Uint8Array
    adv_account_sig: Uint8Array
    adv_account_sig_key: Uint8Array
    adv_device_sig: Uint8Array
    platform?: string
    business_name?: string
    push_name?: string
    lid_migration_ts?: bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedCreateNestedManyWithoutWhatsmeow_deviceInput
  }

  export type whatsmeow_deviceCreateOrConnectWithoutWhatsmeow_sessionsInput = {
    where: whatsmeow_deviceWhereUniqueInput
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sessionsInput>
  }

  export type whatsmeow_deviceUpsertWithoutWhatsmeow_sessionsInput = {
    update: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sessionsInput>
    create: XOR<whatsmeow_deviceCreateWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUncheckedCreateWithoutWhatsmeow_sessionsInput>
    where?: whatsmeow_deviceWhereInput
  }

  export type whatsmeow_deviceUpdateToOneWithWhereWithoutWhatsmeow_sessionsInput = {
    where?: whatsmeow_deviceWhereInput
    data: XOR<whatsmeow_deviceUpdateWithoutWhatsmeow_sessionsInput, whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sessionsInput>
  }

  export type whatsmeow_deviceUpdateWithoutWhatsmeow_sessionsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type whatsmeow_deviceUncheckedUpdateWithoutWhatsmeow_sessionsInput = {
    jid?: StringFieldUpdateOperationsInput | string
    lid?: NullableStringFieldUpdateOperationsInput | string | null
    facebook_uuid?: NullableStringFieldUpdateOperationsInput | string | null
    registration_id?: BigIntFieldUpdateOperationsInput | bigint | number
    noise_key?: BytesFieldUpdateOperationsInput | Uint8Array
    identity_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key?: BytesFieldUpdateOperationsInput | Uint8Array
    signed_pre_key_id?: IntFieldUpdateOperationsInput | number
    signed_pre_key_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_details?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_account_sig_key?: BytesFieldUpdateOperationsInput | Uint8Array
    adv_device_sig?: BytesFieldUpdateOperationsInput | Uint8Array
    platform?: StringFieldUpdateOperationsInput | string
    business_name?: StringFieldUpdateOperationsInput | string
    push_name?: StringFieldUpdateOperationsInput | string
    lid_migration_ts?: BigIntFieldUpdateOperationsInput | bigint | number
    whatsmeow_app_state_sync_keys?: whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_app_state_version?: whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_chat_settings?: whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_contacts?: whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_event_buffer?: whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_identity_keys?: whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_message_secrets?: whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_pre_keys?: whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
    whatsmeow_sender_keys?: whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceNestedInput
  }

  export type chat_status_detailsCreateManyChatsInput = {
    id?: number
    status: string
    changed_by?: string | null
    changed_at?: Date | string | null
    reason?: string | null
    notes?: string | null
  }

  export type chatparticipantsCreateManyChatsInput = {
    contactid: string
  }

  export type messagesCreateManyChatsInput = {
    id: string
    message: string
    timeStamp?: Date | string | null
    isDelivered?: boolean | null
    isRead?: boolean | null
    messageType?: string | null
    isFromMe?: boolean | null
    contactId?: string | null
    isEdit?: boolean | null
    pushname?: string | null
    mediaPath?: string | null
    note?: string | null
    isPinned?: boolean | null
    userId?: string | null
    replyToMessageId?: string | null
  }

  export type chat_status_detailsUpdateWithoutChatsInput = {
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chat_status_detailsUncheckedUpdateWithoutChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chat_status_detailsUncheckedUpdateManyWithoutChatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    changed_by?: NullableStringFieldUpdateOperationsInput | string | null
    changed_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatparticipantsUpdateWithoutChatsInput = {
    contacts?: contactsUpdateOneRequiredWithoutChatparticipantsNestedInput
  }

  export type chatparticipantsUncheckedUpdateWithoutChatsInput = {
    contactid?: StringFieldUpdateOperationsInput | string
  }

  export type chatparticipantsUncheckedUpdateManyWithoutChatsInput = {
    contactid?: StringFieldUpdateOperationsInput | string
  }

  export type messagesUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    message_reactions?: message_reactionsUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    message_reactions?: message_reactionsUncheckedUpdateManyWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateManyWithoutChatsInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    timeStamp?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDelivered?: NullableBoolFieldUpdateOperationsInput | boolean | null
    isRead?: NullableBoolFieldUpdateOperationsInput | boolean | null
    messageType?: NullableStringFieldUpdateOperationsInput | string | null
    isFromMe?: NullableBoolFieldUpdateOperationsInput | boolean | null
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    isEdit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    pushname?: NullableStringFieldUpdateOperationsInput | string | null
    mediaPath?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isPinned?: NullableBoolFieldUpdateOperationsInput | boolean | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    replyToMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type chatparticipantsCreateManyContactsInput = {
    chatid: string
  }

  export type chatparticipantsUpdateWithoutContactsInput = {
    chats?: chatsUpdateOneRequiredWithoutChatparticipantsNestedInput
  }

  export type chatparticipantsUncheckedUpdateWithoutContactsInput = {
    chatid?: StringFieldUpdateOperationsInput | string
  }

  export type chatparticipantsUncheckedUpdateManyWithoutContactsInput = {
    chatid?: StringFieldUpdateOperationsInput | string
  }

  export type message_reactionsCreateManyMessagesInput = {
    participant?: string | null
    emoji: string
    createdAt?: Date | string | null
    userId?: string | null
    id: string
  }

  export type message_reactionsUpdateWithoutMessagesInput = {
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type message_reactionsUncheckedUpdateWithoutMessagesInput = {
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type message_reactionsUncheckedUpdateManyWithoutMessagesInput = {
    participant?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: StringFieldUpdateOperationsInput | string
    createdAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type whatsmeow_app_state_mutation_macsCreateManyWhatsmeow_app_state_versionInput = {
    version: bigint | number
    index_mac: Uint8Array
    value_mac: Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUpdateWithoutWhatsmeow_app_state_versionInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUncheckedUpdateWithoutWhatsmeow_app_state_versionInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_mutation_macsUncheckedUpdateManyWithoutWhatsmeow_app_state_versionInput = {
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    index_mac?: BytesFieldUpdateOperationsInput | Uint8Array
    value_mac?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysCreateManyWhatsmeow_deviceInput = {
    key_id: Uint8Array
    key_data: Uint8Array
    timestamp: bigint | number
    fingerprint: Uint8Array
  }

  export type whatsmeow_app_state_versionCreateManyWhatsmeow_deviceInput = {
    name: string
    version: bigint | number
    hash: Uint8Array
  }

  export type whatsmeow_chat_settingsCreateManyWhatsmeow_deviceInput = {
    chat_jid: string
    muted_until?: bigint | number
    pinned?: boolean
    archived?: boolean
  }

  export type whatsmeow_contactsCreateManyWhatsmeow_deviceInput = {
    their_jid: string
    first_name?: string | null
    full_name?: string | null
    push_name?: string | null
    business_name?: string | null
    redacted_phone?: string | null
  }

  export type whatsmeow_event_bufferCreateManyWhatsmeow_deviceInput = {
    ciphertext_hash: Uint8Array
    plaintext?: Uint8Array | null
    server_timestamp: bigint | number
    insert_timestamp: bigint | number
  }

  export type whatsmeow_identity_keysCreateManyWhatsmeow_deviceInput = {
    their_id: string
    identity: Uint8Array
  }

  export type whatsmeow_message_secretsCreateManyWhatsmeow_deviceInput = {
    chat_jid: string
    sender_jid: string
    message_id: string
    key: Uint8Array
  }

  export type whatsmeow_pre_keysCreateManyWhatsmeow_deviceInput = {
    key_id: number
    key: Uint8Array
    uploaded: boolean
  }

  export type whatsmeow_sender_keysCreateManyWhatsmeow_deviceInput = {
    chat_id: string
    sender_id: string
    sender_key: Uint8Array
  }

  export type whatsmeow_sessionsCreateManyWhatsmeow_deviceInput = {
    their_id: string
    session?: Uint8Array | null
  }

  export type whatsmeow_app_state_sync_keysUpdateWithoutWhatsmeow_deviceInput = {
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_sync_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    key_id?: BytesFieldUpdateOperationsInput | Uint8Array
    key_data?: BytesFieldUpdateOperationsInput | Uint8Array
    timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    fingerprint?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_app_state_versionUpdateWithoutWhatsmeow_deviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsUpdateManyWithoutWhatsmeow_app_state_versionNestedInput
  }

  export type whatsmeow_app_state_versionUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
    whatsmeow_app_state_mutation_macs?: whatsmeow_app_state_mutation_macsUncheckedUpdateManyWithoutWhatsmeow_app_state_versionNestedInput
  }

  export type whatsmeow_app_state_versionUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    name?: StringFieldUpdateOperationsInput | string
    version?: BigIntFieldUpdateOperationsInput | bigint | number
    hash?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_chat_settingsUpdateWithoutWhatsmeow_deviceInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_chat_settingsUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_chat_settingsUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    muted_until?: BigIntFieldUpdateOperationsInput | bigint | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    archived?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_contactsUpdateWithoutWhatsmeow_deviceInput = {
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type whatsmeow_contactsUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type whatsmeow_contactsUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    their_jid?: StringFieldUpdateOperationsInput | string
    first_name?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: NullableStringFieldUpdateOperationsInput | string | null
    push_name?: NullableStringFieldUpdateOperationsInput | string | null
    business_name?: NullableStringFieldUpdateOperationsInput | string | null
    redacted_phone?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type whatsmeow_event_bufferUpdateWithoutWhatsmeow_deviceInput = {
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_event_bufferUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_event_bufferUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    ciphertext_hash?: BytesFieldUpdateOperationsInput | Uint8Array
    plaintext?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
    server_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
    insert_timestamp?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type whatsmeow_identity_keysUpdateWithoutWhatsmeow_deviceInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_identity_keysUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_identity_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    identity?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_message_secretsUpdateWithoutWhatsmeow_deviceInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_message_secretsUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_message_secretsUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    chat_jid?: StringFieldUpdateOperationsInput | string
    sender_jid?: StringFieldUpdateOperationsInput | string
    message_id?: StringFieldUpdateOperationsInput | string
    key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_pre_keysUpdateWithoutWhatsmeow_deviceInput = {
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_pre_keysUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_pre_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    key_id?: IntFieldUpdateOperationsInput | number
    key?: BytesFieldUpdateOperationsInput | Uint8Array
    uploaded?: BoolFieldUpdateOperationsInput | boolean
  }

  export type whatsmeow_sender_keysUpdateWithoutWhatsmeow_deviceInput = {
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_sender_keysUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_sender_keysUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    chat_id?: StringFieldUpdateOperationsInput | string
    sender_id?: StringFieldUpdateOperationsInput | string
    sender_key?: BytesFieldUpdateOperationsInput | Uint8Array
  }

  export type whatsmeow_sessionsUpdateWithoutWhatsmeow_deviceInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type whatsmeow_sessionsUncheckedUpdateWithoutWhatsmeow_deviceInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }

  export type whatsmeow_sessionsUncheckedUpdateManyWithoutWhatsmeow_deviceInput = {
    their_id?: StringFieldUpdateOperationsInput | string
    session?: NullableBytesFieldUpdateOperationsInput | Uint8Array | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}